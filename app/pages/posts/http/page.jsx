import Cover from "../../../Components/js/Cover";
import UrlProtocol from "../../../Components/js/UrlProtocol";

export const metadata = {
    title: "http:",
    description: "Протокол HTTP"
  };

export default function http(){
    return (
        <div>
            <Cover title="Все о Программировании" namePage="http:" image="/allIt.jpg" isShowBtn={false}/>
            <div className="text">
                <q>HTTP (англ. Hypertext Transfer Protocol — «протокол передачи гипертекста») — сетевой протокол прикладного уровня, который изначально предназначался для получения с серверов гипертекстовых документов в формате HTML, а с течением времени стал универсальным средством взаимодействия между узлами как Всемирной паутины, так и изолированных веб-инфраструктур. Определение по основным документациям: HTTP — протокол уровня приложений для распределённых, объединённых, гипермедийных информационных систем, используемый в глобальной информационной инициативе Всемирной паутины с 1990 года.</q>
                <br/>
                <br/>
                <h2>Основные свойства</h2>
                <p>Основой HTTP является технология «клиент-сервер», то есть предполагается существование:<br/></p>
                <ul className="list">
                    <li>потребителей (клиентов), которые инициируют соединение и посылают запрос;</li>
                    <li>поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</li>
                </ul>
                <br/>
                <p>HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов. В 2006 году в Северной Америке доля HTTP-трафика превысила долю P2P-сетей и составила 46 %, из которых почти половина — это передача потокового видео и звука.<br/><br/>
                
                HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV.<br/><br/>
                
                Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.<br/><br/>
                
                HTTP — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий                 запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.<br/><br/>
                
                Большинство протоколов предусматривает установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.<br/><br/>
                
                При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных) определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющий клиенту однозначно определить, каким образом обрабатывать присланные данные. Это особенно важно при работе с CGI-скриптами, когда расширение имени файла указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в зависимости от аргументов запроса и своих собственных соображений может                 порождать ответы разных типов — в простейшем случае картинки в разных форматах).<br/><br/>
                
                Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому CGI-скрипту. Для этого же в HTML были введены формы.<br/><br/>
                
                Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, созданная фирмой DEC), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании, основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.</p>
                <br/>
                <br/>
                <h2>Программное обеспечение</h2>
                <p>Всё программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:<br/></p>
                <ul className="list">
                    <li>Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);</li>
                    <li>Клиенты — конечные потребители услуг сервера (отправка запроса);</li>
                    <li>Прокси (посредники) для выполнения транспортных служб.</li>
                </ul>
                <br/>
                <h3>Клиенты</h3>
                <p>Первоначально протокол HTTP разрабатывался для доступа к гипертекстовым документам Всемирной паутины. Поэтому основными реализациями клиентов являются браузеры (агенты пользователя). Для просмотра сохранённого содержимого сайтов на компьютере без соединения с Интернетом были придуманы офлайн-браузеры. При нестабильном соединении для загрузки больших файлов используются менеджеры закачек; они позволяют в любое время докачать указанные файлы после потери соединения с веб-сервером. Некоторые виртуальные атласы (такие как Google Планета Земля и NASA World Wind) тоже используют HTTP.<br/><br/>

                Нередко протокол HTTP используется программами для скачивания обновлений.<br/><br/>

                Целый комплекс программ-роботов используется в поисковых системах Интернета. Среди них веб-пауки (краулеры), которые производят проход по гиперссылкам, составляют базу данных ресурсов серверов и сохраняют их содержимое для дальнейшего анализа.</p>
                <h3>Исходные серверы</h3>
                <p>Основные реализации: Apache, Internet Information Services (IIS), nginx, LiteSpeed Web Server (LSWS), Google Web Server, lighttpd.</p>
                <h3>Прокси-серверы</h3>
                <p>Основные реализации: Squid, UserGate, Multiproxy, Naviscope, nginx.</p>
                <br/>
                <br/>
                <h2>Структура HTTP-сообщения</h2>
                <p>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</p>
                <ol className="list">
                    <li>Стартовая строка (<i>Starting line</i>) — определяет тип сообщения.</li>
                    <li>Заголовки (<i>Headers</i>) — характеризуют тело сообщения, параметры передачи и прочие сведения.</li>
                    <li>Тело сообщения (<i>Message Body</i>) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.</li>
                </ol>
                <br/>
                <p>Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа — только тело сообщения.<br/><br/>

                Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок Host.</p>
                <h3>Стартовая строка</h3>
                <p>Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:</p>
                <br/>
                <ul className="list">
                    <li><span className="code-mini">Метод URI</span> — для версии протокола 0.9;</li>
                    <li><span className="code-mini">Метод URI HTTP/Версия</span> — для остальных версий.</li>
                </ul>
                <p>Здесь:</p>
                <br/>
                <ul className="list">
                    <li>Метод (англ. Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод <span className="code-mini">GET</span>, список методов для версии 1.1 представлен ниже.</li>
                    <li>URI определяет путь к запрашиваемому документу.</li>
                    <li>Версия (англ. Version) — пара разделённых точкой цифр. Например: <span className="code-mini">1.0</span>.</li>
                </ul>
                <p>Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):</p>
                <br/>
                <div className="code">Host: test.user.com</div>
                <br/>
                <p>Стартовая строка ответа сервера имеет следующий формат: <span className="code-mini">HTTP/Версия КодСостояния Пояснение</span>, где:</p>
                <br/>
                <ul className="list">
                    <li>версия — пара разделённых точкой цифр, как в запросе;</li>
                    <li>код состояния (<i>Status Code</i>) — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;</li>
                    <li>пояснение (<i>Reason Phrase</i>) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.</li>
                </ul>
                <br/>
                <p>Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:</p>
                <br/>
                <div className="code">HTTP/1.0 200 OK</div>
                <br/>
                <h3>Методы</h3>
                <p>Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.<br/>

                Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус <span className="code-mini">501</span> (<span className="code-mini">Not Implemented</span>). Если серверу метод известен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом <span className="code-mini">405</span> (<span className="code-mini">Method Not Allowed</span>). В обоих случаях серверу следует включить в сообщение ответа заголовок <span className="code-mini">Allow</span> со списком поддерживаемых методов.<br/><br/>

                Кроме методов <span className="code-mini">GET</span> и <span className="code-mini">HEAD</span>, часто применяется метод <span className="code-mini">POST</span>.</p>
                <h3>OPTIONS</h3>
                <p>Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок <span className="code-mini">Allow</span> со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.<br/><br/>

                Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.<br/><br/>

                Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «<span className="code-mini">*</span>». Запросы «<span className="code-mini">OPTIONS * HTTP/1.1</span>» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.<br/><br/>

                Результат выполнения этого метода не кэшируется.</p>
                <h3>GET</h3>
                <p>Используется для запроса содержимого указанного ресурса. С помощью метода <span className="code-mini">GET</span> можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.<br/><br/>
                Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «<span className="code-mini">?</span>»:<br/></p>
                <div className="code">GET /path/resource?param1=value1&param2=value2 HTTP/1.1</div>
                <br/>
                <p>Согласно стандарту HTTP, запросы типа <span className="code-mini">GET</span> считаются идемпотентными<br/>
                Кроме обычного метода <span className="code-mini">GET</span>, различают ещё<br/></p>
                <ul className="list">
                    <li>Условный <span className="code-mini">GET</span> — содержит заголовки <span className="code-mini">If-Modified-Since</span>, <span className="code-mini">If-Match</span>, <span className="code-mini">If-Range</span> и подобные;</li>
                    <li>Частичный <span className="code-mini">GET</span> — содержит в запросе <span className="code-mini">Range</span>.</li>
                </ul>
                <br/>
                <p>Порядок выполнения подобных запросов определён стандартами отдельно.</p>
                <h3>HEAD</h3>
                <p>Аналогичен методу <span className="code-mini">GET</span>, за исключением того, что в ответе сервера отсутствует тело. Запрос <span className="code-mini">HEAD</span> обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.

                Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.</p>
                <h3>POST</h3>
                <p>Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода <span className="code-mini">POST</span> обычно загружаются файлы на сервер.<br/><br/>
                В отличие от метода <span className="code-mini">GET</span>, метод <span className="code-mini">POST</span> не считается идемпотентным, то есть многократное повторение одних и тех же запросов <span className="code-mini">POST</span> может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).<br/><br/>

                При результате выполнения <span className="code-mini">200</span> (<span className="code-mini">Ok</span>) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ <span className="code-mini">201</span> (<span className="code-mini">Created</span>) с указанием URI нового ресурса в заголовке <span className="code-mini">Location</span>.<br/><br/>

                Сообщение ответа сервера на выполнение метода <span className="code-mini">POST</span> не кэшируется.
                </p>
                <h3>PUT</h3>
                <p>Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус <span className="code-mini">201</span> (<span className="code-mini">Created</span>). Если же ресурс был изменён, то сервер возвращает <span className="code-mini">200</span> (<span className="code-mini">OK</span>) или <span className="code-mini">204</span> (<span className="code-mini">No Content</span>). Сервер не должен игнорировать некорректные заголовки <span className="code-mini">Content-*</span>, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или недопустим при текущих условиях, то необходимо вернуть код ошибки <span className="code-mini">501</span> (<span className="code-mini">Not Implemented</span>).<br/><br/>
                Фундаментальное различие методов <span className="code-mini">POST</span> и <span className="code-mini">PUT</span> заключается в понимании предназначений URI ресурсов. Метод <span className="code-mini">POST</span> предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя <span className="code-mini">PUT</span>, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.<br/><br/>

                Сообщения ответов сервера на метод <span className="code-mini">PUT</span> не кэшируются.</p>
                <h3>PATCH</h3>
                <p>Аналогично <span className="code-mini">PUT</span>, но применяется только к фрагменту ресурса</p>
                <h3>DELETE</h3>
                <p>Удаляет указанный ресурс.</p>
                <h3>TRACE</h3>
                <p>Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.</p>
                <h3>CONNECT</h3>
                <p>Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.</p>
                <h3>Коды состояния</h3>
                <p>Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. Примеры:<br/></p>
                <div className="code">
                201 Webpage Created<br/>
                403 Access allowed only for registered users<br/>
                507 Insufficient Storage
                </div>
                <br/>
                <p>Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.<br/><br/>
                
                В настоящее время выделено пять классов кодов состояния</p>
                <br/>
                <table>
                    <tr>
                        <th>Код</th>
                        <th>Класс</th>
                        <th>Назначение</th>
                    </tr>
                    <tr>
                        <td><span className="code-mini">1xx</span></td>
                        <td>Информационный</td>
                        <td>Информирование о процессе передачи.<br/>
                         В HTTP/1.0 — сообщения с такими кодами должны игнорироваться.<br/><br/>

                         В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно.<br/><br/>

                         Сами сообщения от сервера содержат только стартовую строку ответа и, возможно, несколько полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.</td>
                    </tr>
                    <tr>
                        <td><span className="code-mini">2xx</span></td>
                        <td>Успех</td>
                        <td>Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.</td>
                    </tr>
                    <tr>
                        <td><span className="code-mini">3xx</span></td>
                        <td>Перенаправление</td>
                        <td>Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов <span className="code-mini">301</span>, <span className="code-mini">302</span>, <span className="codde-mini">303</span>, <span className="code-mini">305</span> и <span className="code-mini">307</span> относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке <span className="code-mini">Location</span>. При этом допускается использование фрагментов в целевом URI.</td>
                    </tr>
                    <tr>
                        <td><span className="code-mini">4xx</span></td>
                        <td>Ошибка клиент</td>
                        <td>Запрос клиента содержит ошибку. При использовании всех методов, кроме <span className="code-mini">HEAD</span>, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</td>
                    </tr>
                    <tr>
                        <td><span className="code-mini">5xx</span></td>
                        <td>Ошибка сервера</td>
                        <td>Операция не выполнена по вине сервера. Для всех ситуаций, кроме использования метода <span className="code-mini">HEAD</span>, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</td>
                    </tr>
                </table>
                <br/>
                <br/>
                <h2>Заголовки</h2>
                <p>Заголовки HTTP (<i>HTTP Headers</i>) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.<br/><br/>
                Примеры заголовков:<br/></p>
                <div className="code">
                    Server: Apache/2.2.11 (Win32) PHP/5.3.0<br/>
                    Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT<br/>
                    Content-Type: text/plain; charset=windows-1251<br/>
                    Content-Language: ru
                </div>
                <br/>
                <p>В примере выше каждая строка представляет собой один заголовок. При этом то, что находится до двоеточия, называется именем (name), а что после него — значением (value).
                    <br/>
                    <br/>
                    Все заголовки разделяются на четыре основных группы:<br/></p>
                <ul className="list">
                    <li>Общие заголовки (<i>General Headers</i>) — применяются как к запросам, так и к ответам, но не относятся к передаваемым данным.</li>
                    <li>Заголовки запроса (<i>Request Headers</i>) — содержат дополнительную информацию, отправляемую клиентом на сервер.</li>
                    <li>Заголовки ответа (<i>Response Headers</i>) — содержат дополнительную информацию, отправляемую сервером клиенту.</li>
                    <li>Заголовки сущности (<i>Entity Headers</i>) — определяют метаинформацию о теле сущности, либо, если тело отсутствует, о ресурсе, идентифицированном запросом.</li>
                </ul>
                <br/>
                <p>Именно в таком порядке рекомендуется посылать заголовки получателю.<br/><br/>

                   Все необходимые для функционирования HTTP заголовки описаны в основных <span className="code-mini">RFC</span>. Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «<span className="code-mini">X-</span>» для избежания конфликта имён с возможно существующими. Например, как в заголовках <span className="code-mini">X-Powered-By</span> или <span className="code-mini">X-Cache</span>. Некоторые разработчики используют свои индивидуальные префиксы. Примерами таких заголовков могут служить <span className="code-mini">Ms-Echo-Request</span> и <span className="code-mini">Ms-Echo-Reply</span>, введённые корпорацией Microsoft для расширения <span className="code-mini">WebDAV</span>.</p>
                <br/>
                <br/>
                <h2>Тело сообщения</h2>
                <p>Тело HTTP-сообщения (<span className="code-mini">message-body</span>), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта (<span className="code-mini">entity-body</span>) только в том случае, когда применяется кодирование передачи, <span className="code-mini">Transfer-Encoding</span>что указывается полем заголовка <span className="code-mini">Transfer-Encoding</span>.</p>
                <br/>
                <div className="code">
                message-body = entity-body<br/>
                | {"<"}entity-body закодировано согласно<br/>
                Transfer-Encoding{">"}
                </div>
                <br/>
                <p>Поле <span className="code-mini">Transfer-Encoding</span> должно использоваться для указания любого кодирования передачи, применённого приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле <span className="code-mini">Transfer-Encoding</span> — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением в цепочке запросов/ответов.<br/><br/>

                Правила, устанавливающие допустимость тела сообщения в сообщении, отличны для запросов и ответов.<br/><br/>

                Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка <span className="code-mini">Content-Length</span> или <span className="code-mini">Transfer-Encoding</span>. Тело сообщения может быть добавлено в запрос, только когда метод запроса допускает тело объекта.

                Включается или не включается тело сообщения в сообщение ответа — зависит как от метода запроса, так и от кода состояния ответа. Все ответы на запрос с методом <span className="code-mini">HEAD</span> не должны включать тело сообщения, даже если присутствуют поля заголовка объекта (<span className="code-mini"></span>), заставляющие поверить в присутствие объекта. Никакие ответы с кодами состояния <span className="code-mini">1xx</span> (Информационные), <span className="code-mini">204</span> (Нет содержимого, <span className="code-mini"></span>), и <span className="code-mini">304</span> (Не модифицирован, <span className="code-mini">Not Modified</span>) не должны содержать тела сообщения. Все другие ответы содержат тело сообщения, даже если оно имеет нулевую длину.</p>
                <br/>
                <br/>
                <h2>Основные механизмы протокола</h2>
                <h3>Частичные GET</h3>
                <p>HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные GET; возможность их выполнения необязательна (но желательна) для серверов. Частичные GET в основном используются для докачки файлов и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.<br/><br/>

                Для получения фрагмента клиент посылает серверу запрос с заголовком Range, указывая в нём необходимые байтовые диапазоны. Если сервер не понимает частичные запросы (игнорирует заголовок Range), то он вернёт всё содержимое со статусом 200, как и при обычном GET. В случае успешного выполнения сервер возвращает вместо кода 200 ответ со статусом 206 (Partial Content), включая в ответ заголовок Content-Range. Сами фрагменты могут быть переданы двумя способами:<br/></p>
                <ul className="list-code">
                    <li>в ответе помещается заголовок <span className="code-mini">Content-Range</span> с указанием байтовых диапазонов. В соответствии с ними фрагменты последовательно помещаются в основное тело. При этом <span className="code-mini">Content-Length</span> должен соответствовать суммарному объёму всего тела;</li>
                    <li>сервер указывает медиатип <span className="code-mini">multipart/byterangescls
                    </span> для основного содержимого и передаёт фрагменты, указывая соответствующий <span className="code-mini">Content-Range</span> для каждого элемента (см. также «Множественное содержимое»).</li>
                </ul>
                <br/>
                <h3>Условные GET</h3>
                <p>Метод <span className="code-mini">GET</span> изменяется на «условный <span className="code-mini">GET</span>», если сообщение запроса включает в себя поле заголовка <span className="code-mini">If-Modified-Since</span>. В ответ на «условный <span className="code-mini">GET</span>» тело запрашиваемого ресурса передаётся, только если он изменялся после даты, указанной в заголовке <span className="code-mini">If-Modified-Since</span>. Алгоритм определения этого включает в себя следующие случаи:</p>
                <br/>
                <ul className="list">
                    <li>если статус ответа на запрос будет отличаться от «<span className="code-mini">200 OK</span>» или дата, указанная в поле заголовка «<span className="code-mini">If-Modified-Since</span>», некорректна, ответ будет идентичен ответу на обычный запрос <span className="code-mini">GET</span>;</li>
                    <li>если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос <span className="code-mini">GET</span>;</li>
                    <li>если ресурс не изменялся после указанной даты, сервер вернет статус «<span className="code-mini">304 Not Modified</span>».</li>
                </ul>
                <br/>
                <p>Использование метода «условный <span className="code-mini">GET</span>» направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.</p>
                <br/>
                <h3>Согласование содержимого</h3>
                <p>Согласование содержимого (<span className="code-mini">Content Negotiation</span>) — механизм автоматического определения необходимого ресурса при наличии нескольких разнотипных версий документа. Субъектами согласования могут быть не только ресурсы сервера, но и возвращаемые страницы с сообщениями об ошибках (<span className="code-mini">403</span>, <span className="code-mini">404</span> и т. п.).<br/><br/>

                Различают два основных типа согласований:</p>
                <ul className="list">
                    <li>управляемое сервером (<span className="code-mini">server-driven</span>);</li>
                    <li>управляемое клиентом (<span className="code-mini">agent-driven</span>).</li>
                </ul>
                <br/>
                <p>Одновременно могут быть использованы оба типа или каждый из них по отдельности.<br/><br/>

                    В основной спецификации по протоколу (<UrlProtocol text="RFC 2616" url="rfc2616" urlSiteDoc="https://datatracker.ietf.org/doc/html/"/>) также выделяется так называемое прозрачное согласование (<span className="code-mini">transparent negotiation</span>) как предпочтительный вариант комбинирования обоих типов. Последний механизм не следует путать с независимой технологией <span className="code-mini">Transparent Content Negotiation</span> (<span className="code-mini">TCN</span>, «Прозрачное согласование содержимого», см. <UrlProtocol text="RFC 2295" url="rfc2295" urlSiteDoc="https://datatracker.ietf.org/doc/html/"/>), которая не является частью протокола HTTP, но может использоваться с ним. У обоих существенное различие в принципе работы и самом значении слова «прозрачное» (<span className="code-mini">transparent</span>). В спецификации по HTTP под прозрачностью подразумевается, что процесс не заметен для клиента и сервера, а в технологии <span className="code-mini">TCN</span> прозрачность означает доступность полного списка вариантов ресурса для всех участников процесса доставки данных.</p>
                    <br/>
                    <h4>Управляемое сервером</h4>
                    <p>При наличии нескольких версий ресурса сервер может анализировать заголовки запроса клиента, чтобы выдать, по его мнению, наиболее подходящую. В основном анализируются заголовки <span className="code-mini">Accept</span>, <span className="code-mini">Accept-Charset</span>, <span className="code-mini">Accept-Encoding</span>, <span className="code-mini">Accept-Languages</span> и <span className="cod-mini">User-Agent</span>. Серверу желательно включать в ответ заголовок <span className="code-mini">Vary</span> с указанием параметров, по которым различается содержимое по запрашиваемому <span className="code-mini">URI</span>.<br/><br/>

                    Географическое положение клиента можно определить по удалённому IP-адресу. Это возможно за счёт того что IP-адреса, как и доменные имена, регистрируются на конкретного человека или организацию. При регистрации указывается регион, в котором будет использоваться желаемое адресное пространство. Эти данные общедоступны, и в Интернете можно найти соответствующие свободно распространяемые базы данных и готовые программные модули для работы с ними (следует ориентироваться на ключевые слова «<span className="code-mini">Geo IP</span>»).<br/><br/>

                    Следует помнить что такой метод способен определить местоположение максимум с точностью до города (отсюда определяется и страна). При этом информация актуальна только на момент регистрации адресного пространства. Например, если московский провайдер зарегистрирует диапазон адресов с указанием Москвы и начнёт предоставлять доступ клиентам из ближайшего Подмосковья, то его абоненты могут на некоторых сайтах наблюдать, что они из Москвы, а не из Красногорска или Дзержинского.<br/><br/>

                    Управляемое сервером согласование имеет несколько недостатков:</p>
                    <br/>
                    <ul className="list">
                        <li>сервер только предполагает, какой вариант наиболее предпочтителен для конечного пользователя, но не может знать точно, что именно нужно в данный момент (например, версия на русском языке или английском);</li>
                        <li>заголовков группы <span className="code-mini">Accept</span> передаётся много, а ресурсов с несколькими вариантами — мало. Из-за этого оборудование испытывает избыточную нагрузку;</li>
                        <li>общему кэшу создаётся ограничение возможности выдавать один и тот же ответ на идентичные запросы от разных пользователей;</li>
                        <li>передача заголовков <span className="code-mini">Accept</span> также может раскрывать некоторые сведения о его предпочтениях, таких как используемые языки, браузер, кодировка.</li>
                    </ul>
                    <br/>
                    <h4>Управляемое клиентом</h4>
                    <p>В данном случае тип содержимого определяется только на стороне клиента. Для этого сервер возвращает в ответе с кодом состояния <span className="code-mini">300</span> (<span className="code-mini">Multiple Choices</span>) или <span className="code-mini">406</span> (<span className="code-mini">Not Acceptable</span>) список вариантов, среди которых пользователь выбирает подходящий. Управляемое клиентом согласование хорошо, когда содержимое различается по самым частым параметрам (например, по языку и кодировке) и используется публичный кэш.<br/><br/>

                    Основной недостаток — лишняя нагрузка, так как приходится делать дополнительный запрос, чтобы получить нужное содержимое.</p>
                    <br/>
                    <h4>Прозрачное согласование</h4>
                    <p>Данное согласование полностью прозрачно для клиента и сервера. В данном случае используется общий кэш, в котором содержится список вариантов, как для управляемого клиентом согласования. Если кэш понимает все эти варианты, то он сам делает выбор, как при управляемом сервером согласовании. Это снижает нагрузки с исходного сервера и исключает дополнительный запрос со стороны клиента.<br/><br/>

                    В основной спецификации по протоколу HTTP механизм прозрачного согласования подробно не описан.</p>
                    <br/>
                    <h4>Множественное содержимое</h4>
                    <p>Протокол HTTP поддерживает передачу нескольких сущностей в пределах одного сообщения. Причём сущности могут передаваться не только в виде одноуровневой последовательности, но и в виде иерархии с вложением элементов друг в друга. Для обозначения множественного содержимого используются медиатипы <span className="code-mini">multipart/*</span>. Работа с такими типами осуществляется по общим правилам, описанным в <UrlProtocol text="RFC 2046" url="rfc2046" urlSiteDoc="https://datatracker.ietf.org/doc/html/"/> (если иное не определено конкретным медиатипом). Если получателю не известно как работать с типом, то он обрабатывает его так же, как <span className="code-mini">multipart/mixed</span>.<br/><br/>

                    Параметр <span className="code-mini">boundary</span> означает разделитель между различными типами передаваемых сообщений. Например, передаваемый из формы параметр <span className="code-mini">DestAddress</span> передаёт значение адреса e-mail, а следующий за ним элемент <span className="code-mini">AttachedFile1</span> отправляет двоичное содержимое изображения формата <span className="img-code">.jpg</span><br/><br/>

                    Со стороны сервера сообщения со множественным содержимым могут посылаться в ответ на частичные <span className="code-mini">GET</span> при запросе нескольких фрагментов ресурса. В этом случае используется медиатип <span className="code-mini">multipart/byteranges</span>.<br/><br/>

                    Со стороны клиента при отправке HTML-формы чаще всего пользуются методом <span className="code-mini">POST</span>. Типичный пример: страницы отправки электронных писем со вложенными файлами. При отправке такого письма браузер формирует сообщение типа <span className="code-mini">multipart/form-data</span>, интегрируя в него как отдельные части, введённые пользователем, тему письма, адрес получателя, сам текст и вложенные файлы:</p>
                    <br/>
                    <div className="code">
                        POST /send-message.html HTTP/1.1<br/>
                        Host: mail.example.com<br/>
                        Referer: http://mail.example.com/send-message.html<br/>
                        User-Agent: BrowserForDummies/4.67b<br/>
                        Content-Type: multipart/form-data; boundary="Asrf456BGe4h"<br/>
                        Content-Length: (суммарный объём, включая дочерние заголовки)<br/>
                        Connection: keep-alive<br/>
                        Keep-Alive: 300<br/>
                        (пустая строка)<br/>
                        (отсутствующая преамбула)<br/>
                        --Asrf456BGe4h<br/>
                        Content-Disposition: form-data; name="DestAddress"<br/>
                        (пустая строка)<br/>
                        brutal-vasya@example.com—Asrf456BGe4h<br/>
                        Content-Disposition: form-data; name="MessageTitle"<br/>
                        (пустая строка)<br/>
                        Я негодую—Asrf456BGe4h<br/>
                        Content-Disposition: form-data; name="MessageText"<br/>
                        (пустая строка)<br/>
                        Привет, Василий! Твой ручной лев, которого ты оставил<br/>
                        у меня на прошлой неделе, разодрал весь мой диван.<br/>
                        Пожалуйста, забери его скорее!<br/>
                        Во вложении две фотки с последствиями.<br/>
                        --Asrf456BGe4h<br/>
                        Content-Disposition: form-data; name="AttachedFile1"; filename="horror-photo-1.jpg"<br/>
                        Content-Type: image/jpeg<br/>
                        (пустая строка)<br/>
                        (двоичное содержимое первой фотографии)<br/>
                        --Asrf456BGe4h<br/>
                        Content-Disposition: form-data; name="AttachedFile2"; filename="horror-photo-2.jpg"<br/>
                        Content-Type: image/jpeg<br/>
                        (пустая строка)<br/>
                        (двоичное содержимое второй фотографии)<br/>
                        --Asrf456BGe4h--<br/>
                        (отсутствующий эпилог)
                    </div>
                    <br/>
                    <p>В примере в заголовках <span className="code-mini">Content-Disposition</span> параметр <span className="code-mini">name</span> соответствует атрибуту name в HTML-тегах <span className="code-mini">{"<INPUT>"}</span> и <span className="code-mini">{"<TEXTAREA>"}</span>. Параметр <span className="code-mini">filename</span> равен исходному имени файла на компьютере пользователя. Более подробная информация о формировании HTML-форм и вложении файлов в <UrlProtocol text="RFC 1867" url="rfc1867" urlSiteDoc="https://datatracker.ietf.org/doc/html/"/>.</p>
                    <br/>
                    <br/>
                    <h2>История развития</h2>
                    <h3>HTTP/0.9</h3>
                    <p>HTTP был предложен в марте 1991 года Тимом Бернерсом-Ли, работавшим тогда в CERN, как механизм для доступа к документам в Интернете и облегчения навигации посредством использования гипертекста. Самая ранняя версия протокола HTTP/0.9 была впервые опубликована в январе 1992 года (хотя реализация датируется 1990 годом). Спецификация протокола привела к упорядочению правил взаимодействия между клиентами и серверами HTTP, а также чёткому разделению функций между этими 
                    двумя компонентами. Были задокументированы основные синтаксические и семантические положения.</p>
                    <br/>
                    <h3>HTTP/1.0</h3>
                    <p>В мае 1996 года для практической реализации HTTP был выпущен информационный документ <UrlProtocol text="RFC 1945" url="rfc1945" urlSiteDoc="https://datatracker.ietf.org/doc/html/"/>, что послужило основой для реализации большинства компонентов HTTP/1.0.</p>
                    <br/>
                    <h3>HTTP/1.1</h3>
                    <p>Современная версия протокола; принята в июне 1999 года. Новым в этой версии был режим «постоянного соединения»: TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент теперь обязан посылать информацию об имени хоста, к которому он обращается, что сделало возможной более простую организацию виртуального хостинга.</p>
                    <br/>
                    <h3>HTTP/2</h3>
                    <p>11 февраля 2015 года опубликованы финальные версии черновика следующей версии протокола. В отличие от предыдущих версий, протокол HTTP/2 является бинарным. Среди ключевых особенностей: мультиплексирование запросов, расстановка приоритетов для запросов, сжатие заголовков, загрузка нескольких элементов параллельно посредством одного TCP-соединения, поддержка проактивных push-уведомлений со стороны сервера.</p>
                    <br/>
                    <h3>HTTP/3</h3>
                    <p>HTTP/3 — предлагаемый последователь HTTP/2, который уже используется в Веб на основе UDP вместо TCP в качестве транспортного протокола. Как и HTTP/2, он не объявляет устаревшими предыдущие основные версии протокола. Поддержка HTTP/3 была добавлена в Cloudflare и Google Chrome в сентябре 2019 года и может быть включена в стабильных версиях Chrome и Firefox.</p>
            </div>
        </div>
    )
}