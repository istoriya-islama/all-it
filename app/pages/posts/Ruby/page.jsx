import Cover from "../../../Components/js/Cover"
import AuthorSpeak from "../../../Components/js/AuthorSpeak"
import ImageBlock from "../../../Components/js/ImageBlock";

export const metadata = {
    title: "Ruby",
    description: "Язык програмиорование Ruby"
  };

export default function Ruby(){
    return <div>
        <Cover title="Все о Программировании" namePage="Ruby" image="/allIt.jpg" isShowBtn={false}/>
        <div className="text">
            <q>Ruby (англ. ruby — рубин, произносится ['ru:bɪ] — ру́би) — динамический, рефлективный, интерпретируемый высокоуровневый язык программирования. Язык обладает независимой от операционной системы реализацией многопоточности, сильной динамической типизацией, сборщиком мусора и многими другими возможностями. По особенностям синтаксиса он близок к языкам Perl и Eiffel, по объектно-ориентированному подходу — к Smalltalk. Также некоторые черты языка взяты из Python, Lisp, Dylan и Клу.<br/><br/>

            Кроссплатформенная реализация интерпретатора языка является полностью свободной.</q>
            <br/>
            <h2>История создания и развития</h2>
            <p>Создатель Ruby — Юкихиро Мацумото (Matz) — интересовался языками программирования, ещё будучи студентом, но идея о разработке нового языка появилась позже. Ruby начал разрабатываться 23 февраля 1993 года и вышел в свет в 1995 году.<br/>

            Название навеяно языком Perl, многие особенности синтаксиса и семантики из которого заимствованы в Ruby: англ. pearl — «жемчужина», ruby — «рубин».<br/><br/>

            Одним из источников вдохновения для Мацумото для разработки Ruby был научно-фантастический роман «Вавилон-17», основанный на гипотезе Сепира — Уорфа.<br/><br/>

            Целью разработки было создание «настоящего объектно-ориентированного», лёгкого в разработке, интерпретируемого языка программирования.</p>
            <br/>
            <AuthorSpeak author="Из письма автора:" rus="Ruby родился 24 февраля 1993 года. В тот день я беседовал со своим коллегой о возможности существования объектно-ориентированного сценарного языка. Я знал Perl (Perl4, а не Perl5), но он мне не нравился — был в нём некий привкус игрушечного языка (да и поныне есть). А объектно-ориентированный интерпретируемый язык казался многообещающим. В то время я знал Python. Но он мне не нравился потому, что я не считал его настоящим объектно-ориентированным языком. Его OO-свойства казались надстройкой над языком. Мне, как языковому маньяку и фанату объектно-ориентированного программирования с пятнадцатилетним стажем, очень, очень хотелось, чтобы был истинно объектно-ориентированный, простой в использовании язык. Я пытался найти такой язык, но его не было. Тогда я решил его создать. Прошло несколько месяцев, прежде чем интерпретатор заработал. Я добавил в свой язык то, что мне хотелось — итераторы, обработку исключений, автоматическую сборку мусора. Затем я переорганизовал свойства Perl и реализовал их как библиотеку классов. В декабре 1995 года я опубликовал Ruby 0.95 в японских новостных группах. С тех пор появились сайты, списки рассылок. В списках рассылок идут жаркие обсуждения. Самый старый список сейчас содержит 14 789 писем."/>
            <br/>
            <p>В Японии Ruby стал популярным с момента появления первой общедоступной версии в 1995 году, однако наличие документации только на японском языке сдерживало его дальнейшее распространение. Лишь в 1997 году появилось описание Ruby на английском языке, а в 1998 году открылся форум «ruby-talk». Это положило начало росту известности языка в остальном мире. В начале 2000-х вышло несколько книг на английском языке, что способствовало росту популярности Ruby в Западной Европе и Америке. В 2003 году была выпущена версия Ruby 1.8.0, а в 2005 году появился веб-фреймворк Ruby on Rails, написанный на Ruby и сразу завоевавший признание благодаря лёгкости построения на нём типичных веб-приложений. Ruby в нём является не только языком реализации самого фреймворка, но и языком описания решений (в частности, используются HTML-шаблоны с встроенным кодом на Ruby).<br/><br/>

            Основной проблемой как для Ruby вообще, так и для Ruby on Rails на тот момент была производительность: оригинальный интерпретатор проигрывал в скорости как языкам-конкурентам, так и альтернативным реализациям, а масштабируемость приложений ограничивалась высокими потребностями в памяти. Разработка языка во второй половине 2000-х разделилась на две ветви: одновременно с поддержкой линии 1.8.* началась разработка экспериментальной ветви 1.9.*, в которой автор языка отошёл от принципов сохранения совместимости с предыдущими версиями и внёс значительные изменения, подготовительные к выпуску Ruby 2.0. В результате с выходом версии Ruby 1.9.1 в 2009 и Rails 3.0 в 2010 году положение существенно изменилось: скорость работы оригинального интерпретатора была увеличена в несколько раз и практически сравнялась с альтернативными реализациями под .NET и JVM, модификации языка устранили некоторые часто критикуемые моменты. Согласно рейтингу TIOBE и данным indeed.com, интерес к Ruby за период с 2009 по 2012 год вырос более чем в три раза. В России первые официальные издания русских переводов книг по Ruby появились в 2011 году и с этого времени выходят регулярно, что можно расценивать как свидетельство растущего интереса к языку у русскоговорящих специалистов<br/><br/>.

            Стабильная версия Ruby 2.0 вышла в феврале 2013 года. 24 февраля 2014 года исполнился 21 год с момента анонса языка программирования Ruby. Такое событие разработчики решили отметить выпуском патча для Ruby 2.1, который назвали Ruby 2.1.1. В конце 2018 года вышел Ruby 2.6, где реализована JIT-компиляция.<br/><br/>

            Сейчас[когда?] Ruby входит в большинство дистрибутивов Linux, поставляется вместе с Mac OS X, доступен пользователям других операционных систем. Одним из основных приложений, связанных с Ruby, продолжает оставаться Ruby on Rails, который продолжает активно развиваться, но использование Ruby значительно шире — на нём разрабатывается большое количество приложений различного назначения, кроме того, он используется в качестве скриптового языка для автоматизации и настройки приложений и написания административных утилит, в частности, в ОС Linux.</p>
            <br/>
            <h2>Философия</h2>
            <p>Мацумото, фанат объектно-ориентированного программирования, мечтал о языке, более мощном, чем Perl, и более объектно-ориентированном, чем Python. Основное назначение Ruby — создание простых и в то же время понятных программ для решения задач, в которых время разработки, понятность и простота важнее, чем скорость работы.<br/><br/>

            Принципы устройства Ruby и программирования на нём иногда выделяются в термин «Путь Ruby» (англ. Ruby Way). В целом «путь Ruby» не имеет точной формулировки, иногда этот термин используется для критики. В относительно сжатом виде его положения изложены в книгах «Программирование на языке Ruby» Хэла Фултона и «Путь Ruby» Хэла Фултона и Андре Арке.</p>
            <br/>
            <h3>Язык для человека, а не для компьютера.</h3>
            <p>Приоритетом является удобство и минимизация затрат труда программиста при разработке программы, освобождение программиста от рутинной работы, которую компьютер может выполнять быстрее и качественнее. Особое внимание, в частности, уделено будничным рутинным занятиям (обработка текстов, администрирование), и для них язык настроен особенно хорошо. В противовес машинно-ориентированным языкам, работающим быстрее, Ruby — язык, наиболее близкий к человеку. Любая работа с компьютером выполняется людьми и для людей, и необходимо заботиться в первую очередь о затрачиваемых усилиях людей.</p>
            <br/>
            <h3>Просто, но не слишком просто.</h3>
            <p>Упрощение является благом, но оно не должно переходить некие границы, за которыми превращается в самоцель и вредит конечному результату.</p>
            <br/>
            <h3>Принцип наименьшей неожиданности</h3>
            <p>Программа должна вести себя так, как ожидает программист. Но в контексте Ruby это означает наименьшее удивление не при знакомстве с языком, а при его основательном изучении. Сам Мацумото утверждает, что целью разработки была минимизация неожиданностей при программировании для него, но после распространения языка он с удивлением узнал, что мышление программистов похоже, и для многих из них принцип «наименьшей неожиданности» совпал с его принципом.</p>
            <br/>
            <h3>Ортогональность важна, но естественность важнее.</h3>
            <p>Избыточность допустима, если она удобна. Ruby унаследовал идеологию языка программирования Perl в части предоставления программисту возможностей достижения одного и того же результата несколькими различными способами. Люди различны, и им для свободы необходима возможность выбирать. «Я предпочитаю обеспечить много путей, если это возможно, но поощрять или вести пользователей, чтобы выбрать лучший путь, если это возможно».</p>
            <br/>
            <h3>Не быть рабом производительности.</h3>
            <p>Если производительность для конкретного случая недопустимо низка, то это требует исправления, а если заранее известно, что она будет существенна — необходимо изначально проектировать программу с учётом этого. Но следует предпочитать элегантность эффективности в тех случаях, когда эффективность не слишком критична.</p>
            <br/>
            <h3>Не бояться изменений во время выполнения.</h3>
            <p>Наличие в языке динамических средств, вплоть до самомодификации программы во время исполнения, дают возможности, которые очень полезны для эффективного программирования. Снижение производительности, на которое приходится пойти ради них, в большинстве случаев вполне допустимо.</p>
            <br/>
            <h3>Следовать простым и строгим правилам, но не доходить до педантизма.</h3>
            <p>«В Ruby мы видим не „педантичную непротиворечивость“, а строгое следование набору простых правил». Правила и соглашения (в частности, соглашения об именовании, принятые в языке) нужны для того, чтобы сделать понимание программы проще. Если отступление от правила в конкретном случае логично и понятно — оно оправданно.</p>
            <br/>
            <h3>«Не нужно с этим бороться».</h3>
            <p>Ruby таков, каким он придуман. Программисту не следует ждать, что Ruby будет вести себя так же, как другой привычный ему язык. Программист может следовать своим представлениям и привычкам, сложившимся под влиянием других языков (см. «Принцип наименьшей неожиданности»), но если ожидания оказываются неверны, это нужно просто принять и использовать.</p>
            <br/>
            <h2>Семантика</h2>
            <p>Ruby — полностью объектно-ориентированный язык. В нём все данные являются объектами, в отличие от многих других языков, где существуют примитивные типы. Каждая функция — метод.<br/><br/>

            Любая конструкция в Ruby возвращает значение. Например:</p>
            <br/>
            <div className="code">
            # Условный оператор возвращает значение выбранной ветви<br/>
            puts( if 5 {">"} 3 then "Одно" else "Другое" end )<br/>
            # Операция присваивания возвращает присвоенное значение<br/>
            puts( var = 5 )
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    Одно<br/>
                    5
                </div>
            </div>
            <br/>
            <p>Ruby использует вызов по соиспользованию (call-by-sharing), хотя в сообществе Ruby часто говорят, что он использует вызов по ссылке. Для программиста, привыкшего к распространённым гибридным языкам программирования, некоторые эффекты такого решения могут показаться неожиданными. Например:</p>
            <br/>
            <div className="code">
            a = "abcdefg" #переменная a инициализирована новой строкой.<br/>
            b = a         #переменная b получает ссылку на ТУ ЖЕ строку.<br/>
            a[3] = 'R'    #строка, присвоенная a, изменяется.<br/>
            b             #при изменении a неявно изменилось и b, так как они ссылаются на ОДИН объект.<br/><br/>
  
            # Однако:
            x = 10        #переменная x инициализирована числом 10.<br/>
            y = x         #переменная y получает ссылку на то же значение.<br/>
            x += 5        #операция += создаёт НОВОЕ целое значение 15, которое и записывается в x,<br/>
            y             #поэтому изменение x не отражается на y
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    abcdefg<br/>
                    abcdefg<br/>
                    abcRefg<br/>
                    abcRefg<br/><br/>

                    10<br/>
                    10<br/>
                    15<br/>
                    10
                </div>
            </div>
            <br/>
            <p>Механизм присваивания действует одинаково для всех объектов, в отличие от языков типа Object Pascal, где присваивание может означать как копирование значения, так и копирование ссылки на значение.<br/><br/>

            Ruby не поддерживает множественное наследование, но вместо него есть мощный механизм примесей. Все классы (напрямую или через другие классы) выведены из класса <span className="code-mini">Object</span>, следовательно, любой объект может использовать определённые в нём методы (например, <span className="code-mini">class</span>, <span className="code-mini">to_s</span>, <span className="code-mini">nil?</span>). Процедурный стиль также поддерживается, но все глобальные процедуры неявно являются закрытыми методами класса <span className="code-mini">Object</span>.<br/><br/>

            Ruby является мультипарадигменным языком: он поддерживает процедурный стиль (определение функций и переменных вне классов), объектно-ориентированный (всё — объект), функциональный (анонимные функции, замыкания, возврат значения всеми инструкциями, возврат функцией последнего вычисленного значения). Он поддерживает рефлексию, метапрограммирование, информацию о типах переменных на стадии выполнения (см. динамическая идентификация типа данных).</p>
            <br/>
            <h2>Возможности Ruby</h2>
            <ul className="list">
                <li>Имеет лаконичный и простой синтаксис, частично разработанный под влиянием Ада, Eiffel и Python.</li>
                <li>Позволяет обрабатывать исключения в стиле Java и Python.</li>
                <li>Позволяет переопределять операторы, которые на самом деле являются методами.</li>
                <li>Полностью объектно-ориентированный язык программирования. Все данные в Ruby являются объектами в понимании Smalltalk. Например, число «1» — это экземпляр класса <span className="code-mini">Integer</span>. Единственное исключение — управляющие конструкции, которые в Ruby, в отличие от Smalltalk, не являются объектами. Также поддерживается добавление методов в класс и даже в конкретный экземпляр во время выполнения программы.</li>
                <li>Не поддерживает множественное наследование, но вместо него может использоваться концепция «примесей», основанная в данном языке на механизме модулей.</li>
                <li>Содержит автоматический сборщик мусора. Он работает для всех объектов Ruby, в том числе для внешних библиотек.</li>
                <li>Создавать расширения для Ruby на Си очень просто частично из-за сборщика мусора, частично из-за несложного и удобного API.</li>
                <li>Поддерживает замыкания с полной привязкой к переменным.</li>
                <li>Поддерживает блоки кода (код заключается в <span className="code-mini">{"{"}</span> … <span className="code-mini">{"}"}</span> или <span className="code-mini">do</span> … <span className="code-mini">end</span>). Блоки могут использоваться в методах или преобразовываться в замыкания.</li>
                <li>Целые переменные в Ruby автоматически конвертируются между типами <span className="code-mini">Fixnum</span> (32-разрядные) и <span className="code-mini">Bignum</span> (больше 32 разрядов) в зависимости от их значения, что позволяет производить целочисленные математические расчёты со сколь угодно большой точностью.</li>
                <li>Не требует предварительного объявления переменных, но для интерпретатора желательно, чтобы переменным присваивалось пустое значение nil (тогда интерпретатор знает, что идентификатор обозначает переменную, а не имя метода).</li>
                <li>В Ruby непосредственно в языке реализованы многие шаблоны проектирования, так, например, «одиночка» (singleton) может быть (хотя и не обязан) реализован добавлением необходимых методов к одному конкретному объекту (см. ниже).</li>
                <li>Может динамически загружать расширения, если это позволяет операционная система.</li>
                <li>Имеет независимую от ОС поддержку невытесняющей многопоточности</li>
                <li>Перенесён на множество платформ. Он разрабатывался на Linux, но работает на многих версиях Unix, DOS, Microsoft Windows (в частности, Win32), Mac OS, BeOS, OS/2 и т. д.</li>
            </ul>
            <br /><br />
            <h2>Синтаксис</h2>
            <h3>Комментарии</h3>
            <p>Строчные комментарии начинаются с символа <span className="code-">#</span>. Также поддерживаются многострочные комментарии:</p>
            <br />
            <div className="code">
            x = 10 # Строчный комментарий начинается со знака # и продолжается до конца текущей строки<br/><br/>

            =begin<br/>
            &nsbsp;&nsbsp;Всё, что находится между =begin и =end, является комментарием.<br/> 
            &nsbsp;&nsbsp;Ограничители такого комментария обязательно должны быть записаны с начала строки.<br/>
            =end
            </div>
            <h3>Алфавит, ключевые слова</h3>
            <p>Ruby — регистро-зависимый язык, прописные и строчные буквы в идентификаторах являются различными. Все ключевые слова языка, за двумя исключениями, пишутся в нижнем регистре.<br /><br />

            До версии 2.0 язык использовал множество символов 7-битной кодировки ASCII. Начиная с версии 2.0 поддерживается Unicode, по умолчанию файлы исходного кода используют кодировку UTF-8. Все буквенные символы Unicode допускается использовать в идентификаторах наравне с английскими буквами. Полностью поддерживаются Unicode-строки.<br /><br />

            Список ключевых слов Ruby:</p>
            <br />
            <div className="code">
            alias     and     BEGIN  begin   break  case   class   def<br/>
            defined?  do      else   elsif   END    end    ensure  false<br/>
            for       if      in     module  next   nil    not     or<br/>
            redo      rescue  retry  return  self   super  then    true<br/>
            undef     unless  until  when    while  yield
            </div>
            <br/>
            <h3>Соглашения об именовании</h3>
            <p>Идентификаторы традиционно должны состоять из букв, цифр и знаков подчёркивания и начинаться с буквы или знака подчёркивания. Ruby использует соглашение об именовании:</p>
            <br/>
            <ul className="list">
                <li>Имена, начинающиеся с прописной буквы, обозначают константы и классы.</li>
                <li>Имена, начинающиеся со строчной буквы или одиночного знака подчёркивания, обозначают локальные переменные и методы класса.</li>
            </ul>
            <br />
            <p>Также используются префиксы имён, определяющие область видимости идентификатора:</p>
            <br />
            <ul className="list">
                <li>Префикс @ обозначает переменную экземпляра (см. ниже).</li>
                <li>Префикс @@ обозначает переменную класса (см. ниже).</li>
                <li>Префикс $ обозначает глобальную переменную или константу. Также он используется в именах предопределённых системных переменных.</li>
                <li>Префикс : обозначает символ (экземпляр класса Symbol, см. ниже).</li>
            </ul>
            <br />
            <p>Для имён методов применяются суффиксы, обозначающие назначение метода:</p>
            <br />
            <ul className="list">
                <li>Суффикс ! обозначает деструктивный метод класса, то есть такой метод, вызов которого изменяет объект, для которого он вызван.</li>
                <li>Суффикс ? обозначает предикат, то есть метод класса, возвращающий логическое значение.</li>
            </ul>
            <br />
            <h3>Базовые типы данных</h3>
            <p>Ruby реализует идеологию «всё — объект», то есть любая единица данных является объектом — экземпляром некоторого класса, к которому применимы все синтаксические средства, предназначенные для работы с объектами. В этом смысле язык не содержит встроенных примитивных типов данных. Условно таковыми можно считать типы, предоставляемые интерпретатором и системной библиотекой, используемые наиболее часто и не требующие для использования специального указания имени класса.</p>
            <br />
            <h4>Целые числа.</h4>
            <p>Представлены типами <spam className="code-mini">Fixnum</spam> и <span className="code-mini">Bignum</span>. Первый тип используется для чисел, по модулю не превышающих 2³⁰, второй — для чисел более 2³⁰. В арифметических операциях эти числовые типы полностью совместимы и могут свободно использоваться вместе, между ними обеспечивается прозрачная конвертация. Тип <span className="code-mini">Fixnum</span> имеет ограниченную разрядность и использует стандартные арифметические команды процессора; разрядность <span className="code-mini">Bignum</span> ограничена только объёмом доступной оперативной памяти, а операции с ними базируются на алгоритмах вычислений с неограниченной точностью. Это позволяет производить точные вычисления с любым требуемым количеством знаков. Например, для большинства языков программирования написать программу точного вычисления факториала, которая работала бы для аргумента порядка сотни — достаточно сложная задача. В Ruby это делается элементарно, так как проблемы работы с длинными числами берёт на себя интерпретатор.</p>
            <br />
            <div className="code">
            def fact (n),<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = 1,<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in 1..n do,<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result *= i,<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end,<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result,<br/>
            end<br/><br/>

            puts fact(100)
            </div>
            <br/>
            <div className="prew-treminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</div>
            </div>
            <br/>
            <p>Запись десятичного числа (без учёта знаков «плюс» и «минус») должна начинаться с цифры от 1 до 9. Целое число, которое начинается с нуля, считается восьмеричным. Целое число с префиксом «0x» — шестнадцатеричное, «0b» — двоичное.</p>
            <br />
            <h4>Другие числовые типы.</h4>
            <p>Тип <span className="code-mini">Float</span> — числа с плавающей запятой, представленные фиксированным числом разрядов. Плавающие числа записываются либо в естественной, либо в экспоненциальной форме. Системная библиотека mathn предоставляет также типы <span className="code-mini">Rational</span> (рациональное число) и <span className="code-mini">Complex</span> (комплексное число). Оба этих типа автоматически преобразуются к целым и плавающим при единичном знаменателе и нулевой мнимой части соответственно.</p>
            <br />
            <h4>Строки</h4>
            <p>Строка — изменяемый массив байтов, представляющий символы в кодировке UTF-8. Реализуются классом String, имеющим большой набор методов, обеспечивающих анализ, манипуляции с содержимым, преобразования, поиск.<br/>
            Строковые литералы ограничиваются апострофами, двойными кавычками, либо заключаются в конструкцию %q[…] или %Q[…]. Ограничители строки влияют на использование внутри неё специальных символов:</p>
            <br />
            <ul className="list">
                <li>Если строка ограничена апострофами, внутри неё распознаются только специальные последовательности «\\» и «\’», обозначающие соответственно, обратный слэш и апостроф.</li>
                <li>Если строка ограничена двойными кавычками, то в ней распознаются также управляющие символы «\t» (знак табуляции), «\n» (перенос строки), «\010» (любой символ в восьмеричной кодировке) и другие.</li>
                <li>Ограничители %q[…] или %Q[…] (можно использовать круглые, квадратные, фигурные и угловые скобки) позволяют записывать строки с использованием апострофов и кавычек без экранирования. Форма %q[…] также обеспечивает непосредственный вывод управляющих последовательностей:</li>
            </ul>
            <br/>
            <div className="code">
                 # Будет выведено три одинаковых строки:<br/>
                 puts %q[Строка с табуляцией "\t" и символом переноса '\n']<br/>
                 puts "Строка с табуляцией \"\\t\" и символом переноса '\\n'"<br/>
                 puts 'Строка с табуляцией "\t" и символом переноса \'\n\''<br/>
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    Строка с табуляцией "{"\t"}" и символом переноса <br/>
                    Строка с табуляцией "t\" и символом переноса <br/>
                    Строка с табуляцией "{"\t"}" и символом переноса <br/>
                </div>
            </div>
            <br/>
            <p>Для вывода многострочного текста имеется ещё одна форма представления строк:</p>
            <br />
            <div className="code">
            puts {"<<"}EOF<br/>
            В этом тексте<br/>
            &nbsp;&nbsp;всё, включая переводы строк,<br/> 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;кавычки и отступы,<br/> 
            &nbsp;&nbsp;&nbsp;&nbsp;будет выведено "как есть".<br/>
            EOF
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                В этом тексте<br/>
                &nbsp;&nbsp;всё, включая переводы строк,<br/> 
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;кавычки и отступы,<br/> 
                &nbsp;&nbsp;&nbsp;&nbsp;будет выведено "как есть".
                </div>
            </div>
            <br/>
            <p>Вместо «EOF» может использоваться любое слово или число, важно, чтобы финальный ограничитель был написан с начала строки и за ним непосредственно следовал перевод строки. В многострочных текстах работает вывод спецсимволов, как и в строках, ограниченных двойными кавычками.<br/>
            Ruby поддерживает для строк получение срезов, ограничение, слияние, вставку в середину, поиск по подстроке или по регулярному выражению и многое другое. Удобной особенностью является поддержка вставки внутрь строки в двойных кавычках вычисляемых выражений: если в строке встречается конструкция {"#{ }"}, то всё, что находится внутри фигурных скобок, вычисляется интерпретатором, преобразуется в строковый формат и помещается в данное место создаваемой строки.</p>
            <br/>
            <div className="code">
            for i in (1..7).reverse_each do<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "Осталось {"#{i}"} секунд{"#{"}case i<br/> 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when 2..4 then "ы"<br/> 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when 1 then "а"<br/> 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else ""<br/> 
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end {"}"}...<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1)<br/>
            end<br/>
            puts "Готово!"
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                Осталось 7 секунд...<br/>  
                Осталось 6 секунд...<br/>
                Осталось 5 секунд...<br/>
                Осталось 4 секунды...<br/>
                Осталось 3 секунды...<br/>
                Осталось 2 секунды...<br/>
                Осталось 1 секунда...<br/>
                Готово!
                </div>
            </div>
            <br/>
            <p>Существенная деталь: при использовании вставки всё, что находится внутри фигурных скобок, является обычным ruby-кодом, в частности, там не требуется экранирование кавычек.</p>
            <br/>
            <h4>Символы</h4>
            <p>Символ — это неизменяемая строка. Символьные литералы записываются с префиксом «<span className="code-mini">:</span>» (двоеточие).</p>
            <br/>
            <div className="code">
            sym = :monday # :monday — это <br/>
            puts sym<br/>      
            puts :sunday<br/>  
            und = :"Unknown\tday of week" # Символ в кавычках может содержать пробелы и спецсимволы<br/>
            # для символов работает получение срезов<br/>
            puts und[8,6]<br/> 
            und[7] = ' '  # ОШИБКА! Символы неизменяемы.
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    monday<br/>
                    sunday<br/>
                    day of
                </div>
            </div>
            <br/>
            <br/>
            <h4>Диапазоны.</h4>
            <p>Диапазон — это экземпляр класса Range, он представляет собой непрерывную последовательность целых чисел от начального до конечного значения. Диапазон задаётся парой целых чисел, разделённых двумя или тремя точками.</p>
            <br/>
            <div className="code">
                d1 = 1..10   # Две точки - от 1 до 10 включительно.<br/>
                d2 = 1...10  # Три точки - от 1 до 9. Верхняя граница в такой диапазон не входит!<br/>
            </div>
            <br/>
            <p>Диапазоны широко используются в Ruby для выборки данных и организации циклов.</p>
            <br />
            <h3>Структура программы</h3>
            <p>Программа на Ruby представляет собой текстовый файл, содержащий последовательность инструкций — команд и описаний. При запуске программного файла на исполнение интерпретатор последовательно читает файл и выполняет инструкции. В Ruby не требуется организовывать тело главной программы в виде специального программного модуля (подобно функции <span className="code-mini">main()</span> в языке Си), составляющие его команды просто записываются непосредственно в тексте файла программы. Поскольку программный файл обрабатывается интерпретатором последовательно, любые функции, методы, описания должны предшествовать в тексте программы их первому использованию.<br/>

            Программа может быть разделена на несколько файлов. В этом случае главный файл программы должен загрузить остальные файлы с помощью инструкции <span className="code-mini">require</span> или <span className="code-mini">require_relative</span>:</p>
            <br />
            <div className="code">
                require 'module1'       # загрузка программного файла с именем 'module1.rb' либо библиотеки с именем 'module1'<br/>
                require 'pkgs/package2' # загрузка программного файла 'package2' из подкаталога pkgs
            </div>
            <br/>
            <p>По данной инструкции происходит поиск файла с указанным именем и расширением '.rb' и его загрузка. Если файла исходного кода с таким именем нет, интерпретатор пытается загрузить динамическую библиотеку с тем же именем (расширения зависят от операционной системы). Пути поиска файлов определяются инструкцией загрузки: <span className="code-mini">require</span> использует для загрузки набор каталогов, заданных настройками среды и параметрами запуска интерпретатора, а <span className="code-mini">require_relative</span> загружает файл с указанным путём относительно текущего файла (то есть в примере выше, если файл, содержащий инструкции загрузки, находится в каталоге <span className="path">/home/programmer/work/ruby/testproject</span>, то файл <span className="path">package2.rb</span> будет загружаться из <span className="path">/home/programmer/work/ruby/testproject/pkgs</span>. При загрузке программный модуль обрабатывается интерпретатором, то есть выполняются все его инструкции. Если модуль загружается в нескольких файлах, то его загрузка происходит только один раз. В Ruby имеется метод <span className="code-mini">load</span>, также выполняющий загрузку файла исходного кода либо библиотеки, он несколько отличается функциональностью и обычно применяется для загрузки бинарных модулей, написанных на Си.</p>
            <br/>
            <h3>Управляющие конструкции</h3>
            <p>Ruby содержит богатый набор управляющих конструкций; многие их варианты являются достаточно редкими.<br/><br/>

            Условный оператор <span className="code-mini">if</span> выглядит традиционно:</p>
            <br/>
            <div className="code">
            if x {">"} 0 <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "x - положительное число"<br/>
            elsif x {"<"} 0 then<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "x - отрицательное число"<br/> 
            else<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "x - ноль"<br/>
            end
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    x - положительное число<br/>
                    x - отрицательное число<br/>
                    x - ноль
                </div>
            </div>
            <br/>
            <p>Ветвей <span className="code-mini">elsif</span> может быть любое количество, использование ключевого слова <span className="code-mini">then</span> допустимо, но не обязательно, ветви <span className="code-mini">elsif</span> и <span className="code-mini">else</span> могут отсутствовать. Помимо этой «канонической» формы условного оператора, язык поддерживает и несколько других:</p>
            <br/>
            <div className="code">
            # Условие "если-не"
            unless x {">"} 3 then<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts x.to_s  # выведет значение x, если оно НЕ больше трёх.<br/>
            else <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "очень много, не сосчитать"<br/>
            end
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    1<br/>
                    2<br/>
                    3<br/>
                    очень много, не сосчитать
                </div>
            </div>
            <br/>
            <p>Можно использовать сокращённые формы условного оператора как модификаторы инструкций. Они пишутся после инструкции и интерпретируются как условие, при котором данную инструкцию следует выполнять. Ветви <span className="code-mini">else</span> в модификаторах быть не может.</p>
            <br/>
            <div className="code-mini">puts "x меньше нуля!" if x {"<"} 0 # Печать произойдёт только при отрицательном x<br/>
            puts "x положительно!" unless x {"<="} 0 # Строка будет выведена, если x БОЛЬШЕ нуля
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    x меньше нуля!<br/>
                    x положительно!
                </div>
            </div>
            <br/>
            <p>Можно использовать условный оператор как выражение. Значением его будет значение той ветви, которая была выбрана согласно условию. При таком использовании ключевое слово then обязательно. Также Ruby унаследовал из Си трёхместный условный оператор ?:.</p>
            <br/>
            <div className="code">
                # Аргумент метода puts выбирается условным выражением.<br/>
                puts ( if x == 0 then "ноль" else "не ноль" end ) <br /><br />
                
                # Аналог предыдущей инструкции, записанный с помощью трёхместного условного оператора.<br/>
                puts (x == 0)? "ноль" : "не ноль"
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    ноль<br/>
                    не ноль
                </div>
            </div>
            <br/>
            <p>Оператор множественного выбора case-when обеспечивает выбор из нескольких альтернатив, каждая из которых может задаваться отдельным значением, набором значений или диапазоном:</p>
            <br/>
            <div className="code">
                case month<br/> 
                when 1,2,12 then puts "зима"  # выбор из списка вариантов<br/>
                when 3..5   then puts "весна" # выбор из диапазона <br/>
                when 6..8   then puts "лето"        # можно заменять then на двоеточие<br/>
                when 9..11                    # можно опускать then, если есть перевод <br/>
                puts "осень"<br/>
                else  puts "так не бывает!!!"<br/>
                end
            </div>
            <br/>
            <p>Альтернативы в операторе <span className="coe-mini">case</span> проверяются последовательно, выбирается первая ветвь, для которой условие соответствует списку значений или диапазону. Если ни одна из ветвей <span className="code-mini">when</span> не выбрана, выполнится ветвь <span className="code-mini">else</span>, если она существует. <br /><br />

            В Ruby семь видов циклических конструкций. В примере показаны варианты цикла для обхода массива <span className="code-mini">list</span> и вывода на печать всех его значений.</p>
            <br/>
            <div className="code">
                # Цикл while<br/>
                i = 0<br/>
                while i {"<"} list.size do<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts list[i]<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += 1<br/>
                end<br/><br/>

                # Цикл until<br/>
                i = 0<br/>
                until i {">="} list.size do
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts list[i]<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += 1<br/>
                end<br/><br/>

                # Цикл for<br/>
                for item in list do<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts item<br/>
                end<br/><br/>

                # Цикл each<br/>
                list.each do |item|<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts item<br/>
                end<br/><br/>

                # Цикл loop<br/>
                i = 0<br/>
                loop do<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break if i {">="} list.size<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts list[i]<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += 1<br/>
                end<br/><br/>

                # Цикл times<br/>
                list.size.times do |i|<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts list[i]<br/>
                end<br/><br/>

                # Цикл upto<br/>
                0.upto(list.size - 1) do |i|<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts list[i]<br/>
                end
            </div>
            <br/>
            <h3>Контейнеры</h3>
            <p>Ruby поддерживает динамические гетерогенные массивы, которые автоматически изменяют размер и могут содержать элементы любых типов. Массив является экземпляром класса Array, который предоставляет мощные средства для работы с хранимыми данными.</p>
            <br/>
            <div className="code">
                # Массив можно инициализировать списком значений в квадратных скобках.<br/>
                a = [1, 'hi', 3.14, 1, 2, [4, 5] * 3]<br/>  
                a[2]   # Обращение по индексу <br/>                               
                # «разворачиваем» все внутренние массивы, удаляем одинаковые элементы<br/>
                a.flatten.uniq  # {"=>"} [1, 'hi', 3.14, 2, 4, 5]<br/>
                # поиск элемента по значению<br/>
                a.index(6) # неудача: возвращается значение nil<br/>
                a.index(4) # {"=>"} 5<br/>
                # почти для всех функций предоставляется<br/>
                # аналог с тем же названием, но заканчивающийся на «!»,<br/>
                # который модифицирует сам контейнер<br/>
                a.flatten! # {"=>"} [1, "hi", 3.14, 1, 2, 4, 5, 4, 5, 4, 5]
            </div>
            <br/>
            <p>Для контейнерных типов предоставляются итераторы, обеспечивающие обход их элементов.</p>
            <br />
            <div className="code">
            # Итератор 'each' - по элементам коллекции<br/>
            list.each do |x|<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print "{"#{х}"} " <br/>
            end<br/><br/>

            # Итератор 'times' - по количеству элементов коллекции<br/>
            n = list.size<br/>
            n.times do |i|<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print "{"#{list[i]}"} "<br/>
            end<br/><br/>

            # Итератор 'upto' - от исходного числа до максимального<br/>
            n = list.size-1<br/>
            O.upto(n) do |i|<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print "{"#{list[i]}"} "<br/>
            end<br/><br/>

            # Итератор 'each_index'<br/>
            list.each_index do |x|<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print "{"#{list[x]}"} "<br/>
            end
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                1 hi 3.14 1 2 4 5 4 5 4 5 <br/>
                1 hi 3.14 1 2 4 5 4 5 4 5 <br/>
                1 hi 3.14 1 2 4 5 4 5 4 5 <br/>
                1 hi 3.14 1 2 4 5 4 5 4 5
                </div>
            </div>
            <br/>
            <br />
            <h2>Объектное программирование в Ruby</h2>
            <h3>Классы</h3>
            <p>Все классы являются потомками предопределённого класса Object. Методы класса описываются внутри описания самого класса. Переменные с префиксом @@, встретившиеся в описании класса, являются переменными класса (аналог статических членов класса в C++), переменные с префиксом @ — переменными экземпляра (полями класса).</p>
            <br/>
            <div className="code">
            class Person {"<"} Object       # класс Person наследуется от <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include Comparable        # подмешивание методов экземпляра из модуля Comparable<br/><br/>

            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@variable                 # переменная экземпляра<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@@count_obj = 0           # переменная класса для подсчёта числа созданных объектов<br/>
                                     
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def initialize(name, age) # конструктор (name, age - параметры метода)<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@name, @age = name, age # создаём объекты<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@@count_obj += 1        # увеличиваем счётчик на 1<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/><br/>
        
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def {"<=>"}(person)           # переопределение оператора {"<=>"}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@age {"<=>"} person.age     # из метода возвращается последнее вычисленное выражение<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/><br/>
        
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def to_s                  # для форматированного вывода информации puts<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{"#{@name} (#{@age})"}"    # конструкция {"#{x}"} в 2-х кавычках замещается в строке текстовым значением x<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/><br/>
        
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def inspect               # метод используется интерпретатором для диагностического вывода<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{"<#{@@count_obj}:#{to_s}>"}"<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/><br/>
        
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attr_reader :name, :age   # создание методов доступа на чтение для полей<br/>
            end<br/><br/>
        
            # Создание массива экземпляров класса Person<br/>
            group = [ Person.new("John", 20),<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person.new("Markus", 63),<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person.new("Ash", 16) ] <br/>
            # для вывода автоматически вызывается метод inspect<br/><br/>
         
            # сортировка и "переворачивание" массива стандартными методами<br/>
            # работает благодаря переопределению оператора {"<=>"}<br/>
            puts group.sort.reverse <br/><br/>
                                    
                                    
            # метод between добавлен неявно при подключении Comparable<br/>
            group[0].between?(group[2], group[1]) 
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    [{"<3:Ash (16)"}, {"<2:John (20)"}, {"<1:Markus (63)"}]<br/>
                    Печатает:<br/>
                    Markus (63)<br/>
                    John (20)<br/>
                    Ash (16)<br/>
                    true
                </div>
            </div>
            <br/>
            <p>Один класс в Ruby может быть объявлен в нескольких файлах исходного кода. В результате возможно, например, добавление новых методов в уже существующий класс.</p>
            <br/>
            <h3>Примеси</h3>
            <p>Ruby поддерживает только единичное наследование. Дополнительно имеется механизм примесей (mixin) и возможность объявления модулей, которые позволяют реализовать большинство возможностей множественного наследования.</p>
            <br/>
            <h2>Поддержка интегрированных сред разработки</h2>
            <p>Для разработки на Ruby существует множество интегрированных сред разработки (IDE), которые предоставляют удобные инструменты для написания, отладки и тестирования кода. Вот некоторые из них:</p>
            <br/>
            <ul className="list">
                <li><strong>RubyMine</strong> - мощная IDE от JetBrains, специально разработанная для Ruby и Ruby on Rails. Поддерживает автодополнение кода, рефакторинг, отладку, тестирование и интеграцию с системами контроля версий.</li>
                <li><strong>Visual Studio Code</strong> - популярный редактор кода от Microsoft с поддержкой расширений для Ruby, таких как Ruby, Solargraph и Ruby on Rails. Обеспечивает автодополнение, отладку и интеграцию с Git.</li>
                <li><strong>Aptana Studio</strong> - бесплатная IDE на основе Eclipse, поддерживающая Ruby и другие языки веб-разработки. Предоставляет инструменты для редактирования, отладки и развертывания приложений.</li>
                <li><strong>Sublime Text</strong> - легкий и быстрый редактор кода с поддержкой плагинов для Ruby. Обеспечивает подсветку синтаксиса, автодополнение и интеграцию с системами контроля версий.</li>
                <li><strong>Atom</strong> - редактор кода от GitHub с поддержкой плагинов для Ruby. Обеспечивает автодополнение, подсветку синтаксиса и интеграцию с Git.</li>
                <li><strong>Emacs</strong> - мощный текстовый редактор с поддержкой Ruby через различные пакеты, такие как ruby-mode и enh-ruby-mode. Обеспечивает автодополнение, отладку и интеграцию с системами контроля версий.</li>
                <li><strong>Vim</strong> - текстовый редактор с поддержкой Ruby через плагины, такие как vim-ruby и vim-rails. Обеспечивает подсветку синтаксиса, автодополнение и интеграцию с Git.</li>
            </ul>
            <br/>
            <h2>Библиотеки</h2>
            <h3>Стандартная библиотека Ruby</h3>
            <p>Стандартная библиотека Ruby включает множество модулей и классов, которые предоставляют широкий спектр функциональных возможностей. Вот некоторые из них:</p>
            <br/>
            <ul className="list">
                <li><strong>Array</strong> - класс для работы с массивами.</li>
                <li><strong>Hash</strong> - класс для работы с хэшами (ассоциативными массивами).</li>
                <li><strong>String</strong> - класс для работы со строками.</li>
                <li><strong>Numeric</strong> - базовый класс для числовых типов данных.</li>
                <li><strong>Integer</strong> - класс для работы с целыми числами.</li>
                <li><strong>Float</strong> - класс для работы с числами с плавающей запятой.</li>
                <li><strong>Range</strong> - класс для работы с диапазонами.</li>
                <li><strong>Regexp</strong> - класс для работы с регулярными выражениями.</li>
                <li><strong>Time</strong> - класс для работы с датой и временем.</li>
                <li><strong>File</strong> - класс для работы с файлами.</li>
                <li><strong>Dir</strong> - класс для работы с директориями.</li>
                <li><strong>IO</strong> - базовый класс для ввода-вывода.</li>
                <li><strong>Socket</strong> - класс для работы с сетевыми сокетами.</li>
                <li><strong>Thread</strong> - класс для работы с потоками.</li>
                <li><strong>Mutex</strong> - класс для работы с мьютексами (взаимное исключение).</li>
                <li><strong>Math</strong> - модуль для математических функций.</li>
                <li><strong>Digest</strong> - модуль для вычисления хешей (MD5, SHA1 и другие).</li>
                <li><strong>JSON</strong> - модуль для работы с JSON.</li>
                <li><strong>YAML</strong> - модуль для работы с YAML.</li>
                <li><strong>CSV</strong> - модуль для работы с CSV файлами.</li>
                <li><strong>OpenURI</strong> - модуль для работы с URI и HTTP.</li>
                <li><strong>Net::HTTP</strong> - модуль для работы с HTTP.</li>
                <li><strong>Net::FTP</strong> - модуль для работы с FTP.</li>
                <li><strong>Net::SMTP</strong> - модуль для работы с SMTP.</li>
                <li><strong>Logger</strong> - класс для логирования.</li>
                <li><strong>Benchmark</strong> - модуль для измерения времени выполнения кода.</li>
                <li><strong>Set</strong> - класс для работы с множествами.</li>
                <li><strong>URI</strong> - модуль для работы с URI.</li>
                <li><strong>Tempfile</strong> - класс для работы с временными файлами.</li>
                <li><strong>FileUtils</strong> - модуль для работы с файловой системой.</li>
                <li><strong>Find</strong> - модуль для поиска файлов.</li>
                <li><strong>ERB</strong> - модуль для работы с шаблонами ERB.</li>
                <li><strong>PP</strong> - модуль для красивого вывода (pretty print).</li>
                <li><strong>Open3</strong> - модуль для работы с внешними командами.</li>
                <li><strong>Pathname</strong> - класс для работы с путями файловой системы.</li>
                <li><strong>BigDecimal</strong> - класс для работы с числами с высокой точностью.</li>
                <li><strong>Rational</strong> - класс для работы с рациональными числами.</li>
                <li><strong>Complex</strong> - класс для работы с комплексными числами.</li>
                <li><strong>Enumerator</strong> - класс для работы с перечислениями.</li>
                <li><strong>Forwardable</strong> - модуль для делегирования методов.</li>
                <li><strong>Singleton</strong> - модуль для реализации паттерна Singleton.</li>
                <li><strong>Observer</strong> - модуль для реализации паттерна Observer.</li>
                <li><strong>TSort</strong> - модуль для топологической сортировки.</li>
            </ul>
            <br/>
            <h3>Расширение</h3>
            <p>Расширения на Ruby позволяют добавлять новые возможности и функциональность в язык. Вот пример создания простого расширения на Ruby:</p>
            <br/>
            <h3>Создание расширения на C</h3>
            <p>Для создания расширения на C, необходимо создать файл с расширением .c и написать код на C. Вот пример простого расширения:</p>
            <br/>
            <div className="code">
            #include "ruby.h"<br/><br/>

            # Создание метода, который будет доступен в Ruby<br/>
            static VALUE salam(VALUE self) {"{"}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return rb_str_new2("Assalamu aleykum!");<br/>
            {"}"}<br/><br/>

            # Инициализация расширения<br/>
            void Init_my_extension() {"{"}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rb_define_method(rb_cObject, "salam", salam, 0);<br/>
            {"}"}
            </div>
            <br/>
            <p>Сохраните этот код в файл с именем my_extension.c. Затем создайте файл extconf.rb для генерации Makefile:</p>
            <br/>
            <div className="code">
            require 'mkmf'<br/>
            create_makefile('my_extension')
            </div>
            <br/>
            <p>Запустите команду <span className="code-mini">ruby extconf.rb</span> для генерации Makefile, затем выполните команду <span className="code-mini">make</span> для компиляции расширения. После этого вы сможете использовать расширение в Ruby:</p>
            <br/>
            <div className="code">
            require './my_extension'<br/>
            puts hello_world
            </div>
            <br/>
            <div className="prew-terminal">
                <nav>
                    <ul>
                        <li>Terminal</li>
                        <li className="new"><p>+</p></li>
                    </ul>
                </nav>
                <div className="terminal">
                    Asslamu aleykum!
                </div>
            </div>
            <br/>
            <ImageBlock imagePath="/ruby.jpg" imageAlt="conding Ruby for FreeRIDE" textImage="FreeRIDE — IDE для Ruby, реализованная с использованием библиотеки FxRuby." />
            <br/>
            <h2>Документация</h2>
            <p>Система RDoc предназначена для автоматического извлечения документации из исходных кодов и программ на Ruby и её дальнейшей обработки. Является стандартом де-факто для подготовки документации по программному обеспечению, написанному на Ruby.<br/><br/>

            Для доступа к документации Ruby из командной строки Unix разработана программа ri. С её помощью можно получить информацию о модулях, классах и методах Ruby.</p>
            <br/>
            <h2>Критика</h2>
            <p>Несмотря на множество преимуществ, Ruby также подвергается критике по ряду причин:</p>
            <br/>
            <ul className="list">
                <li><strong>Производительность:</strong> Ruby часто критикуется за низкую производительность по сравнению с другими языками программирования, такими как C, Java или Go. Это особенно заметно в высоконагруженных системах, где каждая миллисекунда имеет значение.</li>
                <li><strong>Потребление памяти:</strong> Ruby может потреблять значительное количество памяти, что может стать проблемой для приложений, работающих в ограниченных ресурсах.</li>
                <li><strong>Отсутствие статической типизации:</strong> Отсутствие статической типизации может привести к ошибкам, которые обнаруживаются только во время выполнения, что усложняет отладку и тестирование кода.</li>
                <li><strong>Медленная многопоточность:</strong> Несмотря на поддержку многопоточности, Ruby использует глобальную блокировку интерпретатора (GIL), что ограничивает параллельное выполнение потоков и может снижать производительность многопоточных приложений.</li>
                <li><strong>Совместимость версий:</strong> Обновления Ruby могут нарушать совместимость с предыдущими версиями, что требует дополнительных усилий для обновления и поддержки кода.</li>
                <li><strong>Меньшая популярность:</strong> Ruby менее популярен по сравнению с другими языками программирования, такими как Python или JavaScript, что может затруднить поиск разработчиков и ресурсов для обучения.</li>
            </ul>
            <br/>
            <h2>Компании, использующие Ruby</h2>
            <p>Многие компании по всему миру используют Ruby для разработки своих приложений и сервисов. Вот некоторые из них:</p>
            <br/>
            <ul className="list">
                <li><strong>GitHub</strong> - крупнейшая платформа для хостинга и совместной разработки программного обеспечения, использует Ruby on Rails для своей основной инфраструктуры.</li>
                <li><strong>Shopify</strong> - популярная платформа для создания интернет-магазинов, построена на Ruby on Rails.</li>
                <li><strong>Airbnb</strong> - сервис для аренды жилья по всему миру, использует Ruby on Rails для части своих сервисов.</li>
                <li><strong>Basecamp</strong> - инструмент для управления проектами и командной работы, разработан на Ruby on Rails.</li>
                <li><strong>SoundCloud</strong> - платформа для распространения и прослушивания музыки, использует Ruby для некоторых своих сервисов.</li>
                <li><strong>Hulu</strong> - стриминговый сервис, использует Ruby для части своей инфраструктуры.</li>
                <li><strong>Zendesk</strong> - платформа для поддержки клиентов и управления запросами, построена на Ruby on Rails.</li>
                <li><strong>Groupon</strong> - сервис для покупки купонов и скидок, использует Ruby on Rails для своей основной платформы.</li>
                <li><strong>Twitter</strong> - социальная сеть, изначально была построена на Ruby on Rails, хотя позже перешла на другие технологии для масштабирования.</li>
                <li><strong>Cookpad</strong> - платформа для обмена рецептами, использует Ruby on Rails для своей основной инфраструктуры.</li>
            </ul>
            <br/>
            <h2>Разработка мобильных приложений</h2>
            <br/>
            <ul className="list">
                <li>Titanium Studio — среда разработки мобильных приложений на <a href="../HTML">HTML5</a>, <a href="../CSS">CSS3</a>, <a href="../JavaScript">Javascript</a>, Ruby, Rails, <a href="../Python">Python</a>, <a href="../php">PHP</a></li>
                <li>RubyMotion — среда разработки iOS приложений на Ruby</li>
                <li>MobiRuby — инструмент разработки Android и iOS приложений на Ruby</li>
                <li>Rhodes[англ.] — фреймворк для разработки Enteprise Mobility приложений для смартфонов и устройств Motorola</li>
                <li>Ruboto — среда разработки Android приложений на Ruby</li>
            </ul>
            <br/>
            <br/>
            <h2>Хронология выхода версий Ruby</h2>
            <table>
                <thead>
                    <tr>
                        <th>Номер версии</th>
                        <th>Дата выхода</th>
                        <th>Примечание</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>0.95</td>
                        <td>Декабрь 1995</td>
                        <td>Первая общедоступная версия</td>
                    </tr>
                    <tr>
                        <td>1.0</td>
                        <td>25 декабря 1996</td>
                        <td>Первая стабильная версия</td>
                    </tr>
                    <tr>
                        <td>1.6</td>
                        <td>19 августа 2000</td>
                        <td>Поддержка многопоточности</td>
                    </tr>
                    <tr>
                        <td>1.8</td>
                        <td>4 августа 2003</td>
                        <td>Улучшения производительности и новые возможности</td>
                    </tr>
                    <tr>
                        <td>1.9</td>
                        <td>25 декабря 2007</td>
                        <td>Значительные изменения и улучшения</td>
                    </tr>
                    <tr>
                        <td>2.0</td>
                        <td>24 февраля 2013</td>
                        <td>Множество новых возможностей и улучшений</td>
                    </tr>
                    <tr>
                        <td>2.1</td>
                        <td>25 декабря 2013</td>
                        <td>Улучшения производительности и новые методы</td>
                    </tr>
                    <tr>
                        <td>2.2</td>
                        <td>25 декабря 2014</td>
                        <td>Улучшения производительности и сборщика мусора</td>
                    </tr>
                    <tr>
                        <td>2.3</td>
                        <td>25 декабря 2015</td>
                        <td>Новые методы и улучшения производительности</td>
                    </tr>
                    <tr>
                        <td>2.4</td>
                        <td>25 декабря 2016</td>
                        <td>Объединение Fixnum и Bignum в Integer</td>
                    </tr>
                    <tr>
                        <td>2.5</td>
                        <td>25 декабря 2017</td>
                        <td>Улучшения производительности и новые возможности</td>
                    </tr>
                    <tr>
                        <td>2.6</td>
                        <td>25 декабря 2018</td>
                        <td>JIT-компиляция</td>
                    </tr>
                    <tr>
                        <td>2.7</td>
                        <td>25 декабря 2019</td>
                        <td>Улучшения производительности и новые возможности</td>
                    </tr>
                    <tr>
                        <td>3.0</td>
                        <td>25 декабря 2020</td>
                        <td>Значительные изменения и улучшения</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
}