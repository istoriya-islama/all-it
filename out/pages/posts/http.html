<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/1633334b8bd4f972.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-91ddf6d7f343849d.js"/><script src="/_next/static/chunks/4bd1b696-69fef5d6b9a28cb8.js" async=""></script><script src="/_next/static/chunks/517-4c347518e380ea9b.js" async=""></script><script src="/_next/static/chunks/main-app-05f541b8e5bab6fa.js" async=""></script><script src="/_next/static/chunks/173-adb53e817c3964da.js" async=""></script><script src="/_next/static/chunks/970-fdca2819562abdd0.js" async=""></script><script src="/_next/static/chunks/app/pages/posts/http/page-d4511e09a8850469.js" async=""></script><script src="/_next/static/chunks/8e1d74a4-d5fa8b652382e494.js" async=""></script><script src="/_next/static/chunks/app/layout-8dc7d88f1573f6b1.js" async=""></script><title>http:</title><meta name="description" content="Протокол HTTP"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_b962f2"><div class="container"><header><h1>Все о Программировании</h1><nav><ul><li><a href="/">Главная</a></li><li><a href="/pages/post">Статьи</a></li><li class="search"><a href="/pages/search"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" color="white" style="color:white" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></a></li><li class="btn"><a href="https://t.me/it_reviews_other">Зайди к нам</a></li></ul></nav></header><div class="page"><div><div class="cover"><h3>Все о Программировании</h3><h1>http:</h1><a href="https://t.me/it_reviews_other"><img alt="cover" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" srcSet="/_next/image?url=%2FallIt.jpg&amp;w=128&amp;q=75 1x, /_next/image?url=%2FallIt.jpg&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2FallIt.jpg&amp;w=256&amp;q=75"/></a><div></div></div><div class="text"><q>HTTP (англ. Hypertext Transfer Protocol — «протокол передачи гипертекста») — сетевой протокол прикладного уровня, который изначально предназначался для получения с серверов гипертекстовых документов в формате HTML, а с течением времени стал универсальным средством взаимодействия между узлами как Всемирной паутины, так и изолированных веб-инфраструктур. Определение по основным документациям: HTTP — протокол уровня приложений для распределённых, объединённых, гипермедийных информационных систем, используемый в глобальной информационной инициативе Всемирной паутины с 1990 года.</q><br/><br/><h2>Основные свойства</h2><p>Основой HTTP является технология «клиент-сервер», то есть предполагается существование:<br/></p><ul class="list"><li>потребителей (клиентов), которые инициируют соединение и посылают запрос;</li><li>поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</li></ul><br/><p>HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов. В 2006 году в Северной Америке доля HTTP-трафика превысила долю P2P-сетей и составила 46 %, из которых почти половина — это передача потокового видео и звука.<br/><br/>HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV.<br/><br/>Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.<br/><br/>HTTP — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий                 запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.<br/><br/>Большинство протоколов предусматривает установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.<br/><br/>При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных) определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющий клиенту однозначно определить, каким образом обрабатывать присланные данные. Это особенно важно при работе с CGI-скриптами, когда расширение имени файла указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в зависимости от аргументов запроса и своих собственных соображений может                 порождать ответы разных типов — в простейшем случае картинки в разных форматах).<br/><br/>Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому CGI-скрипту. Для этого же в HTML были введены формы.<br/><br/>Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, созданная фирмой DEC), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании, основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.</p><br/><br/><h2>Программное обеспечение</h2><p>Всё программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:<br/></p><ul class="list"><li>Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);</li><li>Клиенты — конечные потребители услуг сервера (отправка запроса);</li><li>Прокси (посредники) для выполнения транспортных служб.</li></ul><br/><h3>Клиенты</h3><p>Первоначально протокол HTTP разрабатывался для доступа к гипертекстовым документам Всемирной паутины. Поэтому основными реализациями клиентов являются браузеры (агенты пользователя). Для просмотра сохранённого содержимого сайтов на компьютере без соединения с Интернетом были придуманы офлайн-браузеры. При нестабильном соединении для загрузки больших файлов используются менеджеры закачек; они позволяют в любое время докачать указанные файлы после потери соединения с веб-сервером. Некоторые виртуальные атласы (такие как Google Планета Земля и NASA World Wind) тоже используют HTTP.<br/><br/>Нередко протокол HTTP используется программами для скачивания обновлений.<br/><br/>Целый комплекс программ-роботов используется в поисковых системах Интернета. Среди них веб-пауки (краулеры), которые производят проход по гиперссылкам, составляют базу данных ресурсов серверов и сохраняют их содержимое для дальнейшего анализа.</p><h3>Исходные серверы</h3><p>Основные реализации: Apache, Internet Information Services (IIS), nginx, LiteSpeed Web Server (LSWS), Google Web Server, lighttpd.</p><h3>Прокси-серверы</h3><p>Основные реализации: Squid, UserGate, Multiproxy, Naviscope, nginx.</p><br/><br/><h2>Структура HTTP-сообщения</h2><p>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</p><ol class="list"><li>Стартовая строка (<i>Starting line</i>) — определяет тип сообщения.</li><li>Заголовки (<i>Headers</i>) — характеризуют тело сообщения, параметры передачи и прочие сведения.</li><li>Тело сообщения (<i>Message Body</i>) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.</li></ol><br/><p>Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа — только тело сообщения.<br/><br/>Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок Host.</p><h3>Стартовая строка</h3><p>Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:</p><br/><ul class="list"><li><span class="code-mini">Метод URI</span> — для версии протокола 0.9;</li><li><span class="code-mini">Метод URI HTTP/Версия</span> — для остальных версий.</li></ul><p>Здесь:</p><br/><ul class="list"><li>Метод (англ. Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод <span class="code-mini">GET</span>, список методов для версии 1.1 представлен ниже.</li><li>URI определяет путь к запрашиваемому документу.</li><li>Версия (англ. Version) — пара разделённых точкой цифр. Например: <span class="code-mini">1.0</span>.</li></ul><p>Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):</p><br/><div class="code">Host: test.user.com</div><br/><p>Стартовая строка ответа сервера имеет следующий формат: <span class="code-mini">HTTP/Версия КодСостояния Пояснение</span>, где:</p><br/><ul class="list"><li>версия — пара разделённых точкой цифр, как в запросе;</li><li>код состояния (<i>Status Code</i>) — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;</li><li>пояснение (<i>Reason Phrase</i>) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.</li></ul><br/><p>Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:</p><br/><div class="code">HTTP/1.0 200 OK</div><br/><h3>Методы</h3><p>Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.<br/>Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус <span class="code-mini">501</span> (<span class="code-mini">Not Implemented</span>). Если серверу метод известен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом <span class="code-mini">405</span> (<span class="code-mini">Method Not Allowed</span>). В обоих случаях серверу следует включить в сообщение ответа заголовок <span class="code-mini">Allow</span> со списком поддерживаемых методов.<br/><br/>Кроме методов <span class="code-mini">GET</span> и <span class="code-mini">HEAD</span>, часто применяется метод <span class="code-mini">POST</span>.</p><h3>OPTIONS</h3><p>Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок <span class="code-mini">Allow</span> со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.<br/><br/>Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.<br/><br/>Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «<span class="code-mini">*</span>». Запросы «<span class="code-mini">OPTIONS * HTTP/1.1</span>» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.<br/><br/>Результат выполнения этого метода не кэшируется.</p><h3>GET</h3><p>Используется для запроса содержимого указанного ресурса. С помощью метода <span class="code-mini">GET</span> можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.<br/><br/>Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «<span class="code-mini">?</span>»:<br/></p><div class="code">GET /path/resource?param1=value1&amp;param2=value2 HTTP/1.1</div><br/><p>Согласно стандарту HTTP, запросы типа <span class="code-mini">GET</span> считаются идемпотентными<br/>Кроме обычного метода <span class="code-mini">GET</span>, различают ещё<br/></p><ul class="list"><li>Условный <span class="code-mini">GET</span> — содержит заголовки <span class="code-mini">If-Modified-Since</span>, <span class="code-mini">If-Match</span>, <span class="code-mini">If-Range</span> и подобные;</li><li>Частичный <span class="code-mini">GET</span> — содержит в запросе <span class="code-mini">Range</span>.</li></ul><br/><p>Порядок выполнения подобных запросов определён стандартами отдельно.</p><h3>HEAD</h3><p>Аналогичен методу <span class="code-mini">GET</span>, за исключением того, что в ответе сервера отсутствует тело. Запрос <span class="code-mini">HEAD</span> обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.</p><h3>POST</h3><p>Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода <span class="code-mini">POST</span> обычно загружаются файлы на сервер.<br/><br/>В отличие от метода <span class="code-mini">GET</span>, метод <span class="code-mini">POST</span> не считается идемпотентным, то есть многократное повторение одних и тех же запросов <span class="code-mini">POST</span> может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).<br/><br/>При результате выполнения <span class="code-mini">200</span> (<span class="code-mini">Ok</span>) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ <span class="code-mini">201</span> (<span class="code-mini">Created</span>) с указанием URI нового ресурса в заголовке <span class="code-mini">Location</span>.<br/><br/>Сообщение ответа сервера на выполнение метода <span class="code-mini">POST</span> не кэшируется.</p><h3>PUT</h3><p>Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус <span class="code-mini">201</span> (<span class="code-mini">Created</span>). Если же ресурс был изменён, то сервер возвращает <span class="code-mini">200</span> (<span class="code-mini">OK</span>) или <span class="code-mini">204</span> (<span class="code-mini">No Content</span>). Сервер не должен игнорировать некорректные заголовки <span class="code-mini">Content-*</span>, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или недопустим при текущих условиях, то необходимо вернуть код ошибки <span class="code-mini">501</span> (<span class="code-mini">Not Implemented</span>).<br/><br/>Фундаментальное различие методов <span class="code-mini">POST</span> и <span class="code-mini">PUT</span> заключается в понимании предназначений URI ресурсов. Метод <span class="code-mini">POST</span> предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя <span class="code-mini">PUT</span>, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.<br/><br/>Сообщения ответов сервера на метод <span class="code-mini">PUT</span> не кэшируются.</p><h3>PATCH</h3><p>Аналогично <span class="code-mini">PUT</span>, но применяется только к фрагменту ресурса</p><h3>DELETE</h3><p>Удаляет указанный ресурс.</p><h3>TRACE</h3><p>Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.</p><h3>CONNECT</h3><p>Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.</p><h3>Коды состояния</h3><p>Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. Примеры:<br/></p><div class="code">201 Webpage Created<br/>403 Access allowed only for registered users<br/>507 Insufficient Storage</div><br/><p>Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.<br/><br/>В настоящее время выделено пять классов кодов состояния</p><br/><table><tr><th>Код</th><th>Класс</th><th>Назначение</th></tr><tr><td><span class="code-mini">1xx</span></td><td>Информационный</td><td>Информирование о процессе передачи.<br/>В HTTP/1.0 — сообщения с такими кодами должны игнорироваться.<br/><br/>В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно.<br/><br/>Сами сообщения от сервера содержат только стартовую строку ответа и, возможно, несколько полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.</td></tr><tr><td><span class="code-mini">2xx</span></td><td>Успех</td><td>Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.</td></tr><tr><td><span class="code-mini">3xx</span></td><td>Перенаправление</td><td>Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов <span class="code-mini">301</span>, <span class="code-mini">302</span>, <span class="codde-mini">303</span>, <span class="code-mini">305</span> и <span class="code-mini">307</span> относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке <span class="code-mini">Location</span>. При этом допускается использование фрагментов в целевом URI.</td></tr><tr><td><span class="code-mini">4xx</span></td><td>Ошибка клиент</td><td>Запрос клиента содержит ошибку. При использовании всех методов, кроме <span class="code-mini">HEAD</span>, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</td></tr><tr><td><span class="code-mini">5xx</span></td><td>Ошибка сервера</td><td>Операция не выполнена по вине сервера. Для всех ситуаций, кроме использования метода <span class="code-mini">HEAD</span>, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</td></tr></table><br/><br/><h2>Заголовки</h2><p>Заголовки HTTP (<i>HTTP Headers</i>) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.<br/><br/>Примеры заголовков:<br/></p><div class="code">Server: Apache/2.2.11 (Win32) PHP/5.3.0<br/>Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT<br/>Content-Type: text/plain; charset=windows-1251<br/>Content-Language: ru</div><br/><p>В примере выше каждая строка представляет собой один заголовок. При этом то, что находится до двоеточия, называется именем (name), а что после него — значением (value).<br/><br/>Все заголовки разделяются на четыре основных группы:<br/></p><ul class="list"><li>Общие заголовки (<i>General Headers</i>) — применяются как к запросам, так и к ответам, но не относятся к передаваемым данным.</li><li>Заголовки запроса (<i>Request Headers</i>) — содержат дополнительную информацию, отправляемую клиентом на сервер.</li><li>Заголовки ответа (<i>Response Headers</i>) — содержат дополнительную информацию, отправляемую сервером клиенту.</li><li>Заголовки сущности (<i>Entity Headers</i>) — определяют метаинформацию о теле сущности, либо, если тело отсутствует, о ресурсе, идентифицированном запросом.</li></ul><br/><p>Именно в таком порядке рекомендуется посылать заголовки получателю.<br/><br/>Все необходимые для функционирования HTTP заголовки описаны в основных <span class="code-mini">RFC</span>. Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «<span class="code-mini">X-</span>» для избежания конфликта имён с возможно существующими. Например, как в заголовках <span class="code-mini">X-Powered-By</span> или <span class="code-mini">X-Cache</span>. Некоторые разработчики используют свои индивидуальные префиксы. Примерами таких заголовков могут служить <span class="code-mini">Ms-Echo-Request</span> и <span class="code-mini">Ms-Echo-Reply</span>, введённые корпорацией Microsoft для расширения <span class="code-mini">WebDAV</span>.</p><br/><br/><h2>Тело сообщения</h2><p>Тело HTTP-сообщения (<span class="code-mini">message-body</span>), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта (<span class="code-mini">entity-body</span>) только в том случае, когда применяется кодирование передачи, <span class="code-mini">Transfer-Encoding</span>что указывается полем заголовка <span class="code-mini">Transfer-Encoding</span>.</p><br/><div class="code">message-body = entity-body<br/>| <!-- -->&lt;<!-- -->entity-body закодировано согласно<br/>Transfer-Encoding<!-- -->&gt;</div><br/><p>Поле <span class="code-mini">Transfer-Encoding</span> должно использоваться для указания любого кодирования передачи, применённого приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле <span class="code-mini">Transfer-Encoding</span> — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением в цепочке запросов/ответов.<br/><br/>Правила, устанавливающие допустимость тела сообщения в сообщении, отличны для запросов и ответов.<br/><br/>Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка <span class="code-mini">Content-Length</span> или <span class="code-mini">Transfer-Encoding</span>. Тело сообщения может быть добавлено в запрос, только когда метод запроса допускает тело объекта. Включается или не включается тело сообщения в сообщение ответа — зависит как от метода запроса, так и от кода состояния ответа. Все ответы на запрос с методом <span class="code-mini">HEAD</span> не должны включать тело сообщения, даже если присутствуют поля заголовка объекта (<span class="code-mini"></span>), заставляющие поверить в присутствие объекта. Никакие ответы с кодами состояния <span class="code-mini">1xx</span> (Информационные), <span class="code-mini">204</span> (Нет содержимого, <span class="code-mini"></span>), и <span class="code-mini">304</span> (Не модифицирован, <span class="code-mini">Not Modified</span>) не должны содержать тела сообщения. Все другие ответы содержат тело сообщения, даже если оно имеет нулевую длину.</p><br/><br/><h2>Основные механизмы протокола</h2><h3>Частичные GET</h3><p>HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные GET; возможность их выполнения необязательна (но желательна) для серверов. Частичные GET в основном используются для докачки файлов и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.<br/><br/>Для получения фрагмента клиент посылает серверу запрос с заголовком Range, указывая в нём необходимые байтовые диапазоны. Если сервер не понимает частичные запросы (игнорирует заголовок Range), то он вернёт всё содержимое со статусом 200, как и при обычном GET. В случае успешного выполнения сервер возвращает вместо кода 200 ответ со статусом 206 (Partial Content), включая в ответ заголовок Content-Range. Сами фрагменты могут быть переданы двумя способами:<br/></p><ul class="list-code"><li>в ответе помещается заголовок <span class="code-mini">Content-Range</span> с указанием байтовых диапазонов. В соответствии с ними фрагменты последовательно помещаются в основное тело. При этом <span class="code-mini">Content-Length</span> должен соответствовать суммарному объёму всего тела;</li><li>сервер указывает медиатип <span class="code-mini">multipart/byterangescls</span> для основного содержимого и передаёт фрагменты, указывая соответствующий <span class="code-mini">Content-Range</span> для каждого элемента (см. также «Множественное содержимое»).</li></ul><br/><h3>Условные GET</h3><p>Метод <span class="code-mini">GET</span> изменяется на «условный <span class="code-mini">GET</span>», если сообщение запроса включает в себя поле заголовка <span class="code-mini">If-Modified-Since</span>. В ответ на «условный <span class="code-mini">GET</span>» тело запрашиваемого ресурса передаётся, только если он изменялся после даты, указанной в заголовке <span class="code-mini">If-Modified-Since</span>. Алгоритм определения этого включает в себя следующие случаи:</p><br/><ul class="list"><li>если статус ответа на запрос будет отличаться от «<span class="code-mini">200 OK</span>» или дата, указанная в поле заголовка «<span class="code-mini">If-Modified-Since</span>», некорректна, ответ будет идентичен ответу на обычный запрос <span class="code-mini">GET</span>;</li><li>если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос <span class="code-mini">GET</span>;</li><li>если ресурс не изменялся после указанной даты, сервер вернет статус «<span class="code-mini">304 Not Modified</span>».</li></ul><br/><p>Использование метода «условный <span class="code-mini">GET</span>» направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.</p><br/><h3>Согласование содержимого</h3><p>Согласование содержимого (<span class="code-mini">Content Negotiation</span>) — механизм автоматического определения необходимого ресурса при наличии нескольких разнотипных версий документа. Субъектами согласования могут быть не только ресурсы сервера, но и возвращаемые страницы с сообщениями об ошибках (<span class="code-mini">403</span>, <span class="code-mini">404</span> и т. п.).<br/><br/>Различают два основных типа согласований:</p><ul class="list"><li>управляемое сервером (<span class="code-mini">server-driven</span>);</li><li>управляемое клиентом (<span class="code-mini">agent-driven</span>).</li></ul><br/><p>Одновременно могут быть использованы оба типа или каждый из них по отдельности.<br/><br/>В основной спецификации по протоколу (<a target="_blank" href="https://datatracker.ietf.org/doc/html/rfc2616" class="link-pr"><span class="p-link-pr">RFC 2616<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-linejoin="round" stroke-width="32" d="M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z"></path></svg></span></a>) также выделяется так называемое прозрачное согласование (<span class="code-mini">transparent negotiation</span>) как предпочтительный вариант комбинирования обоих типов. Последний механизм не следует путать с независимой технологией <span class="code-mini">Transparent Content Negotiation</span> (<span class="code-mini">TCN</span>, «Прозрачное согласование содержимого», см. <a target="_blank" href="https://datatracker.ietf.org/doc/html/rfc2295" class="link-pr"><span class="p-link-pr">RFC 2295<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-linejoin="round" stroke-width="32" d="M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z"></path></svg></span></a>), которая не является частью протокола HTTP, но может использоваться с ним. У обоих существенное различие в принципе работы и самом значении слова «прозрачное» (<span class="code-mini">transparent</span>). В спецификации по HTTP под прозрачностью подразумевается, что процесс не заметен для клиента и сервера, а в технологии <span class="code-mini">TCN</span> прозрачность означает доступность полного списка вариантов ресурса для всех участников процесса доставки данных.</p><br/><h4>Управляемое сервером</h4><p>При наличии нескольких версий ресурса сервер может анализировать заголовки запроса клиента, чтобы выдать, по его мнению, наиболее подходящую. В основном анализируются заголовки <span class="code-mini">Accept</span>, <span class="code-mini">Accept-Charset</span>, <span class="code-mini">Accept-Encoding</span>, <span class="code-mini">Accept-Languages</span> и <span class="cod-mini">User-Agent</span>. Серверу желательно включать в ответ заголовок <span class="code-mini">Vary</span> с указанием параметров, по которым различается содержимое по запрашиваемому <span class="code-mini">URI</span>.<br/><br/>Географическое положение клиента можно определить по удалённому IP-адресу. Это возможно за счёт того что IP-адреса, как и доменные имена, регистрируются на конкретного человека или организацию. При регистрации указывается регион, в котором будет использоваться желаемое адресное пространство. Эти данные общедоступны, и в Интернете можно найти соответствующие свободно распространяемые базы данных и готовые программные модули для работы с ними (следует ориентироваться на ключевые слова «<span class="code-mini">Geo IP</span>»).<br/><br/>Следует помнить что такой метод способен определить местоположение максимум с точностью до города (отсюда определяется и страна). При этом информация актуальна только на момент регистрации адресного пространства. Например, если московский провайдер зарегистрирует диапазон адресов с указанием Москвы и начнёт предоставлять доступ клиентам из ближайшего Подмосковья, то его абоненты могут на некоторых сайтах наблюдать, что они из Москвы, а не из Красногорска или Дзержинского.<br/><br/>Управляемое сервером согласование имеет несколько недостатков:</p><br/><ul class="list"><li>сервер только предполагает, какой вариант наиболее предпочтителен для конечного пользователя, но не может знать точно, что именно нужно в данный момент (например, версия на русском языке или английском);</li><li>заголовков группы <span class="code-mini">Accept</span> передаётся много, а ресурсов с несколькими вариантами — мало. Из-за этого оборудование испытывает избыточную нагрузку;</li><li>общему кэшу создаётся ограничение возможности выдавать один и тот же ответ на идентичные запросы от разных пользователей;</li><li>передача заголовков <span class="code-mini">Accept</span> также может раскрывать некоторые сведения о его предпочтениях, таких как используемые языки, браузер, кодировка.</li></ul><br/><h4>Управляемое клиентом</h4><p>В данном случае тип содержимого определяется только на стороне клиента. Для этого сервер возвращает в ответе с кодом состояния <span class="code-mini">300</span> (<span class="code-mini">Multiple Choices</span>) или <span class="code-mini">406</span> (<span class="code-mini">Not Acceptable</span>) список вариантов, среди которых пользователь выбирает подходящий. Управляемое клиентом согласование хорошо, когда содержимое различается по самым частым параметрам (например, по языку и кодировке) и используется публичный кэш.<br/><br/>Основной недостаток — лишняя нагрузка, так как приходится делать дополнительный запрос, чтобы получить нужное содержимое.</p><br/><h4>Прозрачное согласование</h4><p>Данное согласование полностью прозрачно для клиента и сервера. В данном случае используется общий кэш, в котором содержится список вариантов, как для управляемого клиентом согласования. Если кэш понимает все эти варианты, то он сам делает выбор, как при управляемом сервером согласовании. Это снижает нагрузки с исходного сервера и исключает дополнительный запрос со стороны клиента.<br/><br/>В основной спецификации по протоколу HTTP механизм прозрачного согласования подробно не описан.</p><br/><h4>Множественное содержимое</h4><p>Протокол HTTP поддерживает передачу нескольких сущностей в пределах одного сообщения. Причём сущности могут передаваться не только в виде одноуровневой последовательности, но и в виде иерархии с вложением элементов друг в друга. Для обозначения множественного содержимого используются медиатипы <span class="code-mini">multipart/*</span>. Работа с такими типами осуществляется по общим правилам, описанным в <a target="_blank" href="https://datatracker.ietf.org/doc/html/rfc2046" class="link-pr"><span class="p-link-pr">RFC 2046<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-linejoin="round" stroke-width="32" d="M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z"></path></svg></span></a> (если иное не определено конкретным медиатипом). Если получателю не известно как работать с типом, то он обрабатывает его так же, как <span class="code-mini">multipart/mixed</span>.<br/><br/>Параметр <span class="code-mini">boundary</span> означает разделитель между различными типами передаваемых сообщений. Например, передаваемый из формы параметр <span class="code-mini">DestAddress</span> передаёт значение адреса e-mail, а следующий за ним элемент <span class="code-mini">AttachedFile1</span> отправляет двоичное содержимое изображения формата <span class="img-code">.jpg</span><br/><br/>Со стороны сервера сообщения со множественным содержимым могут посылаться в ответ на частичные <span class="code-mini">GET</span> при запросе нескольких фрагментов ресурса. В этом случае используется медиатип <span class="code-mini">multipart/byteranges</span>.<br/><br/>Со стороны клиента при отправке HTML-формы чаще всего пользуются методом <span class="code-mini">POST</span>. Типичный пример: страницы отправки электронных писем со вложенными файлами. При отправке такого письма браузер формирует сообщение типа <span class="code-mini">multipart/form-data</span>, интегрируя в него как отдельные части, введённые пользователем, тему письма, адрес получателя, сам текст и вложенные файлы:</p><br/><div class="code">POST /send-message.html HTTP/1.1<br/>Host: mail.example.com<br/>Referer: http://mail.example.com/send-message.html<br/>User-Agent: BrowserForDummies/4.67b<br/>Content-Type: multipart/form-data; boundary=&quot;Asrf456BGe4h&quot;<br/>Content-Length: (суммарный объём, включая дочерние заголовки)<br/>Connection: keep-alive<br/>Keep-Alive: 300<br/>(пустая строка)<br/>(отсутствующая преамбула)<br/>--Asrf456BGe4h<br/>Content-Disposition: form-data; name=&quot;DestAddress&quot;<br/>(пустая строка)<br/>brutal-vasya@example.com—Asrf456BGe4h<br/>Content-Disposition: form-data; name=&quot;MessageTitle&quot;<br/>(пустая строка)<br/>Я негодую—Asrf456BGe4h<br/>Content-Disposition: form-data; name=&quot;MessageText&quot;<br/>(пустая строка)<br/>Привет, Василий! Твой ручной лев, которого ты оставил<br/>у меня на прошлой неделе, разодрал весь мой диван.<br/>Пожалуйста, забери его скорее!<br/>Во вложении две фотки с последствиями.<br/>--Asrf456BGe4h<br/>Content-Disposition: form-data; name=&quot;AttachedFile1&quot;; filename=&quot;horror-photo-1.jpg&quot;<br/>Content-Type: image/jpeg<br/>(пустая строка)<br/>(двоичное содержимое первой фотографии)<br/>--Asrf456BGe4h<br/>Content-Disposition: form-data; name=&quot;AttachedFile2&quot;; filename=&quot;horror-photo-2.jpg&quot;<br/>Content-Type: image/jpeg<br/>(пустая строка)<br/>(двоичное содержимое второй фотографии)<br/>--Asrf456BGe4h--<br/>(отсутствующий эпилог)</div><br/><p>В примере в заголовках <span class="code-mini">Content-Disposition</span> параметр <span class="code-mini">name</span> соответствует атрибуту name в HTML-тегах <span class="code-mini">&lt;INPUT&gt;</span> и <span class="code-mini">&lt;TEXTAREA&gt;</span>. Параметр <span class="code-mini">filename</span> равен исходному имени файла на компьютере пользователя. Более подробная информация о формировании HTML-форм и вложении файлов в <a target="_blank" href="https://datatracker.ietf.org/doc/html/rfc1867" class="link-pr"><span class="p-link-pr">RFC 1867<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-linejoin="round" stroke-width="32" d="M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z"></path></svg></span></a>.</p><br/><br/><h2>История развития</h2><h3>HTTP/0.9</h3><p>HTTP был предложен в марте 1991 года Тимом Бернерсом-Ли, работавшим тогда в CERN, как механизм для доступа к документам в Интернете и облегчения навигации посредством использования гипертекста. Самая ранняя версия протокола HTTP/0.9 была впервые опубликована в январе 1992 года (хотя реализация датируется 1990 годом). Спецификация протокола привела к упорядочению правил взаимодействия между клиентами и серверами HTTP, а также чёткому разделению функций между этими двумя компонентами. Были задокументированы основные синтаксические и семантические положения.</p><br/><h3>HTTP/1.0</h3><p>В мае 1996 года для практической реализации HTTP был выпущен информационный документ <a target="_blank" href="https://datatracker.ietf.org/doc/html/rfc1945" class="link-pr"><span class="p-link-pr">RFC 1945<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-linejoin="round" stroke-width="32" d="M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z"></path></svg></span></a>, что послужило основой для реализации большинства компонентов HTTP/1.0.</p><br/><h3>HTTP/1.1</h3><p>Современная версия протокола; принята в июне 1999 года. Новым в этой версии был режим «постоянного соединения»: TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент теперь обязан посылать информацию об имени хоста, к которому он обращается, что сделало возможной более простую организацию виртуального хостинга.</p><br/><h3>HTTP/2</h3><p>11 февраля 2015 года опубликованы финальные версии черновика следующей версии протокола. В отличие от предыдущих версий, протокол HTTP/2 является бинарным. Среди ключевых особенностей: мультиплексирование запросов, расстановка приоритетов для запросов, сжатие заголовков, загрузка нескольких элементов параллельно посредством одного TCP-соединения, поддержка проактивных push-уведомлений со стороны сервера.</p><br/><h3>HTTP/3</h3><p>HTTP/3 — предлагаемый последователь HTTP/2, который уже используется в Веб на основе UDP вместо TCP в качестве транспортного протокола. Как и HTTP/2, он не объявляет устаревшими предыдущие основные версии протокола. Поддержка HTTP/3 была добавлена в Cloudflare и Google Chrome в сентябре 2019 года и может быть включена в стабильных версиях Chrome и Firefox.</p></div></div><button class="back-to-top "><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 320 512" color="white" style="color:white" height="30" width="30" xmlns="http://www.w3.org/2000/svg"><path d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"></path></svg></button></div></div><footer><hr/><div class="container"><span class="footer-text">Спасибо за чтениe</span><button class="btn-telgram"><a href="https://t.me/it_reviews_other">Зайди к нам</a></button></div></footer><script src="/_next/static/chunks/webpack-91ddf6d7f343849d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8173,[\"173\",\"static/chunks/173-adb53e817c3964da.js\",\"970\",\"static/chunks/970-fdca2819562abdd0.js\",\"554\",\"static/chunks/app/pages/posts/http/page-d4511e09a8850469.js\"],\"\"]\n3:I[5244,[],\"\"]\n4:I[3866,[],\"\"]\n5:I[1700,[\"711\",\"static/chunks/8e1d74a4-d5fa8b652382e494.js\",\"173\",\"static/chunks/173-adb53e817c3964da.js\",\"177\",\"static/chunks/app/layout-8dc7d88f1573f6b1.js\"],\"default\"]\n6:I[7970,[\"173\",\"static/chunks/173-adb53e817c3964da.js\",\"970\",\"static/chunks/970-fdca2819562abdd0.js\",\"554\",\"static/chunks/app/pages/posts/http/page-d4511e09a8850469.js\"],\"Image\"]\n7:I[6213,[],\"OutletBoundary\"]\n9:I[6213,[],\"MetadataBoundary\"]\nb:I[6213,[],\"ViewportBoundary\"]\nd:I[4835,[],\"\"]\n:HL[\"/_next/static/css/1633334b8bd4f972.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"2bG9-Hdm14uF9As9GrKRC\",\"p\":\"\",\"c\":[\"\",\"pages\",\"posts\",\"http\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"pages\",{\"children\":[\"posts\",{\"children\":[\"http\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/1633334b8bd4f972.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_b962f2\",\"children\":[[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"header\",null,{\"children\":[[\"$\",\"h1\",null,{\"children\":\"Все о Программировании\"}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"children\":\"Главная\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L2\",null,{\"href\":\"/pages/post\",\"children\":\"Статьи\"}]}],[\"$\",\"li\",null,{\"className\":\"search\",\"children\":[\"$\",\"$L2\",null,{\"href\":\"/pages/search\",\"children\":[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"color\":\"white\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"d\":\"M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"white\"},\"height\":20,\"width\":20,\"xmlns\":\"http://www.w3.org/2000/svg\"}]}]}],[\"$\",\"li\",null,{\"className\":\"btn\",\"children\":[\"$\",\"$L2\",null,{\"href\":\"https://t.me/it_reviews_other\",\"children\":\"Зайди к нам\"}]}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"page\",\"children\":[[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L5\",null,{}]]}]]}],[\"$\",\"footer\",null,{\"children\":[[\"$\",\"hr\",null,{}],[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"span\",null,{\"className\":\"footer-text\",\"children\":\"Спасибо за чтениe\"}],[\"$\",\"button\",null,{\"className\":\"btn-telgram\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://t.me/it_reviews_other\",\"children\":\"Зайди к нам\"}]}]]}]]}]]}]}]]}],{\"children\":[\"pages\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"pages\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"posts\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"pages\",\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"http\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"pages\",\"children\",\"posts\",\"children\",\"http\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"cover\",\"children\":[[\"$\",\"h3\",null,{\"children\":\"Все о Программировании\"}],[\"$\",\"h1\",null,{\"children\":\"http:\"}],[\"$\",\"$L2\",null,{\"href\":\"https://t.me/it_reviews_other\",\"children\":[\"$\",\"$L6\",null,{\"src\":\"/allIt.jpg\",\"width\":100,\"height\":100,\"alt\":\"cover\"}]}],[\"$\",\"div\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"text\",\"children\":[[\"$\",\"q\",null,{\"children\":\"HTTP (англ. Hypertext Transfer Protocol — «протокол передачи гипертекста») — сетевой протокол прикладного уровня, который изначально предназначался для получения с серверов гипертекстовых документов в формате HTML, а с течением времени стал универсальным средством взаимодействия между узлами как Всемирной паутины, так и изолированных веб-инфраструктур. Определение по основным документациям: HTTP — протокол уровня приложений для распределённых, объединённых, гипермедийных информационных систем, используемый в глобальной информационной инициативе Всемирной паутины с 1990 года.\"}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Основные свойства\"}],[\"$\",\"p\",null,{\"children\":[\"Основой HTTP является технология «клиент-сервер», то есть предполагается существование:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"потребителей (клиентов), которые инициируют соединение и посылают запрос;\"}],[\"$\",\"li\",null,{\"children\":\"поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов. В 2006 году в Северной Америке доля HTTP-трафика превысила долю P2P-сетей и составила 46 %, из которых почти половина — это передача потокового видео и звука.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"HTTP — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий                 запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Большинство протоколов предусматривает установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных) определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющий клиенту однозначно определить, каким образом обрабатывать присланные данные. Это особенно важно при работе с CGI-скриптами, когда расширение имени файла указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в зависимости от аргументов запроса и своих собственных соображений может                 порождать ответы разных типов — в простейшем случае картинки в разных форматах).\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому CGI-скрипту. Для этого же в HTML были введены формы.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, созданная фирмой DEC), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании, основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Программное обеспечение\"}],[\"$\",\"p\",null,{\"children\":[\"Всё программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);\"}],[\"$\",\"li\",null,{\"children\":\"Клиенты — конечные потребители услуг сервера (отправка запроса);\"}],[\"$\",\"li\",null,{\"children\":\"Прокси (посредники) для выполнения транспортных служб.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Клиенты\"}],[\"$\",\"p\",null,{\"children\":[\"Первоначально протокол HTTP разрабатывался для доступа к гипертекстовым документам Всемирной паутины. Поэтому основными реализациями клиентов являются браузеры (агенты пользователя). Для просмотра сохранённого содержимого сайтов на компьютере без соединения с Интернетом были придуманы офлайн-браузеры. При нестабильном соединении для загрузки больших файлов используются менеджеры закачек; они позволяют в любое время докачать указанные файлы после потери соединения с веб-сервером. Некоторые виртуальные атласы (такие как Google Планета Земля и NASA World Wind) тоже используют HTTP.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Нередко протокол HTTP используется программами для скачивания обновлений.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Целый комплекс программ-роботов используется в поисковых системах Интернета. Среди них веб-пауки (краулеры), которые производят проход по гиперссылкам, составляют базу данных ресурсов серверов и сохраняют их содержимое для дальнейшего анализа.\"]}],[\"$\",\"h3\",null,{\"children\":\"Исходные серверы\"}],[\"$\",\"p\",null,{\"children\":\"Основные реализации: Apache, Internet Information Services (IIS), nginx, LiteSpeed Web Server (LSWS), Google Web Server, lighttpd.\"}],[\"$\",\"h3\",null,{\"children\":\"Прокси-серверы\"}],[\"$\",\"p\",null,{\"children\":\"Основные реализации: Squid, UserGate, Multiproxy, Naviscope, nginx.\"}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Структура HTTP-сообщения\"}],[\"$\",\"p\",null,{\"children\":\"Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:\"}],[\"$\",\"ol\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Стартовая строка (\",[\"$\",\"i\",null,{\"children\":\"Starting line\"}],\") — определяет тип сообщения.\"]}],[\"$\",\"li\",null,{\"children\":[\"Заголовки (\",[\"$\",\"i\",null,{\"children\":\"Headers\"}],\") — характеризуют тело сообщения, параметры передачи и прочие сведения.\"]}],[\"$\",\"li\",null,{\"children\":[\"Тело сообщения (\",[\"$\",\"i\",null,{\"children\":\"Message Body\"}],\") — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа — только тело сообщения.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок Host.\"]}],[\"$\",\"h3\",null,{\"children\":\"Стартовая строка\"}],[\"$\",\"p\",null,{\"children\":\"Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:\"}],[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Метод URI\"}],\" — для версии протокола 0.9;\"]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Метод URI HTTP/Версия\"}],\" — для остальных версий.\"]}]]}],[\"$\",\"p\",null,{\"children\":\"Здесь:\"}],[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Метод (англ. Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\", список методов для версии 1.1 представлен ниже.\"]}],[\"$\",\"li\",null,{\"children\":\"URI определяет путь к запрашиваемому документу.\"}],[\"$\",\"li\",null,{\"children\":[\"Версия (англ. Version) — пара разделённых точкой цифр. Например: \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"1.0\"}],\".\"]}]]}],[\"$\",\"p\",null,{\"children\":\"Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):\"}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":\"Host: test.user.com\"}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Стартовая строка ответа сервера имеет следующий формат: \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"HTTP/Версия КодСостояния Пояснение\"}],\", где:\"]}],[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"версия — пара разделённых точкой цифр, как в запросе;\"}],[\"$\",\"li\",null,{\"children\":[\"код состояния (\",[\"$\",\"i\",null,{\"children\":\"Status Code\"}],\") — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;\"]}],[\"$\",\"li\",null,{\"children\":[\"пояснение (\",[\"$\",\"i\",null,{\"children\":\"Reason Phrase\"}],\") — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":\"Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:\"}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":\"HTTP/1.0 200 OK\"}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Методы\"}],[\"$\",\"p\",null,{\"children\":[\"Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру.\",[\"$\",\"br\",null,{}],\"Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"501\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Not Implemented\"}],\"). Если серверу метод известен, но он неприменим к конкретному ресурсу, то возвращается сообщение с кодом \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"405\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Method Not Allowed\"}],\"). В обоих случаях серверу следует включить в сообщение ответа заголовок \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Allow\"}],\" со списком поддерживаемых методов.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Кроме методов \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"HEAD\"}],\", часто применяется метод \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\".\"]}],[\"$\",\"h3\",null,{\"children\":\"OPTIONS\"}],[\"$\",\"p\",null,{\"children\":[\"Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Allow\"}],\" со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"*\"}],\"». Запросы «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"OPTIONS * HTTP/1.1\"}],\"» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Результат выполнения этого метода не кэшируется.\"]}],[\"$\",\"h3\",null,{\"children\":\"GET\"}],[\"$\",\"p\",null,{\"children\":[\"Используется для запроса содержимого указанного ресурса. С помощью метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"?\"}],\"»:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":\"GET /path/resource?param1=value1\u0026param2=value2 HTTP/1.1\"}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Согласно стандарту HTTP, запросы типа \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" считаются идемпотентными\",[\"$\",\"br\",null,{}],\"Кроме обычного метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\", различают ещё\",[\"$\",\"br\",null,{}]]}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Условный \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" — содержит заголовки \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"If-Modified-Since\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"If-Match\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"If-Range\"}],\" и подобные;\"]}],[\"$\",\"li\",null,{\"children\":[\"Частичный \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" — содержит в запросе \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Range\"}],\".\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":\"Порядок выполнения подобных запросов определён стандартами отдельно.\"}],[\"$\",\"h3\",null,{\"children\":\"HEAD\"}],[\"$\",\"p\",null,{\"children\":[\"Аналогичен методу \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\", за исключением того, что в ответе сервера отсутствует тело. Запрос \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"HEAD\"}],\" обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.\"]}],[\"$\",\"h3\",null,{\"children\":\"POST\"}],[\"$\",\"p\",null,{\"children\":[\"Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\" обычно загружаются файлы на сервер.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"В отличие от метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\", метод \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\" не считается идемпотентным, то есть многократное повторение одних и тех же запросов \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\" может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"При результате выполнения \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"200\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Ok\"}],\") в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"201\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Created\"}],\") с указанием URI нового ресурса в заголовке \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Location\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Сообщение ответа сервера на выполнение метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\" не кэшируется.\"]}],[\"$\",\"h3\",null,{\"children\":\"PUT\"}],[\"$\",\"p\",null,{\"children\":[\"Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"201\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Created\"}],\"). Если же ресурс был изменён, то сервер возвращает \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"200\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"OK\"}],\") или \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"204\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"No Content\"}],\"). Сервер не должен игнорировать некорректные заголовки \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content-*\"}],\", передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или недопустим при текущих условиях, то необходимо вернуть код ошибки \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"501\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Not Implemented\"}],\").\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Фундаментальное различие методов \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"PUT\"}],\" заключается в понимании предназначений URI ресурсов. Метод \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\" предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"PUT\"}],\", клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Сообщения ответов сервера на метод \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"PUT\"}],\" не кэшируются.\"]}],[\"$\",\"h3\",null,{\"children\":\"PATCH\"}],[\"$\",\"p\",null,{\"children\":[\"Аналогично \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"PUT\"}],\", но применяется только к фрагменту ресурса\"]}],[\"$\",\"h3\",null,{\"children\":\"DELETE\"}],[\"$\",\"p\",null,{\"children\":\"Удаляет указанный ресурс.\"}],[\"$\",\"h3\",null,{\"children\":\"TRACE\"}],[\"$\",\"p\",null,{\"children\":\"Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.\"}],[\"$\",\"h3\",null,{\"children\":\"CONNECT\"}],[\"$\",\"p\",null,{\"children\":\"Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.\"}],[\"$\",\"h3\",null,{\"children\":\"Коды состояния\"}],[\"$\",\"p\",null,{\"children\":[\"Код состояния является частью первой строки ответа сервера. Он представляет собой целое число из трёх цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. Примеры:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"201 Webpage Created\",[\"$\",\"br\",null,{}],\"403 Access allowed only for registered users\",[\"$\",\"br\",null,{}],\"507 Insufficient Storage\"]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Клиент узнаёт по коду ответа о результатах его запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"В настоящее время выделено пять классов кодов состояния\"]}],[\"$\",\"br\",null,{}],[\"$\",\"table\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"Код\"}],[\"$\",\"th\",null,{\"children\":\"Класс\"}],[\"$\",\"th\",null,{\"children\":\"Назначение\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"1xx\"}]}],[\"$\",\"td\",null,{\"children\":\"Информационный\"}],[\"$\",\"td\",null,{\"children\":[\"Информирование о процессе передачи.\",[\"$\",\"br\",null,{}],\"В HTTP/1.0 — сообщения с такими кодами должны игнорироваться.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Сами сообщения от сервера содержат только стартовую строку ответа и, возможно, несколько полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"2xx\"}]}],[\"$\",\"td\",null,{\"children\":\"Успех\"}],[\"$\",\"td\",null,{\"children\":\"Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"3xx\"}]}],[\"$\",\"td\",null,{\"children\":\"Перенаправление\"}],[\"$\",\"td\",null,{\"children\":[\"Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"301\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"302\"}],\", \",[\"$\",\"span\",null,{\"className\":\"codde-mini\",\"children\":\"303\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"305\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"307\"}],\" относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Location\"}],\". При этом допускается использование фрагментов в целевом URI.\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"4xx\"}]}],[\"$\",\"td\",null,{\"children\":\"Ошибка клиент\"}],[\"$\",\"td\",null,{\"children\":[\"Запрос клиента содержит ошибку. При использовании всех методов, кроме \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"HEAD\"}],\", сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.\"]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"5xx\"}]}],[\"$\",\"td\",null,{\"children\":\"Ошибка сервера\"}],[\"$\",\"td\",null,{\"children\":[\"Операция не выполнена по вине сервера. Для всех ситуаций, кроме использования метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"HEAD\"}],\", сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.\"]}]]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Заголовки\"}],[\"$\",\"p\",null,{\"children\":[\"Заголовки HTTP (\",[\"$\",\"i\",null,{\"children\":\"HTTP Headers\"}],\") — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Примеры заголовков:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"Server: Apache/2.2.11 (Win32) PHP/5.3.0\",[\"$\",\"br\",null,{}],\"Last-Modified: Sat, 16 Jan 2010 21:16:42 GMT\",[\"$\",\"br\",null,{}],\"Content-Type: text/plain; charset=windows-1251\",[\"$\",\"br\",null,{}],\"Content-Language: ru\"]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"В примере выше каждая строка представляет собой один заголовок. При этом то, что находится до двоеточия, называется именем (name), а что после него — значением (value).\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Все заголовки разделяются на четыре основных группы:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Общие заголовки (\",[\"$\",\"i\",null,{\"children\":\"General Headers\"}],\") — применяются как к запросам, так и к ответам, но не относятся к передаваемым данным.\"]}],[\"$\",\"li\",null,{\"children\":[\"Заголовки запроса (\",[\"$\",\"i\",null,{\"children\":\"Request Headers\"}],\") — содержат дополнительную информацию, отправляемую клиентом на сервер.\"]}],[\"$\",\"li\",null,{\"children\":[\"Заголовки ответа (\",[\"$\",\"i\",null,{\"children\":\"Response Headers\"}],\") — содержат дополнительную информацию, отправляемую сервером клиенту.\"]}],[\"$\",\"li\",null,{\"children\":[\"Заголовки сущности (\",[\"$\",\"i\",null,{\"children\":\"Entity Headers\"}],\") — определяют метаинформацию о теле сущности, либо, если тело отсутствует, о ресурсе, идентифицированном запросом.\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Именно в таком порядке рекомендуется посылать заголовки получателю.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Все необходимые для функционирования HTTP заголовки описаны в основных \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"RFC\"}],\". Если не хватает существующих, то можно вводить свои. Традиционно к именам таких дополнительных заголовков добавляют префикс «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"X-\"}],\"» для избежания конфликта имён с возможно существующими. Например, как в заголовках \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"X-Powered-By\"}],\" или \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"X-Cache\"}],\". Некоторые разработчики используют свои индивидуальные префиксы. Примерами таких заголовков могут служить \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Ms-Echo-Request\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Ms-Echo-Reply\"}],\", введённые корпорацией Microsoft для расширения \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"WebDAV\"}],\".\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Тело сообщения\"}],[\"$\",\"p\",null,{\"children\":[\"Тело HTTP-сообщения (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"message-body\"}],\"), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом. Тело сообщения отличается от тела объекта (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"entity-body\"}],\") только в том случае, когда применяется кодирование передачи, \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Transfer-Encoding\"}],\"что указывается полем заголовка \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Transfer-Encoding\"}],\".\"]}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"message-body = entity-body\",[\"$\",\"br\",null,{}],\"| \",\"\u003c\",\"entity-body закодировано согласно\",[\"$\",\"br\",null,{}],\"Transfer-Encoding\",\"\u003e\"]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Поле \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Transfer-Encoding\"}],\" должно использоваться для указания любого кодирования передачи, применённого приложением в целях гарантирования безопасной и правильной передачи сообщения. Поле \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Transfer-Encoding\"}],\" — это свойство сообщения, а не объекта, и, таким образом, может быть добавлено или удалено любым приложением в цепочке запросов/ответов.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Правила, устанавливающие допустимость тела сообщения в сообщении, отличны для запросов и ответов.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content-Length\"}],\" или \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Transfer-Encoding\"}],\". Тело сообщения может быть добавлено в запрос, только когда метод запроса допускает тело объекта. Включается или не включается тело сообщения в сообщение ответа — зависит как от метода запроса, так и от кода состояния ответа. Все ответы на запрос с методом \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"HEAD\"}],\" не должны включать тело сообщения, даже если присутствуют поля заголовка объекта (\",[\"$\",\"span\",null,{\"className\":\"code-mini\"}],\"), заставляющие поверить в присутствие объекта. Никакие ответы с кодами состояния \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"1xx\"}],\" (Информационные), \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"204\"}],\" (Нет содержимого, \",[\"$\",\"span\",null,{\"className\":\"code-mini\"}],\"), и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"304\"}],\" (Не модифицирован, \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Not Modified\"}],\") не должны содержать тела сообщения. Все другие ответы содержат тело сообщения, даже если оно имеет нулевую длину.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Основные механизмы протокола\"}],[\"$\",\"h3\",null,{\"children\":\"Частичные GET\"}],[\"$\",\"p\",null,{\"children\":[\"HTTP позволяет запросить не сразу всё содержимое ресурса, а только указанный фрагмент. Такие запросы называются частичные GET; возможность их выполнения необязательна (но желательна) для серверов. Частичные GET в основном используются для докачки файлов и быстрого параллельного скачивания в нескольких потоках. Некоторые программы скачивают заголовок архива, выводят пользователю внутреннюю структуру, а потом уже запрашивают фрагменты с указанными элементами архива.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Для получения фрагмента клиент посылает серверу запрос с заголовком Range, указывая в нём необходимые байтовые диапазоны. Если сервер не понимает частичные запросы (игнорирует заголовок Range), то он вернёт всё содержимое со статусом 200, как и при обычном GET. В случае успешного выполнения сервер возвращает вместо кода 200 ответ со статусом 206 (Partial Content), включая в ответ заголовок Content-Range. Сами фрагменты могут быть переданы двумя способами:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"ul\",null,{\"className\":\"list-code\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"в ответе помещается заголовок \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content-Range\"}],\" с указанием байтовых диапазонов. В соответствии с ними фрагменты последовательно помещаются в основное тело. При этом \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content-Length\"}],\" должен соответствовать суммарному объёму всего тела;\"]}],[\"$\",\"li\",null,{\"children\":[\"сервер указывает медиатип \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"multipart/byterangescls\"}],\" для основного содержимого и передаёт фрагменты, указывая соответствующий \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content-Range\"}],\" для каждого элемента (см. также «Множественное содержимое»).\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Условные GET\"}],[\"$\",\"p\",null,{\"children\":[\"Метод \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" изменяется на «условный \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\"», если сообщение запроса включает в себя поле заголовка \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"If-Modified-Since\"}],\". В ответ на «условный \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\"» тело запрашиваемого ресурса передаётся, только если он изменялся после даты, указанной в заголовке \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"If-Modified-Since\"}],\". Алгоритм определения этого включает в себя следующие случаи:\"]}],[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"если статус ответа на запрос будет отличаться от «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"200 OK\"}],\"» или дата, указанная в поле заголовка «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"If-Modified-Since\"}],\"», некорректна, ответ будет идентичен ответу на обычный запрос \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\";\"]}],[\"$\",\"li\",null,{\"children\":[\"если после указанной даты ресурс изменялся, ответ будет также идентичен ответу на обычный запрос \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\";\"]}],[\"$\",\"li\",null,{\"children\":[\"если ресурс не изменялся после указанной даты, сервер вернет статус «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"304 Not Modified\"}],\"».\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Использование метода «условный \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\"» направлено на разгрузку сети, так как он позволяет не передавать по сети избыточную информацию.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Согласование содержимого\"}],[\"$\",\"p\",null,{\"children\":[\"Согласование содержимого (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content Negotiation\"}],\") — механизм автоматического определения необходимого ресурса при наличии нескольких разнотипных версий документа. Субъектами согласования могут быть не только ресурсы сервера, но и возвращаемые страницы с сообщениями об ошибках (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"403\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"404\"}],\" и т. п.).\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Различают два основных типа согласований:\"]}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"управляемое сервером (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"server-driven\"}],\");\"]}],[\"$\",\"li\",null,{\"children\":[\"управляемое клиентом (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"agent-driven\"}],\").\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"Одновременно могут быть использованы оба типа или каждый из них по отдельности.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"В основной спецификации по протоколу (\",[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://datatracker.ietf.org/doc/html/rfc2616\",\"className\":\"link-pr\",\"children\":[\"$\",\"span\",null,{\"className\":\"p-link-pr\",\"children\":[\"RFC 2616\",[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"fill\":\"none\",\"strokeLinejoin\":\"round\",\"strokeWidth\":\"32\",\"d\":\"M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"$undefined\"},\"height\":\"1em\",\"width\":\"1em\",\"xmlns\":\"http://www.w3.org/2000/svg\"}]]}]}],\") также выделяется так называемое прозрачное согласование (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"transparent negotiation\"}],\") как предпочтительный вариант комбинирования обоих типов. Последний механизм не следует путать с независимой технологией \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Transparent Content Negotiation\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"TCN\"}],\", «Прозрачное согласование содержимого», см. \",[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://datatracker.ietf.org/doc/html/rfc2295\",\"className\":\"link-pr\",\"children\":[\"$\",\"span\",null,{\"className\":\"p-link-pr\",\"children\":[\"RFC 2295\",[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"fill\":\"none\",\"strokeLinejoin\":\"round\",\"strokeWidth\":\"32\",\"d\":\"M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"$undefined\"},\"height\":\"1em\",\"width\":\"1em\",\"xmlns\":\"http://www.w3.org/2000/svg\"}]]}]}],\"), которая не является частью протокола HTTP, но может использоваться с ним. У обоих существенное различие в принципе работы и самом значении слова «прозрачное» (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"transparent\"}],\"). В спецификации по HTTP под прозрачностью подразумевается, что процесс не заметен для клиента и сервера, а в технологии \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"TCN\"}],\" прозрачность означает доступность полного списка вариантов ресурса для всех участников процесса доставки данных.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h4\",null,{\"children\":\"Управляемое сервером\"}],[\"$\",\"p\",null,{\"children\":[\"При наличии нескольких версий ресурса сервер может анализировать заголовки запроса клиента, чтобы выдать, по его мнению, наиболее подходящую. В основном анализируются заголовки \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Accept\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Accept-Charset\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Accept-Encoding\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Accept-Languages\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"cod-mini\",\"children\":\"User-Agent\"}],\". Серверу желательно включать в ответ заголовок \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Vary\"}],\" с указанием параметров, по которым различается содержимое по запрашиваемому \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"URI\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Географическое положение клиента можно определить по удалённому IP-адресу. Это возможно за счёт того что IP-адреса, как и доменные имена, регистрируются на конкретного человека или организацию. При регистрации указывается регион, в котором будет использоваться желаемое адресное пространство. Эти данные общедоступны, и в Интернете можно найти соответствующие свободно распространяемые базы данных и готовые программные модули для работы с ними (следует ориентироваться на ключевые слова «\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Geo IP\"}],\"»).\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Следует помнить что такой метод способен определить местоположение максимум с точностью до города (отсюда определяется и страна). При этом информация актуальна только на момент регистрации адресного пространства. Например, если московский провайдер зарегистрирует диапазон адресов с указанием Москвы и начнёт предоставлять доступ клиентам из ближайшего Подмосковья, то его абоненты могут на некоторых сайтах наблюдать, что они из Москвы, а не из Красногорска или Дзержинского.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Управляемое сервером согласование имеет несколько недостатков:\"]}],[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"сервер только предполагает, какой вариант наиболее предпочтителен для конечного пользователя, но не может знать точно, что именно нужно в данный момент (например, версия на русском языке или английском);\"}],[\"$\",\"li\",null,{\"children\":[\"заголовков группы \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Accept\"}],\" передаётся много, а ресурсов с несколькими вариантами — мало. Из-за этого оборудование испытывает избыточную нагрузку;\"]}],[\"$\",\"li\",null,{\"children\":\"общему кэшу создаётся ограничение возможности выдавать один и тот же ответ на идентичные запросы от разных пользователей;\"}],[\"$\",\"li\",null,{\"children\":[\"передача заголовков \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Accept\"}],\" также может раскрывать некоторые сведения о его предпочтениях, таких как используемые языки, браузер, кодировка.\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h4\",null,{\"children\":\"Управляемое клиентом\"}],[\"$\",\"p\",null,{\"children\":[\"В данном случае тип содержимого определяется только на стороне клиента. Для этого сервер возвращает в ответе с кодом состояния \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"300\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Multiple Choices\"}],\") или \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"406\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Not Acceptable\"}],\") список вариантов, среди которых пользователь выбирает подходящий. Управляемое клиентом согласование хорошо, когда содержимое различается по самым частым параметрам (например, по языку и кодировке) и используется публичный кэш.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Основной недостаток — лишняя нагрузка, так как приходится делать дополнительный запрос, чтобы получить нужное содержимое.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h4\",null,{\"children\":\"Прозрачное согласование\"}],[\"$\",\"p\",null,{\"children\":[\"Данное согласование полностью прозрачно для клиента и сервера. В данном случае используется общий кэш, в котором содержится список вариантов, как для управляемого клиентом согласования. Если кэш понимает все эти варианты, то он сам делает выбор, как при управляемом сервером согласовании. Это снижает нагрузки с исходного сервера и исключает дополнительный запрос со стороны клиента.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"В основной спецификации по протоколу HTTP механизм прозрачного согласования подробно не описан.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h4\",null,{\"children\":\"Множественное содержимое\"}],[\"$\",\"p\",null,{\"children\":[\"Протокол HTTP поддерживает передачу нескольких сущностей в пределах одного сообщения. Причём сущности могут передаваться не только в виде одноуровневой последовательности, но и в виде иерархии с вложением элементов друг в друга. Для обозначения множественного содержимого используются медиатипы \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"multipart/*\"}],\". Работа с такими типами осуществляется по общим правилам, описанным в \",[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://datatracker.ietf.org/doc/html/rfc2046\",\"className\":\"link-pr\",\"children\":[\"$\",\"span\",null,{\"className\":\"p-link-pr\",\"children\":[\"RFC 2046\",[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"fill\":\"none\",\"strokeLinejoin\":\"round\",\"strokeWidth\":\"32\",\"d\":\"M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"$undefined\"},\"height\":\"1em\",\"width\":\"1em\",\"xmlns\":\"http://www.w3.org/2000/svg\"}]]}]}],\" (если иное не определено конкретным медиатипом). Если получателю не известно как работать с типом, то он обрабатывает его так же, как \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"multipart/mixed\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Параметр \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"boundary\"}],\" означает разделитель между различными типами передаваемых сообщений. Например, передаваемый из формы параметр \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"DestAddress\"}],\" передаёт значение адреса e-mail, а следующий за ним элемент \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"AttachedFile1\"}],\" отправляет двоичное содержимое изображения формата \",[\"$\",\"span\",null,{\"className\":\"img-code\",\"children\":\".jpg\"}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Со стороны сервера сообщения со множественным содержимым могут посылаться в ответ на частичные \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"GET\"}],\" при запросе нескольких фрагментов ресурса. В этом случае используется медиатип \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"multipart/byteranges\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Со стороны клиента при отправке HTML-формы чаще всего пользуются методом \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"POST\"}],\". Типичный пример: страницы отправки электронных писем со вложенными файлами. При отправке такого письма браузер формирует сообщение типа \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"multipart/form-data\"}],\", интегрируя в него как отдельные части, введённые пользователем, тему письма, адрес получателя, сам текст и вложенные файлы:\"]}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"POST /send-message.html HTTP/1.1\",[\"$\",\"br\",null,{}],\"Host: mail.example.com\",[\"$\",\"br\",null,{}],\"Referer: http://mail.example.com/send-message.html\",[\"$\",\"br\",null,{}],\"User-Agent: BrowserForDummies/4.67b\",[\"$\",\"br\",null,{}],\"Content-Type: multipart/form-data; boundary=\\\"Asrf456BGe4h\\\"\",[\"$\",\"br\",null,{}],\"Content-Length: (суммарный объём, включая дочерние заголовки)\",[\"$\",\"br\",null,{}],\"Connection: keep-alive\",[\"$\",\"br\",null,{}],\"Keep-Alive: 300\",[\"$\",\"br\",null,{}],\"(пустая строка)\",[\"$\",\"br\",null,{}],\"(отсутствующая преамбула)\",[\"$\",\"br\",null,{}],\"--Asrf456BGe4h\",[\"$\",\"br\",null,{}],\"Content-Disposition: form-data; name=\\\"DestAddress\\\"\",[\"$\",\"br\",null,{}],\"(пустая строка)\",[\"$\",\"br\",null,{}],\"brutal-vasya@example.com—Asrf456BGe4h\",[\"$\",\"br\",null,{}],\"Content-Disposition: form-data; name=\\\"MessageTitle\\\"\",[\"$\",\"br\",null,{}],\"(пустая строка)\",[\"$\",\"br\",null,{}],\"Я негодую—Asrf456BGe4h\",[\"$\",\"br\",null,{}],\"Content-Disposition: form-data; name=\\\"MessageText\\\"\",[\"$\",\"br\",null,{}],\"(пустая строка)\",[\"$\",\"br\",null,{}],\"Привет, Василий! Твой ручной лев, которого ты оставил\",[\"$\",\"br\",null,{}],\"у меня на прошлой неделе, разодрал весь мой диван.\",[\"$\",\"br\",null,{}],\"Пожалуйста, забери его скорее!\",[\"$\",\"br\",null,{}],\"Во вложении две фотки с последствиями.\",[\"$\",\"br\",null,{}],\"--Asrf456BGe4h\",[\"$\",\"br\",null,{}],\"Content-Disposition: form-data; name=\\\"AttachedFile1\\\"; filename=\\\"horror-photo-1.jpg\\\"\",[\"$\",\"br\",null,{}],\"Content-Type: image/jpeg\",[\"$\",\"br\",null,{}],\"(пустая строка)\",[\"$\",\"br\",null,{}],\"(двоичное содержимое первой фотографии)\",[\"$\",\"br\",null,{}],\"--Asrf456BGe4h\",[\"$\",\"br\",null,{}],\"Content-Disposition: form-data; name=\\\"AttachedFile2\\\"; filename=\\\"horror-photo-2.jpg\\\"\",[\"$\",\"br\",null,{}],\"Content-Type: image/jpeg\",[\"$\",\"br\",null,{}],\"(пустая строка)\",[\"$\",\"br\",null,{}],\"(двоичное содержимое второй фотографии)\",[\"$\",\"br\",null,{}],\"--Asrf456BGe4h--\",[\"$\",\"br\",null,{}],\"(отсутствующий эпилог)\"]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"В примере в заголовках \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Content-Disposition\"}],\" параметр \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"name\"}],\" соответствует атрибуту name в HTML-тегах \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"\u003cINPUT\u003e\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"\u003cTEXTAREA\u003e\"}],\". Параметр \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"filename\"}],\" равен исходному имени файла на компьютере пользователя. Более подробная информация о формировании HTML-форм и вложении файлов в \",[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://datatracker.ietf.org/doc/html/rfc1867\",\"className\":\"link-pr\",\"children\":[\"$\",\"span\",null,{\"className\":\"p-link-pr\",\"children\":[\"RFC 1867\",[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"fill\":\"none\",\"strokeLinejoin\":\"round\",\"strokeWidth\":\"32\",\"d\":\"M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"$undefined\"},\"height\":\"1em\",\"width\":\"1em\",\"xmlns\":\"http://www.w3.org/2000/svg\"}]]}]}],\".\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"История развития\"}],[\"$\",\"h3\",null,{\"children\":\"HTTP/0.9\"}],[\"$\",\"p\",null,{\"children\":\"HTTP был предложен в марте 1991 года Тимом Бернерсом-Ли, работавшим тогда в CERN, как механизм для доступа к документам в Интернете и облегчения навигации посредством использования гипертекста. Самая ранняя версия протокола HTTP/0.9 была впервые опубликована в январе 1992 года (хотя реализация датируется 1990 годом). Спецификация протокола привела к упорядочению правил взаимодействия между клиентами и серверами HTTP, а также чёткому разделению функций между этими двумя компонентами. Были задокументированы основные синтаксические и семантические положения.\"}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"HTTP/1.0\"}],[\"$\",\"p\",null,{\"children\":[\"В мае 1996 года для практической реализации HTTP был выпущен информационный документ \",[\"$\",\"a\",null,{\"target\":\"_blank\",\"href\":\"https://datatracker.ietf.org/doc/html/rfc1945\",\"className\":\"link-pr\",\"children\":[\"$\",\"span\",null,{\"className\":\"p-link-pr\",\"children\":[\"RFC 1945\",[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"fill\":\"none\",\"strokeLinejoin\":\"round\",\"strokeWidth\":\"32\",\"d\":\"M448 256 272 88v96C103.57 184 64 304.77 64 424c48.61-62.24 91.6-96 208-96v96z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"$undefined\"},\"height\":\"1em\",\"width\":\"1em\",\"xmlns\":\"http://www.w3.org/2000/svg\"}]]}]}],\", что послужило основой для реализации большинства компонентов HTTP/1.0.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"HTTP/1.1\"}],[\"$\",\"p\",null,{\"children\":\"Современная версия протокола; принята в июне 1999 года. Новым в этой версии был режим «постоянного соединения»: TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент теперь обязан посылать информацию об имени хоста, к которому он обращается, что сделало возможной более простую организацию виртуального хостинга.\"}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"HTTP/2\"}],[\"$\",\"p\",null,{\"children\":\"11 февраля 2015 года опубликованы финальные версии черновика следующей версии протокола. В отличие от предыдущих версий, протокол HTTP/2 является бинарным. Среди ключевых особенностей: мультиплексирование запросов, расстановка приоритетов для запросов, сжатие заголовков, загрузка нескольких элементов параллельно посредством одного TCP-соединения, поддержка проактивных push-уведомлений со стороны сервера.\"}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"HTTP/3\"}],[\"$\",\"p\",null,{\"children\":\"HTTP/3 — предлагаемый последователь HTTP/2, который уже используется в Веб на основе UDP вместо TCP в качестве транспортного протокола. Как и HTTP/2, он не объявляет устаревшими предыдущие основные версии протокола. Поддержка HTTP/3 была добавлена в Cloudflare и Google Chrome в сентябре 2019 года и может быть включена в стабильных версиях Chrome и Firefox.\"}]]}]]}],null,[\"$\",\"$L7\",null,{\"children\":\"$L8\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"3fqvX7ozn_nseHfWFCdaP\",{\"children\":[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\na:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"http:\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Протокол HTTP\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script></body></html>