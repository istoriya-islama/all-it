<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/1633334b8bd4f972.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-91ddf6d7f343849d.js"/><script src="/_next/static/chunks/4bd1b696-69fef5d6b9a28cb8.js" async=""></script><script src="/_next/static/chunks/517-4c347518e380ea9b.js" async=""></script><script src="/_next/static/chunks/main-app-05f541b8e5bab6fa.js" async=""></script><script src="/_next/static/chunks/173-adb53e817c3964da.js" async=""></script><script src="/_next/static/chunks/970-fdca2819562abdd0.js" async=""></script><script src="/_next/static/chunks/app/pages/posts/CSharp/page-7d785bd99510dee4.js" async=""></script><script src="/_next/static/chunks/8e1d74a4-d5fa8b652382e494.js" async=""></script><script src="/_next/static/chunks/app/layout-8dc7d88f1573f6b1.js" async=""></script><title>C#</title><meta name="description" content="Язык програмиорование C#"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_b962f2"><div class="container"><header><h1>Все о Программировании</h1><nav><ul><li><a href="/">Главная</a></li><li><a href="/pages/post">Статьи</a></li><li class="search"><a href="/pages/search"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" color="white" style="color:white" height="20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg></a></li><li class="btn"><a href="https://t.me/it_reviews_other">Зайди к нам</a></li></ul></nav></header><div class="page"><div><div class="cover"><h3>Все о Программировании</h3><h1>C#| Си Шарп</h1><a href="https://t.me/it_reviews_other"><img alt="cover" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent" srcSet="/_next/image?url=%2FallIt.jpg&amp;w=128&amp;q=75 1x, /_next/image?url=%2FallIt.jpg&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2FallIt.jpg&amp;w=256&amp;q=75"/></a><div></div></div><div class="text"><q>C# (произносится си шарп) — объектно-ориентированный язык программирования общего назначения. Разработан в 1998—2001 годах группой инженеров компании Microsoft под руководством Андерса Хейлсберга и Скотта Вильтаумота как язык разработки приложений для платформы Microsoft .NET Framework и .NET Core. Впоследствии был стандартизирован как ECMA-334 и ISO/IEC 23270.<br/><br/>C# относится к семье языков с C-подобным синтаксисом, из них его синтаксис наиболее близок к C++ и Java. Язык имеет статическую типизацию, поддерживает полиморфизм, перегрузку операторов (в том числе операторов явного и неявного приведения типа), делегаты, атрибуты, события, переменные, свойства, обобщённые типы и методы, итераторы, анонимные функции с поддержкой замыканий, LINQ, исключения, комментарии в формате XML.<br/><br/>Переняв многое от своих предшественников — языков C++, Delphi, Модула, Smalltalk и, в особенности, Java — С#, опираясь на практику их использования, исключает некоторые модели, зарекомендовавшие себя как проблематичные при разработке программных систем, например, C# в отличие от C++ не поддерживает множественное наследование классов (между тем допускается множественная реализация интерфейсов).</q><br/><br/><h2>Особенности языка</h2><p>С# разрабатывался как язык программирования прикладного уровня для CLR и, как таковой, зависит, прежде всего, от возможностей самой CLR. Это касается, прежде всего, системы типов С#, которая отражает BCL. Присутствие или отсутствие тех или иных выразительных особенностей языка диктуется тем, может ли конкретная языковая особенность быть транслирована в соответствующие конструкции CLR. Так, с развитием CLR от версии 1.1 к 2.0 значительно обогатился и сам C#; подобного взаимодействия следует ожидать и в дальнейшем (однако, эта закономерность была нарушена с выходом C# 3.0, представляющего собой расширения языка, не опирающиеся на расширения платформы .NET). CLR предоставляет С#, как и всем другим .NET-ориентированным языкам, многие возможности, которых лишены «классические» языки программирования. Например, сборка мусора не реализована в самом C#, а производится CLR для программ, написанных на C#, точно так же, как это делается для программ на VB.NET, J# и др.</p><br/><br/><h2>Название языка</h2><p>Название «Си шарп» (от англ. sharp — диез) происходит от буквенной музыкальной нотации, где латинской букве C соответствует нота До, а знак диез (англ. sharp) означает повышение соответствующего ноте звука на полутон, что аналогично названию языка C++, где «++» обозначает инкремент переменной. Название также является игрой с цепочкой C → C++ → C++++(C#), так как символ «#» можно представить состоящим из 4 знаков «+».<br/><br/>Из-за технических ограничений на отображение (стандартные шрифты, браузеры и т. д.), а также из-за того, что знак диеза ♯ не представлен на стандартной клавиатуре компьютера, при записи имени языка программирования используют знак решётки (#). Это соглашение отражено в Спецификации языка C# ECMA-334. Тем не менее, на практике (например, при размещении рекламы и коробочном дизайне), «Майкрософт» использует знак диеза.<br/><br/>Названия языков программирования не принято переводить, поэтому язык называют, используя транскрипцию, — «Си шарп».</p><br/><br/><h2>Стандартизация</h2><p>C# стандартизирован в ECMA (ECMA-334) и ISO (ISO/IEC 23270).<br/><br/>Известно как минимум о трёх независимых реализациях C#, базирующихся на этой спецификации и находящихся в настоящее время на различных стадиях разработки:</p><br/><ul><li>Mono, начата компанией Ximian, продолжена её покупателем и преемником Novell, а затем Xamarin.</li><li>dotGNU и Portable.NET, разрабатываемые Free Software Foundation.</li></ul><br/><br/><h2>Версии</h2><table><tr><th>Версия</th><th>Дата выхода</th><th>Совместимые версии .NET</th><th>Совместимая версия Visual Studio</th></tr><tr><td>C# 1.0</td><td>Январь 2002</td><td>.NET Framework 1.0</td><td>Visual Studio .NET (2002)</td></tr><tr><td>C# 1.1<br/>C# 1.2</td><td>Апрель 2003</td><td>.NET Framework 1.1</td><td>Visual Studio .NET 2003</td></tr><tr><td>C# 2.0</td><td>Ноябрь 2005</td><td>.NET Framework 2.0<br/>.NET Framework 3.0</td><td>Visual Studio 2005</td></tr><tr><td>C# 3.0</td><td>Ноябрь 2007</td><td>.NET Framework 2.0 (кроме LINQ)<br/>.NET Framework 3.0 (кроме LINQ)<br/>.NET Framework 3.5</td><td>Visual Studio 2008</td></tr><tr><td>C# 4.0</td><td>Апрель 2010</td><td>.NET Framework 4.0</td><td>Visual Studio 2010</td></tr><tr><td>C# 5.0</td><td>Август 2012</td><td>.NET Framework 4.5</td><td>Visual Studio 2012</td></tr><tr><td>C# 6.0</td><td>Июль 2015</td><td>.NET Framework 4.6<br/>.NET Core 1.0<br/>.NET Core 1.1</td><td>Visual Studio 2015</td></tr><tr><td>C# 7.0</td><td>Март 2017</td><td>.NET Framework 4.6.2<br/>.NET Framework 4.7</td><td>Visual Studio 2017 15.0</td></tr><tr><td>C# 7.1</td><td>Август 2017</td><td>.NET Core 2.0</td><td>Visual Studio 2017 15.3</td></tr><tr><td>C# 7.2</td><td>Ноябрь 2017</td><td>Нету</td><td>Visual Studio 2017 15.5</td></tr><tr><td>C# 7.3</td><td>Май 2018</td><td>.NET Core 2.1<br/>.NET Core 2.2.<br/>.NET Framework 4.8</td><td>Visual Studio 2017 15.7</td></tr><tr><td>C# 8.0</td><td>Сентябрь 2019</td><td>.NET Core 3.0<br/>.NET Core 3.1<br/>.NET Framework 4.8</td><td>Visual Studio 2019 16.3</td></tr><tr><td>C# 9.0</td><td>Сентябрь 2020</td><td>.NET 5.0</td><td>Visual Studio 2019 16.8</td></tr><tr><td>C# 10.0</td><td>Июль 2021</td><td>.NET 6.0</td><td>Visual Studio 2022 17.0</td></tr><tr><td>C# 11.0</td><td>Ноябрь 2022</td><td>.NET 7.0</td><td>Visual Studio 2022 17.4</td></tr><tr><td>C# 12.0</td><td>Ноябрь 2023</td><td>.NET 8.0</td><td>Visual Studio 2022 17.8</td></tr></table><br/><h5>Общая информация по версиям</h5><table><tr><th>Версия</th><th>Нововведения</th></tr><tr><td>C# 2.0</td><td><ul class="list"><li>Частичные типы</li><li>Обобщённые типы (generics)</li><li>Итераторы и ключевое слово <span class="code-mini">yield</span></li><li>Анонимные методы</li><li>Оператор null-объединения</li><li>Nullable-типы</li></ul></td></tr><tr><td>C# 3.0</td><td><ul class="list"><li>Запросы, интегрированные в язык (LINQ)</li><li>Инициализаторы объектов и коллекций</li><li>Лямбда-выражения</li><li>Деревья выражений</li><li>Неявная типизация и ключевое слово <span class="code-mini">var</span></li><li>Анонимные типы</li><li>Методы расширения</li><li>Автоматические свойства</li></ul></td></tr><tr><td>C# 4.0</td><td><ul class="list"><li>Динамическое связывание и ключевое слово <span class="code-mini">dynamic</span></li><li>Именованные и опциональные аргументы</li><li>Обобщенная ковариантность и контрвариантность</li><li>Библиотека TPL, концепция задач и классы <span class="code-mni">Task</span>, <span class="code-mni">Parallel</span></li><li>Класс <span class="code-mini">MemoryCache</span></li><li>Классы параллельных коллекций</li></ul></td></tr><tr><td>C# 5.0</td><td><ul class="list"><li>Шаблон TAP</li><li>Асинхронные методы <span class="code-mini">async</span> и <span class="code-mini">await</span></li><li>Сведения о вызывающем объекте</li></ul></td></tr><tr><td>C# 6.0</td><td><ul class="list"><li>Компилятор как сервис</li><li>Импорт членов статических типов в пространство имён</li><li>Фильтры исключений</li><li><span class="code-mini">await</span> в блоках <span class="code-mini">catch</span>/<span class="code-mini">finally</span></li><li>Инициализаторы автосвойств</li><li>Автосвойства только для чтения</li><li>null-условные операции (<span class="code-mini">?.</span> и <span class="code-mini">?[])</span></li><li>Интерполяция строк</li><li>Оператор <span class="code-mini">nameof</span></li><li>Инициализатор словаря</li><li>Функции сжатые до выражений</li></ul></td></tr><tr><td>C# 7.0</td><td><ul class="list"><li><span class="code-mini">out</span>-переменные</li><li>Сопоставление с шаблоном</li><li>Шаблоны с <span class="code-mini">is</span></li><li>Шаблоны и выражение <span class="code-mini">switch</span></li><li>Кортежи</li><li>Распаковка кортежей (деконструкторы)</li><li>Локальные функции</li><li>Улучшения литералов</li><li>Локальные переменные и возвращаемые значения по ссылке</li><li>Расширение списка типов, возвращаемых асинхронными методами</li><li>Больше членов класса в виде выражений</li><li><span class="code-mini">throw</span> выражения</li></ul></td></tr><tr><td>C# 8.0</td><td><ul class="list"><li>Члены только для чтения</li><li>Члены интерфейса по умолчанию</li><li>Улучшения сопоставления шаблонов</li><li>Объявления using</li><li>Статические локальные функции</li><li>Удаляемые ссылочные структуры</li><li>Ссылочные типы, допускающие значение NULL</li><li>Асинхронные потоки</li><li>Индексы и диапазоны</li><li>Присваивание объединения со значением NULL</li><li>Неуправляемые сконструированные типы</li><li>Выражения stackalloc во вложенных выражениях</li><li>Больше членов класса в виде выражений</li><li>Улучшения интерполированных строк</li></ul></td></tr><tr><td>C# 9.0</td><td><ul class="list"><li>Оператор объединения с null (??)</li><li>Пустые параметры для лямбда-выражений</li><li>Native Int: nint, nuint</li><li>Дизъюнктное объединение</li><li>Добавлено <span class="code-mini">with</span>-выражения</li><li>новый модификатор <span class="code-mini">initonly</span></li></ul></td></tr><tr><td>C# 10.0</td><td><ul class="list"><li>Добавление <span class="code-mini">role=&quot;alert&quot;</span> атрибуты сообщений</li><li>Обновления <span class="code-mini">Counter</span> компонент для добавления <span class="code-mini">role=&quot;status&quot;</span></li><li>Замена ul в <span class="code-mini">NavBar</span> компонент для <span class="code-mini">nav</span></li><li>Новое название кнопки переключения <span class="code-mini">NavBar</span></li><li>Переход к использованию более семантической разметки</li></ul></td></tr><tr><td>C# 11.0</td><td><ul class="list"><li>Необработанные строковые литералы</li><li>Поддержка универсальной математики</li><li>Универсальные атрибуты</li><li>Строковые литералы UTF-8</li><li>Новые строки в выражениях интерполяции строк</li><li>Шаблоны списка</li><li>Локальные типы файлов</li><li>Обязательные элементы</li><li>Автоматические структуры по умолчанию</li><li>Сопоставление <span class="code-mini">Span<!-- -->&lt;char&gt;</span> шаблонов для константы string</li><li>Расширенные <span class="code-mini">nameof</span> область</li><li>Числовой <span class="code-mini">intPtr</span></li><li><span class="code-mini">ref</span> поля и <span class="code-mini">scoped ref</span></li><li>Улучшенное преобразование групп методов для делегирования.</li></ul></td></tr></table><br/><h3>Версия 1.0</h3><p>Проект C# был начат в декабре 1998 и получил кодовое название COOL (C-style Object Oriented Language). Версия 1.0 была анонсирована вместе с платформой .NET в июне 2000 года, тогда же появилась и первая общедоступная бета-версия; C# 1.0 окончательно вышел вместе с Microsoft Visual Studio .NET в феврале 2002 года.<br/><br/>Первая версия C# напоминала по своим возможностям Java 1.4, несколько их расширяя: так, в C# имелись свойства (выглядящие в коде как поля объекта, но на деле вызывающие при обращении к ним методы класса), индексаторы (подобные свойствам, но принимающие параметр как индекс массива), события, делегаты, циклы <span class="code-mini">foreach</span>, структуры, передаваемые по значению, автоматическое преобразование встроенных типов в объекты при необходимости (boxing), атрибуты, встроенные средства взаимодействия с неуправляемым кодом (DLL, COM) и прочее.<br/><br/>Кроме того, в C# решено было перенести некоторые возможности C++, отсутствовавшие в Java: беззнаковые типы, перегрузку операторов (с некоторыми ограничениями, в отличие от C++), передача параметров в метод по ссылке, методы с переменным числом параметров, оператор <span class="code-mini">goto</span> (с ограничениями). Также в C# оставили ограниченную возможность работы с указателями — в местах кода, специально обозначенных словом <span class="code-mini">unsafe</span> и при указании специальной опции компилятору.</p><br/><h3>Версия 2.0</h3><p>Проект спецификации C# 2.0 впервые был опубликован Microsoft в октябре 2003 года; в 2004 году выходили бета-версии (проект с кодовым названием Whidbey), C# 2.0 окончательно вышел 7 ноября 2005 года вместе с Visual Studio 2005 и .NET 2.0.</p><h4>Новые возможности в версии 2.0</h4><ul class="list"><li>Частичные типы (разделение реализации класса более чем на один файл).</li><li>Обобщённые, или параметризованные типы (generics). В отличие от шаблонов C++, они поддерживают некоторые дополнительные возможности и работают на уровне виртуальной машины. Вместе с тем, параметрами обобщённого типа не могут быть выражения, они не могут быть полностью или частично специализированы, не поддерживают шаблонных параметров по умолчанию, от шаблонного параметра нельзя наследоваться, и т. д.</li><li>Новая форма итератора, позволяющая создавать сопрограммы с помощью ключевого слова <span class="code-mini">yeild</span>, подобно Python и Ruby.</li><li>Анонимные методы, обеспечивающие функциональность замыкания.</li><li>Оператор null-объединения: <span class="code-mini">&#x27;??&#x27;: return obj1 ?? obj2;</span> означает (в нотации C# 1.0) <span class="code-mini">return obj1!=null ? obj1 : obj2;</span>.</li><li>Обнуляемые (nullable) типы — значения (обозначаемые вопросительным знаком, например, <span class="code-mini">int? i = null;</span>), представляющие собой те же самые типы-значения, способные принимать также значение <span class="code-mini">null</span>. Такие типы позволяют улучшить взаимодействие с базами данных через язык SQL.</li><li>Поддержка 64-разрядных вычислений, что кроме всего прочего, позволяет увеличить адресное пространство и использовать 64-разрядные примитивные типы данных.</li></ul><br/><h3>Версия 3.0</h3><p>В июне 2004 года Андерс Хейлсберг впервые рассказал на сайте Microsoft о планируемых расширениях языка в C#3.0. В сентябре 2005 года вышли проект спецификации C# 3.0 и бета-версия C# 3.0, устанавливаемая в виде дополнения к существующим Visual Studio 2005 и .NET 2.0. Окончательно эта версия языка вошла в Visual Studio 2008 и .NET 3.5.</p><h4>Новые возможности в версии 3.0</h4><p>В C# 3.0 появились следующие радикальные добавления к языку:</p><ul class="list"><li>ключевые слова <span class="code-mini">select, from, where</span>, позволяющие делать запросы из XML документов, коллекций и т. п. Эти запросы имеют сходство с запросами SQL и реализуются компонентом LINQ. (Сама фраза «language integrated query» переводится «запрос, интегрированный в язык».)</li><li class="padding-hover">Инициализация объекта вместе с его свойствами:<div class="code">Customer c = new Customer();<br/>c.Name = &quot;James&quot;; c.Age=30;</div>можно записать как<div class="code-big-mini">Customer c = new Customer <!-- -->{ Name = &quot;James&quot;, Age = 30 }<!-- -->;</div></li><li class="padding-hover">Лямбда-выражения:<div class="code-big-mini">listOfFoo.Where(delegate(Foo x) <!-- -->{ return x.size &gt; 10; }<!-- -->);</div>теперь можно записать как<div class="code-big-mini">listOfFoo.Where(x <!-- -->=&gt;<!-- --> x.size <!-- -->&gt;<!-- --> 10);</div></li><li>Деревья выражений:<br/>лямбда-выражения теперь могут представляться в виде структуры данных, доступной для обхода во время выполнения, тем самым позволяя транслировать строго типизированные C#-выражения в другие домены (например, выражения SQL).</li><li>Неявная типизация: Вывод типов локальной переменной. Для неявной типизации вместо названия типа данных используется ключевое слово var. Затем уже при компиляции компилятор сам выводит тип данных исходя из присвоенного значения: <span class="code-mini">var x = &quot;hello&quot;;</span> вместо <span class="code-mini">string x = &quot;hello&quot;;</span></li><li>Анонимные типы: <span class="code-mini">var x = new <!-- -->{ Name = &quot;Muhammad&quot; }<!-- -->;</span></li><li class="padding-hover">Методы расширения. Появилась возможность добавления новых методов в уже существующие классы. Реализуется с помощью ключевого слова this при первом параметре статической функции статического класса.<div class="code">public static class StringExtensions<br/>{<br/>        public static int ToInt32(this string val)<br/>        <!-- -->{<br/>                return Int32.Parse(val);<br/>        <!-- -->}<br/>}<br/>// ...<br/>string s = &quot;10&quot;;<br/>int x = s.ToInt32();</div></li><li class="padding-hover">Автоматические свойства: компилятор сгенерирует закрытое (private) поле и соответствующие аксессор и мутатор для кода вида<div class="code-big-mini">public string Name <!-- -->{ get; private set; }</div></li></ul><p>C# 3.0 совместим с C# 2.0 по генерируемому MSIL-коду; улучшения в языке — чисто синтаксические и реализуются на этапе компиляции. Например, многие из интегрированных запросов LINQ можно осуществить, используя безымянные делегаты в сочетании с предикатными методами над контейнерами наподобие <span class="code-mini">List.FindAll</span> и <span class="code-mini">List.RemoveAll</span>.</p><br/><h3>Версия 4.0</h3><p>Превью C# 4.0 было представлено в конце 2008 года, вместе с CTP-версией Visual Studio 2010.<br/><br/>Visual Basic 10.0 и C# 4.0 были выпущены в апреле 2010 года, одновременно с выпуском Visual Studio 2010.</p><h4>Новые возможности в версии 4.0</h4><ul class="list"><li>Возможность использования позднего связывания, для использования:<ul class="in-list"><li>с языками с динамической типизацией (<a href="../Python">Python</a>, <a href="../Ruby">Ruby</a>)</li><li>с COM-объектами</li><li>отражения (reflection)</li><li>объектов с изменяемой структурой (DOM). Появляется ключевое слово <span class="code-mini">dynamic</span>.</li></ul></li><li>Именованные и опциональные параметры</li><li>Новые возможности COM interop</li><li>Ковариантность и контравариантность обобщенных интерфейсов и делегатов</li><li>Контракты в коде (Code Contracts)</li><li>Библиотека параллельных задач TPL (Task Parallel Library), концепция задач и классы <span class="code-mini">Task</span>, <span class="code-mini">TaskFactory</span>, <span class="code-mini">Parallel</span></li><li>Добавлен класс <span class="code-mini">MemoryCache</span>, который предназначен для кэширования контента. Он похож на класс <span class="code-mini">Cache</span> ASP.NET, но его можно использовать при написании веб- / графических / консольных приложений.</li><li>Добавлено пространство имен System.Collections.Concurrent и новые классы параллельных коллекций (ConcurrentQueue, ConcurrentStack, ConcurrentBag,…), которые предоставляют не только большую эффективность, но и более полную потокобезопасность.</li></ul><br/><p>Примеры:</p><br/><div class="code">dynamic calc = GetCalculator();<br/>int sum = calc.Add(10, 20); // Динамический вызов</div><br/><div class="code">public void SomeMethod(int x, int y = 5, int z = 7); // Опциональные параметры</div><br/><h3>Версия 5.0</h3><h4>Новые возможности в версии 5.0</h4><ul class="list"><li>Шаблон TAP (Task-based Asynchronous Pattern). TAP использует один метод для представления инициализации и завершения асинхронной операции.</li><li>Асинхронные методы (<span class="code-mini">async</span> и <span class="code-mini">await</span>) — как реализация шаблона TAP.</li><li>Сведения о вызывающем объекте</li></ul><br/><h3>Версия 6.0</h3><h4>Новые возможности в версии 6.0</h4><ul class="list-code"><li>null-условные операторы. Добавлены новые операторы: ?. и ?[]:<br/><div class="code-big-mini">int? length = customers?.Length; // null if customers is null<br/>Customer first = customers?[0];  // null if customers is null</div></li><li>Функции сжатые до выражений (expression-bodied functions). Теперь определение метода может быть задано с использованием лямбда-синтаксиса:<br/><div class="code-big-mini">public Point Move(int dx, int dy) <!-- -->=&gt;<!-- --> new Point(x + dx, y + dy);</div></li><li>Инициализаторы автосвойств. Автосвойства теперь можно инициализировать при объявлении:<br/><div class="code-big-mini">public string First <!-- -->{ get; set; }<!-- --> = &quot;Jane&quot;;</div></li><li>Автосвойства только для чтения. Автосвойства теперь могут быть объявлены без сеттеров:<br/><div class="code-big-mini">public string First <!-- -->{ get; }<!-- --> = &quot;Jane&quot;;</div></li><li>Инициализаторы индексов. Теперь можно инициализировать не только объекты и коллекции, но и словари:<br/><div class="code-big-mini">var numbers = new Dictionary<!-- -->&lt;int, string&gt;<!-- --> <!-- -->{<br/>        [7] = &quot;seven&quot;,<br/>        [9] = &quot;nine&quot;,<br/>        [13] = &quot;thirteen&quot;<br/>}<!-- -->;</div></li><li>Интерполяция строк. Вместо использования конструкций с <span class="code-mini">String.Format()</span>, например:<br/><div class="code-big-mini">var s = String.Format(&quot;<!-- -->{0}<!-- --> is <!-- -->{1}<!-- --> year<!-- -->{{s}}<!-- --> old&quot;, p.Name, p.Age);</div><br/>теперь можно размещать код прямо в строке:<br/><div class="code-big-mini">теперь можно размещать код прямо в строке:</div></li><li>Фильтры исключений. Появилась возможность задавать условия для блоков <span class="code-mini">catch</span>:<br/><div class="code-big-mini">try <!-- -->{ … }<!-- --> catch (Exception e) when (Log(e)) <!-- -->{ … }</div></li><li>Импорт статических функций типов. Теперь доступ к статическим членам типов возможен без указания полного имени этих членов:<br/><div class="code-big-mini">using static System.Console;<br/>using static System.Math;<br/>class Program<br/>{<br/>        static void Main()<br/>        <!-- -->{<br/>                WriteLine(Sqrt(3*3 + 4*4));<br/>        <!-- -->}<br/>}</div></li><li>Оператор <span class="code-mini">nameof</span>. Новый оператор, который возвращает компактное строковое представление для переданного в качестве аргумента типа:<br/><div class="code-big-mini">WriteLine(nameof(person.Address.ZipCode)); // prints &quot;ZipCode&quot;</div></li><li>Для асинхронного программирования была добавлена возможность использования операторов <span class="code-mini">await</span> внутри блоков <span class="code-mini">catch</span> и <span class="code-mini">finally</span>:<br/><div class="code-big-mini">Resource res = null;<br/>try<br/>{<br/>        res = await Resource.OpenAsync(…);       // You could do this.<br/>}<br/>catch(ResourceException e)<br/>{<br/>        await Resource.LogAsync(res, e);         // Now you can do this …<br/>}<br/>finally<br/>}<br/>        if (res != null) await res.CloseAsync(); // … and this.<br/>}</div></li></ul><br/><h3>Версия 7.0</h3><h4>Новые возможности в версии 7.0</h4><ul class="list"><li class="padding-hover"><span class="code-mini">out</span>-переменные, которые позволяют объявить переменные сразу в вызове метода (причем областью видимости для таких переменных является внешний блок):<br/><div class="code-big-mini">p.GetCoordinates(out int x, out int y);</div></li><li>Сопоставление с шаблоном. Вводится понятие шаблона (<span class="code-mini">pattern</span>), который представляет собой синтаксическую конструкцию, позволяющую проверить соответствие переменной определённой форме и извлечь из неё информацию.</li><li>Шаблоны с <span class="code-mini">is</span> (<span class="code-mini">is</span> теперь может использоваться не только с типом, но и с шаблоном — в качестве правого аргумента)</li><li>Шаблоны и выражение <span class="code-mini">switch</span>. Варианты использования <span class="code-mini">switch</span> были расширены, теперь можно:<br/><ul class="in-list"><li>использовать любые типы (не только примитивные);</li><li>использовать шаблоны в выражениях <span class="code-mini">case</span>;</li><li>добавлять дополнительные условия к выражениям <span class="code-mini">case</span> (используя ключевое слово <span class="code-mini">when</span>).</li></ul></li><li class="padding-hover">Кортежи. Добавлен тип кортеж значений (структура <span class="code-mini">ValueTuple</span>) и синтаксис работы с данными этого типа:<br/><div class="code-big-mini">(string, string, string) LookupName(long id) // возвращаемый тип - кортеж<br/>{<br/>        ... // инициализируем данные<br/>        return (first, middle, last); // литерал кортежа<br/>}</div></li><li>Распаковка кортежей. Была добавлена новая синтаксическая конструкция деконструктор, позволяющая извлечь кортеж, состоящий из членов класса.</li><li>окальные функции. Теперь функцию, которая используется только в теле какого-либо метода, можно объявить прямо в теле этого метода.</li><li>Улучшения литералов. Были добавлены бинарные литералы и символ разделителя (<span class="code-mini">_</span>) в числовых литералах.</li><li>Локальные переменные и возвращаемые значения по ссылке. Расширена функциональность ключевого слова <span class="code-mini">ref</span>. Теперь можно возвратить данные из метода или сохранить их в локальной переменной по ссылке.</li><li>Расширение списка типов, возвращаемых асинхронными методами</li><li>Больше членов класса в виде выражений. Синтаксис функций, сжатых до выражений (expression-bodied functions <span class="code-mini">expression-bidied functions</span>), теперь применим для сеттеров, геттеров, конструкторов и деструкторов.</li><li class="padding-hover"><span class="code-mini">throw</span>-выражения. Теперь можно использовать <span class="code-mini">throw</span> в функциях, сжатых до выражений (expression-bodied functions):<br/><div class="code-big-mini">public string GetLastName() <!-- -->=&gt;<!-- --> throw new NotImplementedException();</div></li></ul><br/><h3>Версия 8.0</h3><h4>Новые возможности в версии 8.0</h4><ul class="list"><li>Модификатор <span class="code-mini">readonly</span>. Был создан для обозначения члена, который не изменит состояние.</li><li>Методы интерфейсов по умолчанию. Теперь при создании метода интерфейса можно объявить его реализацию по умолчанию, которую можно переопределить в классе, который реализует этот интерфейс.</li><br/><br/><li class="padding-hover-big">Сопоставление шаблонов. Возможность позволяет работать с шаблонами в зависимости от формата в связанных, но различных типах данных.<br/><ul class="in-list"><li>Рекурсивные шаблоны. Является выражением шаблона, которое применяется к результатам другого выражения шаблона.</li><li class="padding-hover-big-big">Выражения switch позволяют сократить количество case и break, а также фигурных скобок.<br/><div class="code-big-mini-small">public enum Rainbow<br/>{<br/>        Red,<br/>        Orange,<br/>        Yellow,<br/>        Green,<br/>        Blue,<br/>        Indigo,<br/>        Violet<br/>}<br/><br/>public static RGBColor FromRainbow(Rainbow colorBand) <!-- -->=&gt;<br/>        colorBand switch<br/>        <!-- -->{<br/>                Rainbow.Red    <!-- -->=&gt;<!-- --> new RGBColor(0xFF, 0x00, 0x00),<br/>                Rainbow.Orange <!-- -->=&gt;<!-- --> new RGBColor(0xFF, 0x7F, 0x00),<br/>                Rainbow.Yellow <!-- -->=&gt;<!-- --> new RGBColor(0xFF, 0xFF, 0x00),<br/>                Rainbow.Green  <!-- -->=&gt;<!-- --> new RGBColor(0x00, 0xFF, 0x00),<br/>                Rainbow.Blue   <!-- -->=&gt;<!-- --> new RGBColor(0x00, 0x00, 0xFF),<br/>                Rainbow.Indigo <!-- -->=&gt;<!-- --> new RGBColor(0x4B, 0x00, 0x82),<br/>                Rainbow.Violet <!-- -->=&gt;<!-- --> new RGBColor(0x94, 0x00, 0xD3),<br/>                _              <!-- -->=&gt;<!-- --> throw new ArgumentException(message: &quot;invalid enum value&quot;, paramName: nameof(colorBand)),<br/>        <!-- -->}<!-- -->;</div><br/><br/></li><li>Шаблоны свойств. Позволяет сопоставлять свойства исследуемого объекта с помощью <span class="code-mini">{<!-- --> variable : value <!-- -->}<!-- --> <!-- -->=&gt;<!-- --> ... .</span></li><li>Шаблоны кортежей. Используется, если нужно работать с несколькими наборами входных данных. <span class="code-mini">(value1, value2,..) <!-- -->=&gt;<!-- --> ...</span></li></ul></li><li>Объявление <span class="code-mini">using</span>. Это объявление переменной, которому предшествует ключевое слово <span class="code-mini">using</span>. Оно сообщает компилятору, что объявляемая переменная должна быть удалена в конце области видимости.</li><li>Статический локальный метод. Теперь можно убедиться в том, что метод не охватывает какие-либо переменные из области видимости с помощью добавления к нему модификатора <span class="code-mini">static</span>.</li><li>Удаляемые ссылочные структуры. Ссылочные структуры не могут реализовать IDisposable (как и любые другие интерфейсы). Поэтому чтобы удалить <span class="code-mini">ref struct</span>, необходим доступный <span class="code-mini">void Dispose()</span>.</li><li>Типы значений, допускающие значение null. Теперь, чтобы указать, что переменная типа значений допускает значение <span class="code-mini">null</span>, необходимо поставить к имени типа <span class="code-mini">?</span></li><li class="padding-hover">Асинхронные потоки. Это во-первых интерфейс <span class="code-mini">IAsyncEnumerable<!-- -->&lt;T&gt;</span>.  А во-вторых конструкция <span class="code-mini">foreach</span> с <span class="code-mini">await</span>.<br/><br/><div class="code-big-mini-small">public static async System.Collections.Generic.IAsyncEnumerable<!-- -->&lt;int&gt;<!-- --> GenerateSequence()<br/>{<br/>        for (int i = 0; i <!-- -->&lt;<!-- --> 20; i++)<br/>        <!-- -->{<br/>                await Task.Delay(100);<br/>                yield return i;<br/>        <!-- -->}<br/>}<br/>// or<br/>await foreach (var number in GenerateSequence())<br/>{<br/>        Console.WriteLine(number);<br/>}</div></li><li>Асинхронные высвобождаемые типы. Начиная с C# 8.0 язык поддерживает асинхронные освобождаемые типы, реализующие интерфейс <span class="code-mini">System.IAsyncDisposable</span>. Операнд выражения <span class="code-mini">using</span> может реализовывать <span class="code-mini">IDisposable</span> или <span class="code-mini">IAsyncDisposable</span>. В случае <span class="code-mini">IAsyncDisposable</span> компилятор создает код для <span class="code-mini">await</span>, возвращенного <span class="code-mini">Task</span> из <span class="code-mini">IAsyncDisposable.DisposeAsync</span>.</li><li>Индексы и диапазоны. Диапазоны и индексы обеспечивают лаконичный синтаксис для доступа к отдельным элементам или диапазонам в последовательности. Нововведение включает в себя операторы <span class="code-mini">^</span> и <span class="code-mini">..</span> , а также <span class="code-mini">System.Index</span> и <span class="code-mini">System.Range</span></li><li class="padding-hover-big">Оператор присваивания объединения с <span class="code-mini">null</span>. Оператор <span class="code-mini">??=</span> можно использовать для присваивания значения правого операнда левому операнду только в том случае, если левый операнд имеет значение <span class="code-mini">null</span>.<br/><div class="code-big-mini">List<!-- -->&lt;int&gt;<!-- --> numbers = null;<br/>int? i = null;<br/><br/>numbers ??= new List<!-- -->&lt;int&gt;<!-- -->();<br/>numbers.Add(i ??= 17);<br/>numbers.Add(i ??= 20);<br/><br/>Console.WriteLine(string.Join(&quot; &quot;, numbers));<br/>Console.WriteLine(i);</div><br/><div class="prew-terminal"><nav><ul><li>Terminal</li><li class="new"><p>+</p></li></ul></nav><div class="terminal">17 17<br/>17</div></div></li><li>Неуправляемые сконструированные типы. Начиная с C# 8.0, сконструированный тип значения является неуправляемым, если он содержит поля исключительно неуправляемых типов (например универсальный тип <!-- -->&lt;T&gt;<!-- -->).</li><li class="padding-hover-big">Выражение stackalloc во вложенных выражениях. Теперь если результат выражения stackalloc имеет тип <span class="code-mini">System.Span&lt;T&gt;</span> или <span class="code-mini">System.ReadOnlySpan&lt;T&gt;</span>, то его можно использовать в других выражениях.<br/><div class="code-big-mini">Span<!-- -->&lt;int&gt;<!-- --> numbers = stackalloc[] <!-- -->{ 1, 2, 3, 4, 5, 6 }<!-- -->;<br/>var ind = numbers.IndexOfAny(stackalloc[] <!-- -->{ 2, 4, 6, 8 }<!-- -->);<br/>Console.WriteLine(ind);</div><br/><div class="prew-terminal"><nav><ul><li>Terminal</li><li class="new"><p>+</p></li></ul></nav><div class="terminal">1</div></div></li><li>Порядок маркеров <span class="code-mini">$</span> и <span class="code-mini">@</span> в интерполированных строках verbatim теперь может быть любым.</li></ul><br/><h3>Версия 9.0</h3><h4>Новые возможности в версии 9.0</h4><ul class="list"><li class="padding-hover-big">Типы записей. Появилась возможность при помощи ключевого слова <span class="code-mini">record</span> для определения ссылочного типа, предоставляющего функционал инкапсуляции данных.<div class="code-big-mini">public record User(string FirstName, string LastName);</div><br/>По умолчанию типы записей является неизменяемыми. В отличие от других ссылочных типов, переменные типов записей считаются равными, если равны типы и значения их свойств и полей.<br/><ul class="in-list"><li>Обратимые изменения. Для заданного экземпляра записи при помощи ключевого слова <span class="code-mini">with</span> возможно создание копии с изменёнными значениями указанных свойств и полей.</li><li>Запись может быть унаследована от записи. Однако запись не может быть унаследована от класса, и наоборот, класс не может быть унаследован от записи.</li></ul></li><li class="padding-hover-big">Инициализаторы. C# 9.0 предоставляет синтаксис — ключевое слово <span class="code-mini">init</span> — для задания значений свойств класса при инициализации.<br/><div class="code-big-mini">public class User<br/>{<br/>        public string FirstName <!-- -->{<!-- --> get; init; <!-- -->}<br/>        public string LastName <!-- -->{<!-- --> get; init; <!-- -->}<br/>}<!-- -->;</div></li><li>Операторы верхнего уровня. Один файл в приложении допускается начать сразу с исполняемых строк кода, минуя ряд таких формальностей, как объявление пространств имён, классов, методов. Такие операторы эквивалентны операторам метода <span class="code-mini">Main</span>.</li><li>Улучшения сопоставлений шаблонов.<br/><ul class="in-list"><li>Шаблоны типов — соответствуют объекту заданного типа.</li><li>Логические шаблоны — входные данные должны соответствовать заданной логической операции (<span class="code-mini">and</span>, <span class="code-mini">or</span>, <span class="code-mini">not</span>).</li><li>Реляционные шаблоны — входные данные должны соответствовать заданной операции сравнения (больше, меньше, равно, больше или равно, меньше или равно) с константой.</li></ul></li><li>Улучшения производительности. </li><li class="padding-hover">Допускается опустить тип создаваемого объекта в выражении <span class="code-mini">new</span>, если он известен заранее<br/><div class="code-big-mini">private List<!-- -->&lt;User&gt;<!-- --> persons = new();</div></li><li>Поддержка статических лямбда-выражений и статических анонимных методов. Как и статические локальные функции, они не могут захватывать нестатические локальные переменные и состояния экземпляра.</li><li>Поддержка применения атрибутов к локальным функциям.</li></ul><br/><h3>Версия 10.0</h3><h4>Новые возможности в версии 10.0</h4><ul class="list-code"><li>Глобальные импорты. С помощью ключевого слова <span class="code-mini">global</span> появилась возможность определить пространства имён, которые будут импортированы глобально во всех файлах проекта.<br/><div class="code-big-mini">global using System;<br/>global using System.Collections.Generic;</div></li><li>Файловая область видимости пространства имён. Объявление пространства имён может быть применено ко всему файлу, что уменьшает уровень отступов в коде.<br/><div class="code-big-mini">namespace MyNamespace;</div></li><li>Усовершенствованные структуры. Добавлены улучшения в работу со структурами, в том числе возможность инициализации полей непосредственно в теле структуры и поддержка параметров по умолчанию.<br/><div class="code-big-mini">public struct Point<br/>{<br/>        public int X <!-- -->{<!-- --> get; set; <!-- -->}<!-- --> = 0;<br/>        public int Y <!-- -->{<!-- --> get; set; <!-- -->}<!-- --> = 0;<br/>{</div></li><li>Запечатанные интерфейсы. Интерфейсы могут быть объявлены как <span class="code-mini">sealed</span>, что предотвращает их реализацию другими интерфейсами.<br/><div class="code-big-mini">public sealed interface IMyInterface <!-- -->{ }</div></li><li>Усовершенствованные операторы и литералы. Поддержка <span class="code-mini">with</span>-оператора для структурных типов, улучшенные string-интерполяции и другие синтаксические улучшения.</li><li>Улучшенное сопоставление шаблонов. Добавлены новые возможности для сопоставления шаблонов, включая шаблоны списков и возможность использования шаблонов в операторах <span class="code-mini">switch</span> и <span class="code-mini">if</span>.<br/><div class="code-big-mini">int[] numbers = <!-- -->{ 1, 2, 3, 4, 5 }<!-- -->;<br/>bool isThreeElementArray = numbers is [_, _, _];</div></li><li>Поддержка записи структуры и членов записи. Улучшена производительность при использовании структурных типов с поддержкой записи.<br/><div class="code-big-mini">public record struct Point(int X, int Y);</div></li><li>Усовершенствованные атрибуты. Возможность применения атрибутов к более широкому кругу элементов, таких как локальные функции и выражения.<br/><div class="code-big-mini">[MyCustom]<br/>void LocalFunction() <!-- -->{ }</div></li><li>Лямбда-выражения. Поддержка более мощных и гибких лямбда-выражений, включая использование типов возврата и деструктуризацию.<br/><div class="code-big-mini">var increment = (int x) <!-- -->=&gt;<!-- --> x + 1;</div></li><li>Усовершенствованные <span class="code-mini">async/await</span>. Улучшена работа с асинхронными методами, включая более эффективное управление памятью и потоками.</li></ul><br/><h3>Версия 11.0</h3><h4>Новые возможности в версии 11.0</h4><ul class="list-code"><li>Статические виртуальные элементы в интерфейсах. Интерфейсы теперь могут включать статические виртуальные и абстрактные члены, что позволяет перегружать операторы и определять статические свойства и методы. Это упрощает реализацию универсальных математических операций.<br/><div class="code-big-mini">public interface IMyInterface<!-- -->&lt;<!-- -->TSelf, TOther, TResult<!-- -->&gt;<br/>        where TSelf : IMyInterface<!-- -->&lt;<!-- -->TSelf, TOther, TResult<!-- -->&gt;<br/>{<br/>        static abstract TResult operator +(TSelf left, TOther right);<br/>}</div></li><li>Проверяемые и непроверяемые операторы. Разработчики могут определять <span class="code-mini">checked</span> и <span class="code-mini">unchecked</span> арифметические операторы, что позволяет компилятору вызывать правильный вариант на основе контекста.<br/><div class="code-big-mini">public static checked int operator +(MyType left, MyType right)<br/>{<br/>        left.Value + right.Value;<br/>}</div></li><li>Оператор unsigned right-shift. Введен новый оператор <span class="code-mini">&gt;&gt;&gt;</span>, который выполняет сдвиг вправо без знака, упрощая работу с целочисленными типами.<br/><div class="code-big-mini">int result = -8 <!-- -->&gt;&gt;&gt;<!-- --> 2;</div></li><li>Ослабленные требования к операторам смены. Второй операнд оператора сдвига больше не обязан быть типа <span class="code-mini">int</span>, что делает использование универсальных математических интерфейсов более гибким.<br/><div class="code-big-mini">MyType value = new MyType();<br/>value <!-- -->&gt;&gt;=<!-- --> 3;</div></li><li>Поддержка универсальной математики. Новые интерфейсы, такие как <span class="code-mini">System.IAdditionOperators&lt;TSelf, TOther, TResult&gt;</span>, позволяют типам реализовывать математические операции более последовательно и удобно.<br/><div class="code-big-mini">public struct MyNumber : <!-- -->IAdditionOperators&lt;MyNumber, MyNumber, MyNumber&gt;<br/>{<br/>        public static MyNumber operator +(MyNumber left, MyNumber right)<br/>        <!-- -->{<br/>        new MyNumber(left.Value + right.Value);<br/>        <!-- -->}<br/>}</div></li><li>Расширенные возможности инициализации типов. Теперь можно задавать значения полей прямо в теле структуры и использовать параметры по умолчанию.<br/><div class="code-big-mini">public struct Point<br/>{<br/>        public int X <!-- -->{<!-- --> get; set; <!-- -->}<!-- --> = 0;<br/>        public int Y <!-- -->{<!-- --> get; set; <!-- -->}<!-- --> = 0;<br/>}</div></li></ul><br/><h3>Версия 12.0</h3><h4>Новые возможности в версии 12.0[</h4><ul class="list-code"><li>Статические абстрактные и виртуальные методы в интерфейсах. Интерфейсы теперь могут содержать статические абстрактные и виртуальные методы, что позволяет определять поведение для универсальных математических операций.<br/><div class="code-big-mini">public interface <!-- -->IMyInterface&lt;TSelf, TOther, TResult&gt;<br/>        where TSelf : <!-- -->IMyInterface&lt;TSelf, TOther, TResult&gt;<!-- --> <br/>{<!-- --> <br/>        static abstract TResult operator +(TSelf left, TOther right);<br/>        static virtual TResult Add(TSelf left, TOther right)<br/>        <!-- -->{<br/>                return left + right;<br/>        <!-- -->}<br/>}</div></li><li>Поддержка коллекций с неизменяемыми элементами. Введена новая коллекция <span class="code-mini">ImmutableArray</span>, которая обеспечивает неизменяемость элементов и повышение производительности.<br/><div class="code-big-mini">var immutableArray = ImmutableArray.Create(1, 2, 3, 4);</div></li><li>Улучшенные структуры данных. В C# 12 введены новые типы данных, такие как <span class="code-mini">readonly struct</span> и <span class="code-mini">ref readonly struct</span>, для оптимизации работы с памятью.<br/><div class="code-big-mini">public readonly struct Point<br/>{<br/>        public int X <!-- -->{<!-- --> get; <!-- -->}<br/>        public int Y <!-- -->{<!-- --> get; <!-- -->}<br/><br/>        public Point(int x, int y)<br/>        <!-- -->{<br/>                X = x;<br/>                Y = y;<br/>        <!-- -->{<br/>}</div></li><li>Расширенные возможности для типов записи. Теперь записи поддерживают наследование и могут содержать методы с телами.<br/><div class="code-big-mini">public record Person(string Name)<br/>{<br/>        public virtual string GetName() <!-- -->=&gt;<!-- --> Name;<br/>}<br/><br/>public record Employee(string Name, int EmployeeId) : Person(Name)<br/>{<br/>        public override string GetName() <!-- -->=&gt;<!-- --> $&quot;<!-- -->{<!-- -->Name<!-- -->}<!-- --> (ID: <!-- -->{<!-- -->EmployeeId<!-- -->}<!-- -->)&quot;;<br/>{</div></li><li>Поддержка типов с произвольным количеством параметров. Введены новые методы для работы с переменным числом параметров, упрощая использование таких типов в коде.<br/><div class="code-big-mini">public void PrintValues(params int[] values)<br/>{<br/>        foreach (var value in values)<br/>        <!-- -->{<br/>                Console.WriteLine(value);<br/>        <!-- -->}<br/>}<br/><br/>PrintValues(1, 2, 3, 4);</div></li><li>Расширенные возможности компилятора. В C# 12 компилятор получил новые возможности для оптимизации и проверки кода, включая улучшенную поддержку анализаторов и генераторов исходного кода.</li></ul><br/><br/><h2>Пример «Hello, World!»</h2><p>Ниже представлен код классической программы «Hello world» на C# для консольного приложения:<br/></p><div class="code">Console.WriteLine(&quot;Hello World!&quot;);</div><br/><p>и код этой же программы для приложения Windows Forms:<br/></p><div class="code">namespace WindowsForms;<br/><br/>public class Program <br/>{<br/>        [STAThread]<br/>        public static void Main() <!-- -->=&gt;<!-- --> new DemoForm().ShowDialog();<br/>}<br/><br/>public class DemoForm : Form<br/>{<br/>        Label label = new Label();<br/><br/>        public DemoForm()<br/>        <!-- -->{<br/>                label.Text = &quot;Hello World!&quot;;<br/>                this.Controls.Add(label);<br/>                this.StartPosition = FormStartPosition.CenterScreen;<br/>                this.BackColor = Color.White;<br/>                this.FormBorderStyle = FormBorderStyle.Fixed3D;<br/>        <!-- -->}<br/>}</div><br/><br/><h2>Реализации</h2><p>Существует несколько реализаций C#:</p><ul class="list"><li>Компилятор Roslyn c открытым <a href="https://github.com/dotnet/roslyn" class="link-other">исходным кодом</a></li><li>Реализация C# в виде компилятора csc.exe включена в состав .NET Framework (включая .NET Micro Framework, .NET Compact Framework и его реализации под Silverlight и Windows Phone 7).</li><li>В составе проекта Rotor (Shared Source Common Language Infrastructure) компании Microsoft.</li><li>Проект Mono включает в себя реализацию C# с открытым исходным кодом.</li><li>Проект DotGNU также включает компилятор C# с открытым кодом.</li><li>DotNetAnywhere — ориентированная на встраиваемые системы реализация CLR, поддерживает практически всю спецификацию C# 2.0.</li></ul></div></div><button class="back-to-top "><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 320 512" color="white" style="color:white" height="30" width="30" xmlns="http://www.w3.org/2000/svg"><path d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"></path></svg></button></div></div><footer><hr/><div class="container"><span class="footer-text">Спасибо за чтениe</span><button class="btn-telgram"><a href="https://t.me/it_reviews_other">Зайди к нам</a></button></div></footer><script src="/_next/static/chunks/webpack-91ddf6d7f343849d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[8173,[\"173\",\"static/chunks/173-adb53e817c3964da.js\",\"970\",\"static/chunks/970-fdca2819562abdd0.js\",\"237\",\"static/chunks/app/pages/posts/CSharp/page-7d785bd99510dee4.js\"],\"\"]\n3:I[5244,[],\"\"]\n4:I[3866,[],\"\"]\n5:I[1700,[\"711\",\"static/chunks/8e1d74a4-d5fa8b652382e494.js\",\"173\",\"static/chunks/173-adb53e817c3964da.js\",\"177\",\"static/chunks/app/layout-8dc7d88f1573f6b1.js\"],\"default\"]\n6:I[7970,[\"173\",\"static/chunks/173-adb53e817c3964da.js\",\"970\",\"static/chunks/970-fdca2819562abdd0.js\",\"237\",\"static/chunks/app/pages/posts/CSharp/page-7d785bd99510dee4.js\"],\"Image\"]\n7:I[6213,[],\"OutletBoundary\"]\n9:I[6213,[],\"MetadataBoundary\"]\nb:I[6213,[],\"ViewportBoundary\"]\nd:I[4835,[],\"\"]\n:HL[\"/_next/static/css/1633334b8bd4f972.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"2bG9-Hdm14uF9As9GrKRC\",\"p\":\"\",\"c\":[\"\",\"pages\",\"posts\",\"CSharp\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"pages\",{\"children\":[\"posts\",{\"children\":[\"CSharp\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/1633334b8bd4f972.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_b962f2\",\"children\":[[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"header\",null,{\"children\":[[\"$\",\"h1\",null,{\"children\":\"Все о Программировании\"}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"children\":\"Главная\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"$L2\",null,{\"href\":\"/pages/post\",\"children\":\"Статьи\"}]}],[\"$\",\"li\",null,{\"className\":\"search\",\"children\":[\"$\",\"$L2\",null,{\"href\":\"/pages/search\",\"children\":[\"$\",\"svg\",null,{\"stroke\":\"currentColor\",\"fill\":\"currentColor\",\"strokeWidth\":\"0\",\"viewBox\":\"0 0 512 512\",\"color\":\"white\",\"children\":[\"$undefined\",[[\"$\",\"path\",\"0\",{\"d\":\"M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z\",\"children\":[]}]]],\"className\":\"$undefined\",\"style\":{\"color\":\"white\"},\"height\":20,\"width\":20,\"xmlns\":\"http://www.w3.org/2000/svg\"}]}]}],[\"$\",\"li\",null,{\"className\":\"btn\",\"children\":[\"$\",\"$L2\",null,{\"href\":\"https://t.me/it_reviews_other\",\"children\":\"Зайди к нам\"}]}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"page\",\"children\":[[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L5\",null,{}]]}]]}],[\"$\",\"footer\",null,{\"children\":[[\"$\",\"hr\",null,{}],[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"span\",null,{\"className\":\"footer-text\",\"children\":\"Спасибо за чтениe\"}],[\"$\",\"button\",null,{\"className\":\"btn-telgram\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://t.me/it_reviews_other\",\"children\":\"Зайди к нам\"}]}]]}]]}]]}]}]]}],{\"children\":[\"pages\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"pages\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"posts\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"pages\",\"children\",\"posts\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"CSharp\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"pages\",\"children\",\"posts\",\"children\",\"CSharp\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"div\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"cover\",\"children\":[[\"$\",\"h3\",null,{\"children\":\"Все о Программировании\"}],[\"$\",\"h1\",null,{\"children\":\"C#| Си Шарп\"}],[\"$\",\"$L2\",null,{\"href\":\"https://t.me/it_reviews_other\",\"children\":[\"$\",\"$L6\",null,{\"src\":\"/allIt.jpg\",\"width\":100,\"height\":100,\"alt\":\"cover\"}]}],[\"$\",\"div\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"text\",\"children\":[[\"$\",\"q\",null,{\"children\":[\"C# (произносится си шарп) — объектно-ориентированный язык программирования общего назначения. Разработан в 1998—2001 годах группой инженеров компании Microsoft под руководством Андерса Хейлсберга и Скотта Вильтаумота как язык разработки приложений для платформы Microsoft .NET Framework и .NET Core. Впоследствии был стандартизирован как ECMA-334 и ISO/IEC 23270.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"C# относится к семье языков с C-подобным синтаксисом, из них его синтаксис наиболее близок к C++ и Java. Язык имеет статическую типизацию, поддерживает полиморфизм, перегрузку операторов (в том числе операторов явного и неявного приведения типа), делегаты, атрибуты, события, переменные, свойства, обобщённые типы и методы, итераторы, анонимные функции с поддержкой замыканий, LINQ, исключения, комментарии в формате XML.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Переняв многое от своих предшественников — языков C++, Delphi, Модула, Smalltalk и, в особенности, Java — С#, опираясь на практику их использования, исключает некоторые модели, зарекомендовавшие себя как проблематичные при разработке программных систем, например, C# в отличие от C++ не поддерживает множественное наследование классов (между тем допускается множественная реализация интерфейсов).\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Особенности языка\"}],[\"$\",\"p\",null,{\"children\":\"С# разрабатывался как язык программирования прикладного уровня для CLR и, как таковой, зависит, прежде всего, от возможностей самой CLR. Это касается, прежде всего, системы типов С#, которая отражает BCL. Присутствие или отсутствие тех или иных выразительных особенностей языка диктуется тем, может ли конкретная языковая особенность быть транслирована в соответствующие конструкции CLR. Так, с развитием CLR от версии 1.1 к 2.0 значительно обогатился и сам C#; подобного взаимодействия следует ожидать и в дальнейшем (однако, эта закономерность была нарушена с выходом C# 3.0, представляющего собой расширения языка, не опирающиеся на расширения платформы .NET). CLR предоставляет С#, как и всем другим .NET-ориентированным языкам, многие возможности, которых лишены «классические» языки программирования. Например, сборка мусора не реализована в самом C#, а производится CLR для программ, написанных на C#, точно так же, как это делается для программ на VB.NET, J# и др.\"}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Название языка\"}],[\"$\",\"p\",null,{\"children\":[\"Название «Си шарп» (от англ. sharp — диез) происходит от буквенной музыкальной нотации, где латинской букве C соответствует нота До, а знак диез (англ. sharp) означает повышение соответствующего ноте звука на полутон, что аналогично названию языка C++, где «++» обозначает инкремент переменной. Название также является игрой с цепочкой C → C++ → C++++(C#), так как символ «#» можно представить состоящим из 4 знаков «+».\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Из-за технических ограничений на отображение (стандартные шрифты, браузеры и т. д.), а также из-за того, что знак диеза ♯ не представлен на стандартной клавиатуре компьютера, при записи имени языка программирования используют знак решётки (#). Это соглашение отражено в Спецификации языка C# ECMA-334. Тем не менее, на практике (например, при размещении рекламы и коробочном дизайне), «Майкрософт» использует знак диеза.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Названия языков программирования не принято переводить, поэтому язык называют, используя транскрипцию, — «Си шарп».\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Стандартизация\"}],[\"$\",\"p\",null,{\"children\":[\"C# стандартизирован в ECMA (ECMA-334) и ISO (ISO/IEC 23270).\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Известно как минимум о трёх независимых реализациях C#, базирующихся на этой спецификации и находящихся в настоящее время на различных стадиях разработки:\"]}],[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"Mono, начата компанией Ximian, продолжена её покупателем и преемником Novell, а затем Xamarin.\"}],[\"$\",\"li\",null,{\"children\":\"dotGNU и Portable.NET, разрабатываемые Free Software Foundation.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Версии\"}],[\"$\",\"table\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"Версия\"}],[\"$\",\"th\",null,{\"children\":\"Дата выхода\"}],[\"$\",\"th\",null,{\"children\":\"Совместимые версии .NET\"}],[\"$\",\"th\",null,{\"children\":\"Совместимая версия Visual Studio\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 1.0\"}],[\"$\",\"td\",null,{\"children\":\"Январь 2002\"}],[\"$\",\"td\",null,{\"children\":\".NET Framework 1.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio .NET (2002)\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":[\"C# 1.1\",[\"$\",\"br\",null,{}],\"C# 1.2\"]}],[\"$\",\"td\",null,{\"children\":\"Апрель 2003\"}],[\"$\",\"td\",null,{\"children\":\".NET Framework 1.1\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio .NET 2003\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 2.0\"}],[\"$\",\"td\",null,{\"children\":\"Ноябрь 2005\"}],[\"$\",\"td\",null,{\"children\":[\".NET Framework 2.0\",[\"$\",\"br\",null,{}],\".NET Framework 3.0\"]}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2005\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 3.0\"}],[\"$\",\"td\",null,{\"children\":\"Ноябрь 2007\"}],[\"$\",\"td\",null,{\"children\":[\".NET Framework 2.0 (кроме LINQ)\",[\"$\",\"br\",null,{}],\".NET Framework 3.0 (кроме LINQ)\",[\"$\",\"br\",null,{}],\".NET Framework 3.5\"]}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2008\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 4.0\"}],[\"$\",\"td\",null,{\"children\":\"Апрель 2010\"}],[\"$\",\"td\",null,{\"children\":\".NET Framework 4.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2010\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 5.0\"}],[\"$\",\"td\",null,{\"children\":\"Август 2012\"}],[\"$\",\"td\",null,{\"children\":\".NET Framework 4.5\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2012\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 6.0\"}],[\"$\",\"td\",null,{\"children\":\"Июль 2015\"}],[\"$\",\"td\",null,{\"children\":[\".NET Framework 4.6\",[\"$\",\"br\",null,{}],\".NET Core 1.0\",[\"$\",\"br\",null,{}],\".NET Core 1.1\"]}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2015\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 7.0\"}],[\"$\",\"td\",null,{\"children\":\"Март 2017\"}],[\"$\",\"td\",null,{\"children\":[\".NET Framework 4.6.2\",[\"$\",\"br\",null,{}],\".NET Framework 4.7\"]}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2017 15.0\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 7.1\"}],[\"$\",\"td\",null,{\"children\":\"Август 2017\"}],[\"$\",\"td\",null,{\"children\":\".NET Core 2.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2017 15.3\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 7.2\"}],[\"$\",\"td\",null,{\"children\":\"Ноябрь 2017\"}],[\"$\",\"td\",null,{\"children\":\"Нету\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2017 15.5\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 7.3\"}],[\"$\",\"td\",null,{\"children\":\"Май 2018\"}],[\"$\",\"td\",null,{\"children\":[\".NET Core 2.1\",[\"$\",\"br\",null,{}],\".NET Core 2.2.\",[\"$\",\"br\",null,{}],\".NET Framework 4.8\"]}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2017 15.7\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 8.0\"}],[\"$\",\"td\",null,{\"children\":\"Сентябрь 2019\"}],[\"$\",\"td\",null,{\"children\":[\".NET Core 3.0\",[\"$\",\"br\",null,{}],\".NET Core 3.1\",[\"$\",\"br\",null,{}],\".NET Framework 4.8\"]}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2019 16.3\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 9.0\"}],[\"$\",\"td\",null,{\"children\":\"Сентябрь 2020\"}],[\"$\",\"td\",null,{\"children\":\".NET 5.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2019 16.8\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 10.0\"}],[\"$\",\"td\",null,{\"children\":\"Июль 2021\"}],[\"$\",\"td\",null,{\"children\":\".NET 6.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2022 17.0\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 11.0\"}],[\"$\",\"td\",null,{\"children\":\"Ноябрь 2022\"}],[\"$\",\"td\",null,{\"children\":\".NET 7.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2022 17.4\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 12.0\"}],[\"$\",\"td\",null,{\"children\":\"Ноябрь 2023\"}],[\"$\",\"td\",null,{\"children\":\".NET 8.0\"}],[\"$\",\"td\",null,{\"children\":\"Visual Studio 2022 17.8\"}]]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h5\",null,{\"children\":\"Общая информация по версиям\"}],[\"$\",\"table\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"Версия\"}],[\"$\",\"th\",null,{\"children\":\"Нововведения\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 2.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Частичные типы\"}],[\"$\",\"li\",null,{\"children\":\"Обобщённые типы (generics)\"}],[\"$\",\"li\",null,{\"children\":[\"Итераторы и ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"yield\"}]]}],[\"$\",\"li\",null,{\"children\":\"Анонимные методы\"}],[\"$\",\"li\",null,{\"children\":\"Оператор null-объединения\"}],[\"$\",\"li\",null,{\"children\":\"Nullable-типы\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 3.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Запросы, интегрированные в язык (LINQ)\"}],[\"$\",\"li\",null,{\"children\":\"Инициализаторы объектов и коллекций\"}],[\"$\",\"li\",null,{\"children\":\"Лямбда-выражения\"}],[\"$\",\"li\",null,{\"children\":\"Деревья выражений\"}],[\"$\",\"li\",null,{\"children\":[\"Неявная типизация и ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"var\"}]]}],[\"$\",\"li\",null,{\"children\":\"Анонимные типы\"}],[\"$\",\"li\",null,{\"children\":\"Методы расширения\"}],[\"$\",\"li\",null,{\"children\":\"Автоматические свойства\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 4.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Динамическое связывание и ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"dynamic\"}]]}],[\"$\",\"li\",null,{\"children\":\"Именованные и опциональные аргументы\"}],[\"$\",\"li\",null,{\"children\":\"Обобщенная ковариантность и контрвариантность\"}],[\"$\",\"li\",null,{\"children\":[\"Библиотека TPL, концепция задач и классы \",[\"$\",\"span\",null,{\"className\":\"code-mni\",\"children\":\"Task\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mni\",\"children\":\"Parallel\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Класс \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"MemoryCache\"}]]}],[\"$\",\"li\",null,{\"children\":\"Классы параллельных коллекций\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 5.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Шаблон TAP\"}],[\"$\",\"li\",null,{\"children\":[\"Асинхронные методы \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"async\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"await\"}]]}],[\"$\",\"li\",null,{\"children\":\"Сведения о вызывающем объекте\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 6.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Компилятор как сервис\"}],[\"$\",\"li\",null,{\"children\":\"Импорт членов статических типов в пространство имён\"}],[\"$\",\"li\",null,{\"children\":\"Фильтры исключений\"}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"await\"}],\" в блоках \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"catch\"}],\"/\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"finally\"}]]}],[\"$\",\"li\",null,{\"children\":\"Инициализаторы автосвойств\"}],[\"$\",\"li\",null,{\"children\":\"Автосвойства только для чтения\"}],[\"$\",\"li\",null,{\"children\":[\"null-условные операции (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"?.\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"?[])\"}]]}],[\"$\",\"li\",null,{\"children\":\"Интерполяция строк\"}],[\"$\",\"li\",null,{\"children\":[\"Оператор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"nameof\"}]]}],[\"$\",\"li\",null,{\"children\":\"Инициализатор словаря\"}],[\"$\",\"li\",null,{\"children\":\"Функции сжатые до выражений\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 7.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"out\"}],\"-переменные\"]}],[\"$\",\"li\",null,{\"children\":\"Сопоставление с шаблоном\"}],[\"$\",\"li\",null,{\"children\":[\"Шаблоны с \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"is\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Шаблоны и выражение \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"switch\"}]]}],[\"$\",\"li\",null,{\"children\":\"Кортежи\"}],[\"$\",\"li\",null,{\"children\":\"Распаковка кортежей (деконструкторы)\"}],[\"$\",\"li\",null,{\"children\":\"Локальные функции\"}],[\"$\",\"li\",null,{\"children\":\"Улучшения литералов\"}],[\"$\",\"li\",null,{\"children\":\"Локальные переменные и возвращаемые значения по ссылке\"}],[\"$\",\"li\",null,{\"children\":\"Расширение списка типов, возвращаемых асинхронными методами\"}],[\"$\",\"li\",null,{\"children\":\"Больше членов класса в виде выражений\"}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"throw\"}],\" выражения\"]}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 8.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Члены только для чтения\"}],[\"$\",\"li\",null,{\"children\":\"Члены интерфейса по умолчанию\"}],[\"$\",\"li\",null,{\"children\":\"Улучшения сопоставления шаблонов\"}],[\"$\",\"li\",null,{\"children\":\"Объявления using\"}],[\"$\",\"li\",null,{\"children\":\"Статические локальные функции\"}],[\"$\",\"li\",null,{\"children\":\"Удаляемые ссылочные структуры\"}],[\"$\",\"li\",null,{\"children\":\"Ссылочные типы, допускающие значение NULL\"}],[\"$\",\"li\",null,{\"children\":\"Асинхронные потоки\"}],[\"$\",\"li\",null,{\"children\":\"Индексы и диапазоны\"}],[\"$\",\"li\",null,{\"children\":\"Присваивание объединения со значением NULL\"}],[\"$\",\"li\",null,{\"children\":\"Неуправляемые сконструированные типы\"}],[\"$\",\"li\",null,{\"children\":\"Выражения stackalloc во вложенных выражениях\"}],[\"$\",\"li\",null,{\"children\":\"Больше членов класса в виде выражений\"}],[\"$\",\"li\",null,{\"children\":\"Улучшения интерполированных строк\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 9.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Оператор объединения с null (??)\"}],[\"$\",\"li\",null,{\"children\":\"Пустые параметры для лямбда-выражений\"}],[\"$\",\"li\",null,{\"children\":\"Native Int: nint, nuint\"}],[\"$\",\"li\",null,{\"children\":\"Дизъюнктное объединение\"}],[\"$\",\"li\",null,{\"children\":[\"Добавлено \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"with\"}],\"-выражения\"]}],[\"$\",\"li\",null,{\"children\":[\"новый модификатор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"initonly\"}]]}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 10.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Добавление \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"role=\\\"alert\\\"\"}],\" атрибуты сообщений\"]}],[\"$\",\"li\",null,{\"children\":[\"Обновления \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Counter\"}],\" компонент для добавления \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"role=\\\"status\\\"\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Замена ul в \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"NavBar\"}],\" компонент для \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"nav\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Новое название кнопки переключения \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"NavBar\"}]]}],[\"$\",\"li\",null,{\"children\":\"Переход к использованию более семантической разметки\"}]]}]}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"C# 11.0\"}],[\"$\",\"td\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Необработанные строковые литералы\"}],[\"$\",\"li\",null,{\"children\":\"Поддержка универсальной математики\"}],[\"$\",\"li\",null,{\"children\":\"Универсальные атрибуты\"}],[\"$\",\"li\",null,{\"children\":\"Строковые литералы UTF-8\"}],[\"$\",\"li\",null,{\"children\":\"Новые строки в выражениях интерполяции строк\"}],[\"$\",\"li\",null,{\"children\":\"Шаблоны списка\"}],[\"$\",\"li\",null,{\"children\":\"Локальные типы файлов\"}],[\"$\",\"li\",null,{\"children\":\"Обязательные элементы\"}],[\"$\",\"li\",null,{\"children\":\"Автоматические структуры по умолчанию\"}],[\"$\",\"li\",null,{\"children\":[\"Сопоставление \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":[\"Span\",\"\u003cchar\u003e\"]}],\" шаблонов для константы string\"]}],[\"$\",\"li\",null,{\"children\":[\"Расширенные \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"nameof\"}],\" область\"]}],[\"$\",\"li\",null,{\"children\":[\"Числовой \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"intPtr\"}]]}],[\"$\",\"li\",null,{\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"ref\"}],\" поля и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"scoped ref\"}]]}],[\"$\",\"li\",null,{\"children\":\"Улучшенное преобразование групп методов для делегирования.\"}]]}]}]]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 1.0\"}],[\"$\",\"p\",null,{\"children\":[\"Проект C# был начат в декабре 1998 и получил кодовое название COOL (C-style Object Oriented Language). Версия 1.0 была анонсирована вместе с платформой .NET в июне 2000 года, тогда же появилась и первая общедоступная бета-версия; C# 1.0 окончательно вышел вместе с Microsoft Visual Studio .NET в феврале 2002 года.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Первая версия C# напоминала по своим возможностям Java 1.4, несколько их расширяя: так, в C# имелись свойства (выглядящие в коде как поля объекта, но на деле вызывающие при обращении к ним методы класса), индексаторы (подобные свойствам, но принимающие параметр как индекс массива), события, делегаты, циклы \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"foreach\"}],\", структуры, передаваемые по значению, автоматическое преобразование встроенных типов в объекты при необходимости (boxing), атрибуты, встроенные средства взаимодействия с неуправляемым кодом (DLL, COM) и прочее.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Кроме того, в C# решено было перенести некоторые возможности C++, отсутствовавшие в Java: беззнаковые типы, перегрузку операторов (с некоторыми ограничениями, в отличие от C++), передача параметров в метод по ссылке, методы с переменным числом параметров, оператор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"goto\"}],\" (с ограничениями). Также в C# оставили ограниченную возможность работы с указателями — в местах кода, специально обозначенных словом \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"unsafe\"}],\" и при указании специальной опции компилятору.\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 2.0\"}],[\"$\",\"p\",null,{\"children\":\"Проект спецификации C# 2.0 впервые был опубликован Microsoft в октябре 2003 года; в 2004 году выходили бета-версии (проект с кодовым названием Whidbey), C# 2.0 окончательно вышел 7 ноября 2005 года вместе с Visual Studio 2005 и .NET 2.0.\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 2.0\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Частичные типы (разделение реализации класса более чем на один файл).\"}],[\"$\",\"li\",null,{\"children\":\"Обобщённые, или параметризованные типы (generics). В отличие от шаблонов C++, они поддерживают некоторые дополнительные возможности и работают на уровне виртуальной машины. Вместе с тем, параметрами обобщённого типа не могут быть выражения, они не могут быть полностью или частично специализированы, не поддерживают шаблонных параметров по умолчанию, от шаблонного параметра нельзя наследоваться, и т. д.\"}],[\"$\",\"li\",null,{\"children\":[\"Новая форма итератора, позволяющая создавать сопрограммы с помощью ключевого слова \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"yeild\"}],\", подобно Python и Ruby.\"]}],[\"$\",\"li\",null,{\"children\":\"Анонимные методы, обеспечивающие функциональность замыкания.\"}],[\"$\",\"li\",null,{\"children\":[\"Оператор null-объединения: \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"'??': return obj1 ?? obj2;\"}],\" означает (в нотации C# 1.0) \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"return obj1!=null ? obj1 : obj2;\"}],\".\"]}],[\"$\",\"li\",null,{\"children\":[\"Обнуляемые (nullable) типы — значения (обозначаемые вопросительным знаком, например, \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"int? i = null;\"}],\"), представляющие собой те же самые типы-значения, способные принимать также значение \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"null\"}],\". Такие типы позволяют улучшить взаимодействие с базами данных через язык SQL.\"]}],[\"$\",\"li\",null,{\"children\":\"Поддержка 64-разрядных вычислений, что кроме всего прочего, позволяет увеличить адресное пространство и использовать 64-разрядные примитивные типы данных.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 3.0\"}],[\"$\",\"p\",null,{\"children\":\"В июне 2004 года Андерс Хейлсберг впервые рассказал на сайте Microsoft о планируемых расширениях языка в C#3.0. В сентябре 2005 года вышли проект спецификации C# 3.0 и бета-версия C# 3.0, устанавливаемая в виде дополнения к существующим Visual Studio 2005 и .NET 2.0. Окончательно эта версия языка вошла в Visual Studio 2008 и .NET 3.5.\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 3.0\"}],[\"$\",\"p\",null,{\"children\":\"В C# 3.0 появились следующие радикальные добавления к языку:\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"ключевые слова \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"select, from, where\"}],\", позволяющие делать запросы из XML документов, коллекций и т. п. Эти запросы имеют сходство с запросами SQL и реализуются компонентом LINQ. (Сама фраза «language integrated query» переводится «запрос, интегрированный в язык».)\"]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Инициализация объекта вместе с его свойствами:\",[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"Customer c = new Customer();\",[\"$\",\"br\",null,{}],\"c.Name = \\\"James\\\"; c.Age=30;\"]}],\"можно записать как\",[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"Customer c = new Customer \",\"{ Name = \\\"James\\\", Age = 30 }\",\";\"]}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Лямбда-выражения:\",[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"listOfFoo.Where(delegate(Foo x) \",\"{ return x.size \u003e 10; }\",\");\"]}],\"теперь можно записать как\",[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"listOfFoo.Where(x \",\"=\u003e\",\" x.size \",\"\u003e\",\" 10);\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Деревья выражений:\",[\"$\",\"br\",null,{}],\"лямбда-выражения теперь могут представляться в виде структуры данных, доступной для обхода во время выполнения, тем самым позволяя транслировать строго типизированные C#-выражения в другие домены (например, выражения SQL).\"]}],[\"$\",\"li\",null,{\"children\":[\"Неявная типизация: Вывод типов локальной переменной. Для неявной типизации вместо названия типа данных используется ключевое слово var. Затем уже при компиляции компилятор сам выводит тип данных исходя из присвоенного значения: \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"var x = \\\"hello\\\";\"}],\" вместо \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"string x = \\\"hello\\\";\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Анонимные типы: \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":[\"var x = new \",\"{ Name = \\\"Muhammad\\\" }\",\";\"]}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Методы расширения. Появилась возможность добавления новых методов в уже существующие классы. Реализуется с помощью ключевого слова this при первом параметре статической функции статического класса.\",[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"public static class StringExtensions\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public static int ToInt32(this string val)\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                return Int32.Parse(val);\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],\"// ...\",[\"$\",\"br\",null,{}],\"string s = \\\"10\\\";\",[\"$\",\"br\",null,{}],\"int x = s.ToInt32();\"]}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Автоматические свойства: компилятор сгенерирует закрытое (private) поле и соответствующие аксессор и мутатор для кода вида\",[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public string Name \",\"{ get; private set; }\"]}]]}]]}],[\"$\",\"p\",null,{\"children\":[\"C# 3.0 совместим с C# 2.0 по генерируемому MSIL-коду; улучшения в языке — чисто синтаксические и реализуются на этапе компиляции. Например, многие из интегрированных запросов LINQ можно осуществить, используя безымянные делегаты в сочетании с предикатными методами над контейнерами наподобие \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"List.FindAll\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"List.RemoveAll\"}],\".\"]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 4.0\"}],[\"$\",\"p\",null,{\"children\":[\"Превью C# 4.0 было представлено в конце 2008 года, вместе с CTP-версией Visual Studio 2010.\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Visual Basic 10.0 и C# 4.0 были выпущены в апреле 2010 года, одновременно с выпуском Visual Studio 2010.\"]}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 4.0\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Возможность использования позднего связывания, для использования:\",[\"$\",\"ul\",null,{\"className\":\"in-list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"с языками с динамической типизацией (\",[\"$\",\"a\",null,{\"href\":\"../Python\",\"children\":\"Python\"}],\", \",[\"$\",\"a\",null,{\"href\":\"../Ruby\",\"children\":\"Ruby\"}],\")\"]}],[\"$\",\"li\",null,{\"children\":\"с COM-объектами\"}],[\"$\",\"li\",null,{\"children\":\"отражения (reflection)\"}],[\"$\",\"li\",null,{\"children\":[\"объектов с изменяемой структурой (DOM). Появляется ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"dynamic\"}],\".\"]}]]}]]}],[\"$\",\"li\",null,{\"children\":\"Именованные и опциональные параметры\"}],[\"$\",\"li\",null,{\"children\":\"Новые возможности COM interop\"}],[\"$\",\"li\",null,{\"children\":\"Ковариантность и контравариантность обобщенных интерфейсов и делегатов\"}],[\"$\",\"li\",null,{\"children\":\"Контракты в коде (Code Contracts)\"}],[\"$\",\"li\",null,{\"children\":[\"Библиотека параллельных задач TPL (Task Parallel Library), концепция задач и классы \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Task\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"TaskFactory\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Parallel\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Добавлен класс \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"MemoryCache\"}],\", который предназначен для кэширования контента. Он похож на класс \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Cache\"}],\" ASP.NET, но его можно использовать при написании веб- / графических / консольных приложений.\"]}],[\"$\",\"li\",null,{\"children\":\"Добавлено пространство имен System.Collections.Concurrent и новые классы параллельных коллекций (ConcurrentQueue, ConcurrentStack, ConcurrentBag,…), которые предоставляют не только большую эффективность, но и более полную потокобезопасность.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":\"Примеры:\"}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"dynamic calc = GetCalculator();\",[\"$\",\"br\",null,{}],\"int sum = calc.Add(10, 20); // Динамический вызов\"]}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":\"public void SomeMethod(int x, int y = 5, int z = 7); // Опциональные параметры\"}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 5.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 5.0\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Шаблон TAP (Task-based Asynchronous Pattern). TAP использует один метод для представления инициализации и завершения асинхронной операции.\"}],[\"$\",\"li\",null,{\"children\":[\"Асинхронные методы (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"async\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"await\"}],\") — как реализация шаблона TAP.\"]}],[\"$\",\"li\",null,{\"children\":\"Сведения о вызывающем объекте\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 6.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 6.0\"}],[\"$\",\"ul\",null,{\"className\":\"list-code\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"null-условные операторы. Добавлены новые операторы: ?. и ?[]:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"int? length = customers?.Length; // null if customers is null\",[\"$\",\"br\",null,{}],\"Customer first = customers?[0];  // null if customers is null\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Функции сжатые до выражений (expression-bodied functions). Теперь определение метода может быть задано с использованием лямбда-синтаксиса:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public Point Move(int dx, int dy) \",\"=\u003e\",\" new Point(x + dx, y + dy);\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Инициализаторы автосвойств. Автосвойства теперь можно инициализировать при объявлении:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public string First \",\"{ get; set; }\",\" = \\\"Jane\\\";\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Автосвойства только для чтения. Автосвойства теперь могут быть объявлены без сеттеров:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public string First \",\"{ get; }\",\" = \\\"Jane\\\";\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Инициализаторы индексов. Теперь можно инициализировать не только объекты и коллекции, но и словари:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"var numbers = new Dictionary\",\"\u003cint, string\u003e\",\" \",\"{\",[\"$\",\"br\",null,{}],\"        [7] = \\\"seven\\\",\",[\"$\",\"br\",null,{}],\"        [9] = \\\"nine\\\",\",[\"$\",\"br\",null,{}],\"        [13] = \\\"thirteen\\\"\",[\"$\",\"br\",null,{}],\"}\",\";\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Интерполяция строк. Вместо использования конструкций с \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"String.Format()\"}],\", например:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"var s = String.Format(\\\"\",\"{0}\",\" is \",\"{1}\",\" year\",\"{{s}}\",\" old\\\", p.Name, p.Age);\"]}],[\"$\",\"br\",null,{}],\"теперь можно размещать код прямо в строке:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"теперь можно размещать код прямо в строке:\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Фильтры исключений. Появилась возможность задавать условия для блоков \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"catch\"}],\":\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"try \",\"{ … }\",\" catch (Exception e) when (Log(e)) \",\"{ … }\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Импорт статических функций типов. Теперь доступ к статическим членам типов возможен без указания полного имени этих членов:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"using static System.Console;\",[\"$\",\"br\",null,{}],\"using static System.Math;\",[\"$\",\"br\",null,{}],\"class Program\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        static void Main()\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                WriteLine(Sqrt(3*3 + 4*4));\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Оператор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"nameof\"}],\". Новый оператор, который возвращает компактное строковое представление для переданного в качестве аргумента типа:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"WriteLine(nameof(person.Address.ZipCode)); // prints \\\"ZipCode\\\"\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Для асинхронного программирования была добавлена возможность использования операторов \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"await\"}],\" внутри блоков \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"catch\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"finally\"}],\":\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"Resource res = null;\",[\"$\",\"br\",null,{}],\"try\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        res = await Resource.OpenAsync(…);       // You could do this.\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],\"catch(ResourceException e)\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        await Resource.LogAsync(res, e);         // Now you can do this …\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],\"finally\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],\"        if (res != null) await res.CloseAsync(); // … and this.\",[\"$\",\"br\",null,{}],\"}\"]}]]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 7.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 7.0\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"out\"}],\"-переменные, которые позволяют объявить переменные сразу в вызове метода (причем областью видимости для таких переменных является внешний блок):\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"p.GetCoordinates(out int x, out int y);\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Сопоставление с шаблоном. Вводится понятие шаблона (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"pattern\"}],\"), который представляет собой синтаксическую конструкцию, позволяющую проверить соответствие переменной определённой форме и извлечь из неё информацию.\"]}],[\"$\",\"li\",null,{\"children\":[\"Шаблоны с \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"is\"}],\" (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"is\"}],\" теперь может использоваться не только с типом, но и с шаблоном — в качестве правого аргумента)\"]}],[\"$\",\"li\",null,{\"children\":[\"Шаблоны и выражение \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"switch\"}],\". Варианты использования \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"switch\"}],\" были расширены, теперь можно:\",[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"in-list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"использовать любые типы (не только примитивные);\"}],[\"$\",\"li\",null,{\"children\":[\"использовать шаблоны в выражениях \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"case\"}],\";\"]}],[\"$\",\"li\",null,{\"children\":[\"добавлять дополнительные условия к выражениям \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"case\"}],\" (используя ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"when\"}],\").\"]}]]}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Кортежи. Добавлен тип кортеж значений (структура \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"ValueTuple\"}],\") и синтаксис работы с данными этого типа:\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"(string, string, string) LookupName(long id) // возвращаемый тип - кортеж\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        ... // инициализируем данные\",[\"$\",\"br\",null,{}],\"        return (first, middle, last); // литерал кортежа\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":\"Распаковка кортежей. Была добавлена новая синтаксическая конструкция деконструктор, позволяющая извлечь кортеж, состоящий из членов класса.\"}],[\"$\",\"li\",null,{\"children\":\"окальные функции. Теперь функцию, которая используется только в теле какого-либо метода, можно объявить прямо в теле этого метода.\"}],[\"$\",\"li\",null,{\"children\":[\"Улучшения литералов. Были добавлены бинарные литералы и символ разделителя (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"_\"}],\") в числовых литералах.\"]}],[\"$\",\"li\",null,{\"children\":[\"Локальные переменные и возвращаемые значения по ссылке. Расширена функциональность ключевого слова \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"ref\"}],\". Теперь можно возвратить данные из метода или сохранить их в локальной переменной по ссылке.\"]}],[\"$\",\"li\",null,{\"children\":\"Расширение списка типов, возвращаемых асинхронными методами\"}],[\"$\",\"li\",null,{\"children\":[\"Больше членов класса в виде выражений. Синтаксис функций, сжатых до выражений (expression-bodied functions \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"expression-bidied functions\"}],\"), теперь применим для сеттеров, геттеров, конструкторов и деструкторов.\"]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"throw\"}],\"-выражения. Теперь можно использовать \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"throw\"}],\" в функциях, сжатых до выражений (expression-bodied functions):\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public string GetLastName() \",\"=\u003e\",\" throw new NotImplementedException();\"]}]]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 8.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 8.0\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Модификатор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"readonly\"}],\". Был создан для обозначения члена, который не изменит состояние.\"]}],[\"$\",\"li\",null,{\"children\":\"Методы интерфейсов по умолчанию. Теперь при создании метода интерфейса можно объявить его реализацию по умолчанию, которую можно переопределить в классе, который реализует этот интерфейс.\"}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"li\",null,{\"className\":\"padding-hover-big\",\"children\":[\"Сопоставление шаблонов. Возможность позволяет работать с шаблонами в зависимости от формата в связанных, но различных типах данных.\",[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"in-list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Рекурсивные шаблоны. Является выражением шаблона, которое применяется к результатам другого выражения шаблона.\"}],[\"$\",\"li\",null,{\"className\":\"padding-hover-big-big\",\"children\":[\"Выражения switch позволяют сократить количество case и break, а также фигурных скобок.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini-small\",\"children\":[\"public enum Rainbow\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        Red,\",[\"$\",\"br\",null,{}],\"        Orange,\",[\"$\",\"br\",null,{}],\"        Yellow,\",[\"$\",\"br\",null,{}],\"        Green,\",[\"$\",\"br\",null,{}],\"        Blue,\",[\"$\",\"br\",null,{}],\"        Indigo,\",[\"$\",\"br\",null,{}],\"        Violet\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"public static RGBColor FromRainbow(Rainbow colorBand) \",\"=\u003e\",[\"$\",\"br\",null,{}],\"        colorBand switch\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                Rainbow.Red    \",\"=\u003e\",\" new RGBColor(0xFF, 0x00, 0x00),\",[\"$\",\"br\",null,{}],\"                Rainbow.Orange \",\"=\u003e\",\" new RGBColor(0xFF, 0x7F, 0x00),\",[\"$\",\"br\",null,{}],\"                Rainbow.Yellow \",\"=\u003e\",\" new RGBColor(0xFF, 0xFF, 0x00),\",[\"$\",\"br\",null,{}],\"                Rainbow.Green  \",\"=\u003e\",\" new RGBColor(0x00, 0xFF, 0x00),\",[\"$\",\"br\",null,{}],\"                Rainbow.Blue   \",\"=\u003e\",\" new RGBColor(0x00, 0x00, 0xFF),\",[\"$\",\"br\",null,{}],\"                Rainbow.Indigo \",\"=\u003e\",\" new RGBColor(0x4B, 0x00, 0x82),\",[\"$\",\"br\",null,{}],\"                Rainbow.Violet \",\"=\u003e\",\" new RGBColor(0x94, 0x00, 0xD3),\",[\"$\",\"br\",null,{}],\"                _              \",\"=\u003e\",\" throw new ArgumentException(message: \\\"invalid enum value\\\", paramName: nameof(colorBand)),\",[\"$\",\"br\",null,{}],\"        \",\"}\",\";\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}]]}],[\"$\",\"li\",null,{\"children\":[\"Шаблоны свойств. Позволяет сопоставлять свойства исследуемого объекта с помощью \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":[\"{\",\" variable : value \",\"}\",\" \",\"=\u003e\",\" ... .\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Шаблоны кортежей. Используется, если нужно работать с несколькими наборами входных данных. \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":[\"(value1, value2,..) \",\"=\u003e\",\" ...\"]}]]}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"Объявление \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"using\"}],\". Это объявление переменной, которому предшествует ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"using\"}],\". Оно сообщает компилятору, что объявляемая переменная должна быть удалена в конце области видимости.\"]}],[\"$\",\"li\",null,{\"children\":[\"Статический локальный метод. Теперь можно убедиться в том, что метод не охватывает какие-либо переменные из области видимости с помощью добавления к нему модификатора \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"static\"}],\".\"]}],[\"$\",\"li\",null,{\"children\":[\"Удаляемые ссылочные структуры. Ссылочные структуры не могут реализовать IDisposable (как и любые другие интерфейсы). Поэтому чтобы удалить \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"ref struct\"}],\", необходим доступный \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"void Dispose()\"}],\".\"]}],[\"$\",\"li\",null,{\"children\":[\"Типы значений, допускающие значение null. Теперь, чтобы указать, что переменная типа значений допускает значение \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"null\"}],\", необходимо поставить к имени типа \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"?\"}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Асинхронные потоки. Это во-первых интерфейс \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":[\"IAsyncEnumerable\",\"\u003cT\u003e\"]}],\".  А во-вторых конструкция \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"foreach\"}],\" с \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"await\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini-small\",\"children\":[\"public static async System.Collections.Generic.IAsyncEnumerable\",\"\u003cint\u003e\",\" GenerateSequence()\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        for (int i = 0; i \",\"\u003c\",\" 20; i++)\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                await Task.Delay(100);\",[\"$\",\"br\",null,{}],\"                yield return i;\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],\"// or\",[\"$\",\"br\",null,{}],\"await foreach (var number in GenerateSequence())\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        Console.WriteLine(number);\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Асинхронные высвобождаемые типы. Начиная с C# 8.0 язык поддерживает асинхронные освобождаемые типы, реализующие интерфейс \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"System.IAsyncDisposable\"}],\". Операнд выражения \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"using\"}],\" может реализовывать \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"IDisposable\"}],\" или \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"IAsyncDisposable\"}],\". В случае \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"IAsyncDisposable\"}],\" компилятор создает код для \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"await\"}],\", возвращенного \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Task\"}],\" из \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"IAsyncDisposable.DisposeAsync\"}],\".\"]}],[\"$\",\"li\",null,{\"children\":[\"Индексы и диапазоны. Диапазоны и индексы обеспечивают лаконичный синтаксис для доступа к отдельным элементам или диапазонам в последовательности. Нововведение включает в себя операторы \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"^\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"..\"}],\" , а также \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"System.Index\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"System.Range\"}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover-big\",\"children\":[\"Оператор присваивания объединения с \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"null\"}],\". Оператор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"??=\"}],\" можно использовать для присваивания значения правого операнда левому операнду только в том случае, если левый операнд имеет значение \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"null\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"List\",\"\u003cint\u003e\",\" numbers = null;\",[\"$\",\"br\",null,{}],\"int? i = null;\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"numbers ??= new List\",\"\u003cint\u003e\",\"();\",[\"$\",\"br\",null,{}],\"numbers.Add(i ??= 17);\",[\"$\",\"br\",null,{}],\"numbers.Add(i ??= 20);\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"Console.WriteLine(string.Join(\\\" \\\", numbers));\",[\"$\",\"br\",null,{}],\"Console.WriteLine(i);\"]}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"prew-terminal\",\"children\":[[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"Terminal\"}],[\"$\",\"li\",null,{\"className\":\"new\",\"children\":[\"$\",\"p\",null,{\"children\":\"+\"}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"terminal\",\"children\":[\"17 17\",[\"$\",\"br\",null,{}],\"17\"]}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"Неуправляемые сконструированные типы. Начиная с C# 8.0, сконструированный тип значения является неуправляемым, если он содержит поля исключительно неуправляемых типов (например универсальный тип \",\"\u003cT\u003e\",\").\"]}],[\"$\",\"li\",null,{\"className\":\"padding-hover-big\",\"children\":[\"Выражение stackalloc во вложенных выражениях. Теперь если результат выражения stackalloc имеет тип \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"System.Span\u003cT\u003e\"}],\" или \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"System.ReadOnlySpan\u003cT\u003e\"}],\", то его можно использовать в других выражениях.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"Span\",\"\u003cint\u003e\",\" numbers = stackalloc[] \",\"{ 1, 2, 3, 4, 5, 6 }\",\";\",[\"$\",\"br\",null,{}],\"var ind = numbers.IndexOfAny(stackalloc[] \",\"{ 2, 4, 6, 8 }\",\");\",[\"$\",\"br\",null,{}],\"Console.WriteLine(ind);\"]}],[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"prew-terminal\",\"children\":[[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"children\":[[\"$\",\"li\",null,{\"children\":\"Terminal\"}],[\"$\",\"li\",null,{\"className\":\"new\",\"children\":[\"$\",\"p\",null,{\"children\":\"+\"}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"terminal\",\"children\":\"1\"}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"Порядок маркеров \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"$$\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"@\"}],\" в интерполированных строках verbatim теперь может быть любым.\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 9.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 9.0\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"className\":\"padding-hover-big\",\"children\":[\"Типы записей. Появилась возможность при помощи ключевого слова \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"record\"}],\" для определения ссылочного типа, предоставляющего функционал инкапсуляции данных.\",[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"public record User(string FirstName, string LastName);\"}],[\"$\",\"br\",null,{}],\"По умолчанию типы записей является неизменяемыми. В отличие от других ссылочных типов, переменные типов записей считаются равными, если равны типы и значения их свойств и полей.\",[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"in-list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Обратимые изменения. Для заданного экземпляра записи при помощи ключевого слова \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"with\"}],\" возможно создание копии с изменёнными значениями указанных свойств и полей.\"]}],[\"$\",\"li\",null,{\"children\":\"Запись может быть унаследована от записи. Однако запись не может быть унаследована от класса, и наоборот, класс не может быть унаследован от записи.\"}]]}]]}],[\"$\",\"li\",null,{\"className\":\"padding-hover-big\",\"children\":[\"Инициализаторы. C# 9.0 предоставляет синтаксис — ключевое слово \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"init\"}],\" — для задания значений свойств класса при инициализации.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public class User\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public string FirstName \",\"{\",\" get; init; \",\"}\",[\"$\",\"br\",null,{}],\"        public string LastName \",\"{\",\" get; init; \",\"}\",[\"$\",\"br\",null,{}],\"}\",\";\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Операторы верхнего уровня. Один файл в приложении допускается начать сразу с исполняемых строк кода, минуя ряд таких формальностей, как объявление пространств имён, классов, методов. Такие операторы эквивалентны операторам метода \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"Main\"}],\".\"]}],[\"$\",\"li\",null,{\"children\":[\"Улучшения сопоставлений шаблонов.\",[\"$\",\"br\",null,{}],[\"$\",\"ul\",null,{\"className\":\"in-list\",\"children\":[[\"$\",\"li\",null,{\"children\":\"Шаблоны типов — соответствуют объекту заданного типа.\"}],[\"$\",\"li\",null,{\"children\":[\"Логические шаблоны — входные данные должны соответствовать заданной логической операции (\",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"and\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"or\"}],\", \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"not\"}],\").\"]}],[\"$\",\"li\",null,{\"children\":\"Реляционные шаблоны — входные данные должны соответствовать заданной операции сравнения (больше, меньше, равно, больше или равно, меньше или равно) с константой.\"}]]}]]}],[\"$\",\"li\",null,{\"children\":\"Улучшения производительности. \"}],[\"$\",\"li\",null,{\"className\":\"padding-hover\",\"children\":[\"Допускается опустить тип создаваемого объекта в выражении \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"new\"}],\", если он известен заранее\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"private List\",\"\u003cUser\u003e\",\" persons = new();\"]}]]}],[\"$\",\"li\",null,{\"children\":\"Поддержка статических лямбда-выражений и статических анонимных методов. Как и статические локальные функции, они не могут захватывать нестатические локальные переменные и состояния экземпляра.\"}],[\"$\",\"li\",null,{\"children\":\"Поддержка применения атрибутов к локальным функциям.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 10.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 10.0\"}],[\"$\",\"ul\",null,{\"className\":\"list-code\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Глобальные импорты. С помощью ключевого слова \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"global\"}],\" появилась возможность определить пространства имён, которые будут импортированы глобально во всех файлах проекта.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"global using System;\",[\"$\",\"br\",null,{}],\"global using System.Collections.Generic;\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Файловая область видимости пространства имён. Объявление пространства имён может быть применено ко всему файлу, что уменьшает уровень отступов в коде.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"namespace MyNamespace;\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Усовершенствованные структуры. Добавлены улучшения в работу со структурами, в том числе возможность инициализации полей непосредственно в теле структуры и поддержка параметров по умолчанию.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public struct Point\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public int X \",\"{\",\" get; set; \",\"}\",\" = 0;\",[\"$\",\"br\",null,{}],\"        public int Y \",\"{\",\" get; set; \",\"}\",\" = 0;\",[\"$\",\"br\",null,{}],\"{\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Запечатанные интерфейсы. Интерфейсы могут быть объявлены как \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"sealed\"}],\", что предотвращает их реализацию другими интерфейсами.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public sealed interface IMyInterface \",\"{ }\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Усовершенствованные операторы и литералы. Поддержка \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"with\"}],\"-оператора для структурных типов, улучшенные string-интерполяции и другие синтаксические улучшения.\"]}],[\"$\",\"li\",null,{\"children\":[\"Улучшенное сопоставление шаблонов. Добавлены новые возможности для сопоставления шаблонов, включая шаблоны списков и возможность использования шаблонов в операторах \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"switch\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"if\"}],\".\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"int[] numbers = \",\"{ 1, 2, 3, 4, 5 }\",\";\",[\"$\",\"br\",null,{}],\"bool isThreeElementArray = numbers is [_, _, _];\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Поддержка записи структуры и членов записи. Улучшена производительность при использовании структурных типов с поддержкой записи.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"public record struct Point(int X, int Y);\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Усовершенствованные атрибуты. Возможность применения атрибутов к более широкому кругу элементов, таких как локальные функции и выражения.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"[MyCustom]\",[\"$\",\"br\",null,{}],\"void LocalFunction() \",\"{ }\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Лямбда-выражения. Поддержка более мощных и гибких лямбда-выражений, включая использование типов возврата и деструктуризацию.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"var increment = (int x) \",\"=\u003e\",\" x + 1;\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Усовершенствованные \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"async/await\"}],\". Улучшена работа с асинхронными методами, включая более эффективное управление памятью и потоками.\"]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 11.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 11.0\"}],[\"$\",\"ul\",null,{\"className\":\"list-code\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Статические виртуальные элементы в интерфейсах. Интерфейсы теперь могут включать статические виртуальные и абстрактные члены, что позволяет перегружать операторы и определять статические свойства и методы. Это упрощает реализацию универсальных математических операций.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public interface IMyInterface\",\"\u003c\",\"TSelf, TOther, TResult\",\"\u003e\",[\"$\",\"br\",null,{}],\"        where TSelf : IMyInterface\",\"\u003c\",\"TSelf, TOther, TResult\",\"\u003e\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        static abstract TResult operator +(TSelf left, TOther right);\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Проверяемые и непроверяемые операторы. Разработчики могут определять \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"checked\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"unchecked\"}],\" арифметические операторы, что позволяет компилятору вызывать правильный вариант на основе контекста.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public static checked int operator +(MyType left, MyType right)\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        left.Value + right.Value;\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Оператор unsigned right-shift. Введен новый оператор \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"\u003e\u003e\u003e\"}],\", который выполняет сдвиг вправо без знака, упрощая работу с целочисленными типами.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"int result = -8 \",\"\u003e\u003e\u003e\",\" 2;\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Ослабленные требования к операторам смены. Второй операнд оператора сдвига больше не обязан быть типа \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"int\"}],\", что делает использование универсальных математических интерфейсов более гибким.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"MyType value = new MyType();\",[\"$\",\"br\",null,{}],\"value \",\"\u003e\u003e=\",\" 3;\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Поддержка универсальной математики. Новые интерфейсы, такие как \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"System.IAdditionOperators\u003cTSelf, TOther, TResult\u003e\"}],\", позволяют типам реализовывать математические операции более последовательно и удобно.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public struct MyNumber : \",\"IAdditionOperators\u003cMyNumber, MyNumber, MyNumber\u003e\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public static MyNumber operator +(MyNumber left, MyNumber right)\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"        new MyNumber(left.Value + right.Value);\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Расширенные возможности инициализации типов. Теперь можно задавать значения полей прямо в теле структуры и использовать параметры по умолчанию.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public struct Point\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public int X \",\"{\",\" get; set; \",\"}\",\" = 0;\",[\"$\",\"br\",null,{}],\"        public int Y \",\"{\",\" get; set; \",\"}\",\" = 0;\",[\"$\",\"br\",null,{}],\"}\"]}]]}]]}],[\"$\",\"br\",null,{}],[\"$\",\"h3\",null,{\"children\":\"Версия 12.0\"}],[\"$\",\"h4\",null,{\"children\":\"Новые возможности в версии 12.0[\"}],[\"$\",\"ul\",null,{\"className\":\"list-code\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Статические абстрактные и виртуальные методы в интерфейсах. Интерфейсы теперь могут содержать статические абстрактные и виртуальные методы, что позволяет определять поведение для универсальных математических операций.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public interface \",\"IMyInterface\u003cTSelf, TOther, TResult\u003e\",[\"$\",\"br\",null,{}],\"        where TSelf : \",\"IMyInterface\u003cTSelf, TOther, TResult\u003e\",\" \",[\"$\",\"br\",null,{}],\"{\",\" \",[\"$\",\"br\",null,{}],\"        static abstract TResult operator +(TSelf left, TOther right);\",[\"$\",\"br\",null,{}],\"        static virtual TResult Add(TSelf left, TOther right)\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                return left + right;\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Поддержка коллекций с неизменяемыми элементами. Введена новая коллекция \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"ImmutableArray\"}],\", которая обеспечивает неизменяемость элементов и повышение производительности.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":\"var immutableArray = ImmutableArray.Create(1, 2, 3, 4);\"}]]}],[\"$\",\"li\",null,{\"children\":[\"Улучшенные структуры данных. В C# 12 введены новые типы данных, такие как \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"readonly struct\"}],\" и \",[\"$\",\"span\",null,{\"className\":\"code-mini\",\"children\":\"ref readonly struct\"}],\", для оптимизации работы с памятью.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public readonly struct Point\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public int X \",\"{\",\" get; \",\"}\",[\"$\",\"br\",null,{}],\"        public int Y \",\"{\",\" get; \",\"}\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"        public Point(int x, int y)\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                X = x;\",[\"$\",\"br\",null,{}],\"                Y = y;\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"}\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Расширенные возможности для типов записи. Теперь записи поддерживают наследование и могут содержать методы с телами.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public record Person(string Name)\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public virtual string GetName() \",\"=\u003e\",\" Name;\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"public record Employee(string Name, int EmployeeId) : Person(Name)\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        public override string GetName() \",\"=\u003e\",\" $\\\"\",\"{\",\"Name\",\"}\",\" (ID: \",\"{\",\"EmployeeId\",\"}\",\")\\\";\",[\"$\",\"br\",null,{}],\"{\"]}]]}],[\"$\",\"li\",null,{\"children\":[\"Поддержка типов с произвольным количеством параметров. Введены новые методы для работы с переменным числом параметров, упрощая использование таких типов в коде.\",[\"$\",\"br\",null,{}],[\"$\",\"div\",null,{\"className\":\"code-big-mini\",\"children\":[\"public void PrintValues(params int[] values)\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        foreach (var value in values)\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                Console.WriteLine(value);\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"PrintValues(1, 2, 3, 4);\"]}]]}],[\"$\",\"li\",null,{\"children\":\"Расширенные возможности компилятора. В C# 12 компилятор получил новые возможности для оптимизации и проверки кода, включая улучшенную поддержку анализаторов и генераторов исходного кода.\"}]]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Пример «Hello, World!»\"}],[\"$\",\"p\",null,{\"children\":[\"Ниже представлен код классической программы «Hello world» на C# для консольного приложения:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":\"Console.WriteLine(\\\"Hello World!\\\");\"}],[\"$\",\"br\",null,{}],[\"$\",\"p\",null,{\"children\":[\"и код этой же программы для приложения Windows Forms:\",[\"$\",\"br\",null,{}]]}],[\"$\",\"div\",null,{\"className\":\"code\",\"children\":[\"namespace WindowsForms;\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"public class Program \",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        [STAThread]\",[\"$\",\"br\",null,{}],\"        public static void Main() \",\"=\u003e\",\" new DemoForm().ShowDialog();\",[\"$\",\"br\",null,{}],\"}\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"public class DemoForm : Form\",[\"$\",\"br\",null,{}],\"{\",[\"$\",\"br\",null,{}],\"        Label label = new Label();\",[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],\"        public DemoForm()\",[\"$\",\"br\",null,{}],\"        \",\"{\",[\"$\",\"br\",null,{}],\"                label.Text = \\\"Hello World!\\\";\",[\"$\",\"br\",null,{}],\"                this.Controls.Add(label);\",[\"$\",\"br\",null,{}],\"                this.StartPosition = FormStartPosition.CenterScreen;\",[\"$\",\"br\",null,{}],\"                this.BackColor = Color.White;\",[\"$\",\"br\",null,{}],\"                this.FormBorderStyle = FormBorderStyle.Fixed3D;\",[\"$\",\"br\",null,{}],\"        \",\"}\",[\"$\",\"br\",null,{}],\"}\"]}],[\"$\",\"br\",null,{}],[\"$\",\"br\",null,{}],[\"$\",\"h2\",null,{\"children\":\"Реализации\"}],[\"$\",\"p\",null,{\"children\":\"Существует несколько реализаций C#:\"}],[\"$\",\"ul\",null,{\"className\":\"list\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"Компилятор Roslyn c открытым \",[\"$\",\"a\",null,{\"href\":\"https://github.com/dotnet/roslyn\",\"className\":\"link-other\",\"children\":\"исходным кодом\"}]]}],[\"$\",\"li\",null,{\"children\":\"Реализация C# в виде компилятора csc.exe включена в состав .NET Framework (включая .NET Micro Framework, .NET Compact Framework и его реализации под Silverlight и Windows Phone 7).\"}],[\"$\",\"li\",null,{\"children\":\"В составе проекта Rotor (Shared Source Common Language Infrastructure) компании Microsoft.\"}],[\"$\",\"li\",null,{\"children\":\"Проект Mono включает в себя реализацию C# с открытым исходным кодом.\"}],[\"$\",\"li\",null,{\"children\":\"Проект DotGNU также включает компилятор C# с открытым кодом.\"}],[\"$\",\"li\",null,{\"children\":\"DotNetAnywhere — ориентированная на встраиваемые системы реализация CLR, поддерживает практически всю спецификацию C# 2.0.\"}]]}]]}]]}],null,[\"$\",\"$L7\",null,{\"children\":\"$L8\"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"rQXX18elhgv8hPKBEplck\",{\"children\":[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],null]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\na:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"C#\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Язык програмиорование C#\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script></body></html>