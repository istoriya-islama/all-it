1:"$Sreact.fragment"
2:I[8173,["173","static/chunks/173-adb53e817c3964da.js","970","static/chunks/970-fdca2819562abdd0.js","237","static/chunks/app/pages/posts/CSharp/page-7d785bd99510dee4.js"],""]
3:I[5244,[],""]
4:I[3866,[],""]
5:I[1700,["711","static/chunks/8e1d74a4-d5fa8b652382e494.js","173","static/chunks/173-adb53e817c3964da.js","177","static/chunks/app/layout-8dc7d88f1573f6b1.js"],"default"]
6:I[7970,["173","static/chunks/173-adb53e817c3964da.js","970","static/chunks/970-fdca2819562abdd0.js","237","static/chunks/app/pages/posts/CSharp/page-7d785bd99510dee4.js"],"Image"]
7:I[6213,[],"OutletBoundary"]
9:I[6213,[],"MetadataBoundary"]
b:I[6213,[],"ViewportBoundary"]
d:I[4835,[],""]
:HL["/_next/static/css/1633334b8bd4f972.css","style"]
0:{"P":null,"b":"2bG9-Hdm14uF9As9GrKRC","p":"","c":["","pages","posts","CSharp"],"i":false,"f":[[["",{"children":["pages",{"children":["posts",{"children":["CSharp",{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/1633334b8bd4f972.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_b962f2","children":[["$","div",null,{"className":"container","children":[["$","header",null,{"children":[["$","h1",null,{"children":"Все о Программировании"}],["$","nav",null,{"children":["$","ul",null,{"children":[["$","li",null,{"children":["$","$L2",null,{"href":"/","children":"Главная"}]}],["$","li",null,{"children":["$","$L2",null,{"href":"/pages/post","children":"Статьи"}]}],["$","li",null,{"className":"search","children":["$","$L2",null,{"href":"/pages/search","children":["$","svg",null,{"stroke":"currentColor","fill":"currentColor","strokeWidth":"0","viewBox":"0 0 512 512","color":"white","children":["$undefined",[["$","path","0",{"d":"M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z","children":[]}]]],"className":"$undefined","style":{"color":"white"},"height":20,"width":20,"xmlns":"http://www.w3.org/2000/svg"}]}]}],["$","li",null,{"className":"btn","children":["$","$L2",null,{"href":"https://t.me/it_reviews_other","children":"Зайди к нам"}]}]]}]}]]}],["$","div",null,{"className":"page","children":[["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","$L5",null,{}]]}]]}],["$","footer",null,{"children":[["$","hr",null,{}],["$","div",null,{"className":"container","children":[["$","span",null,{"className":"footer-text","children":"Спасибо за чтениe"}],["$","button",null,{"className":"btn-telgram","children":["$","a",null,{"href":"https://t.me/it_reviews_other","children":"Зайди к нам"}]}]]}]]}]]}]}]]}],{"children":["pages",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","pages","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","pages","children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["CSharp",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","pages","children","posts","children","CSharp","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":[["$","div",null,{"children":[["$","div",null,{"className":"cover","children":[["$","h3",null,{"children":"Все о Программировании"}],["$","h1",null,{"children":"C#| Си Шарп"}],["$","$L2",null,{"href":"https://t.me/it_reviews_other","children":["$","$L6",null,{"src":"/allIt.jpg","width":100,"height":100,"alt":"cover"}]}],["$","div",null,{}]]}],["$","div",null,{"className":"text","children":[["$","q",null,{"children":["C# (произносится си шарп) — объектно-ориентированный язык программирования общего назначения. Разработан в 1998—2001 годах группой инженеров компании Microsoft под руководством Андерса Хейлсберга и Скотта Вильтаумота как язык разработки приложений для платформы Microsoft .NET Framework и .NET Core. Впоследствии был стандартизирован как ECMA-334 и ISO/IEC 23270.",["$","br",null,{}],["$","br",null,{}],"C# относится к семье языков с C-подобным синтаксисом, из них его синтаксис наиболее близок к C++ и Java. Язык имеет статическую типизацию, поддерживает полиморфизм, перегрузку операторов (в том числе операторов явного и неявного приведения типа), делегаты, атрибуты, события, переменные, свойства, обобщённые типы и методы, итераторы, анонимные функции с поддержкой замыканий, LINQ, исключения, комментарии в формате XML.",["$","br",null,{}],["$","br",null,{}],"Переняв многое от своих предшественников — языков C++, Delphi, Модула, Smalltalk и, в особенности, Java — С#, опираясь на практику их использования, исключает некоторые модели, зарекомендовавшие себя как проблематичные при разработке программных систем, например, C# в отличие от C++ не поддерживает множественное наследование классов (между тем допускается множественная реализация интерфейсов)."]}],["$","br",null,{}],["$","br",null,{}],["$","h2",null,{"children":"Особенности языка"}],["$","p",null,{"children":"С# разрабатывался как язык программирования прикладного уровня для CLR и, как таковой, зависит, прежде всего, от возможностей самой CLR. Это касается, прежде всего, системы типов С#, которая отражает BCL. Присутствие или отсутствие тех или иных выразительных особенностей языка диктуется тем, может ли конкретная языковая особенность быть транслирована в соответствующие конструкции CLR. Так, с развитием CLR от версии 1.1 к 2.0 значительно обогатился и сам C#; подобного взаимодействия следует ожидать и в дальнейшем (однако, эта закономерность была нарушена с выходом C# 3.0, представляющего собой расширения языка, не опирающиеся на расширения платформы .NET). CLR предоставляет С#, как и всем другим .NET-ориентированным языкам, многие возможности, которых лишены «классические» языки программирования. Например, сборка мусора не реализована в самом C#, а производится CLR для программ, написанных на C#, точно так же, как это делается для программ на VB.NET, J# и др."}],["$","br",null,{}],["$","br",null,{}],["$","h2",null,{"children":"Название языка"}],["$","p",null,{"children":["Название «Си шарп» (от англ. sharp — диез) происходит от буквенной музыкальной нотации, где латинской букве C соответствует нота До, а знак диез (англ. sharp) означает повышение соответствующего ноте звука на полутон, что аналогично названию языка C++, где «++» обозначает инкремент переменной. Название также является игрой с цепочкой C → C++ → C++++(C#), так как символ «#» можно представить состоящим из 4 знаков «+».",["$","br",null,{}],["$","br",null,{}],"Из-за технических ограничений на отображение (стандартные шрифты, браузеры и т. д.), а также из-за того, что знак диеза ♯ не представлен на стандартной клавиатуре компьютера, при записи имени языка программирования используют знак решётки (#). Это соглашение отражено в Спецификации языка C# ECMA-334. Тем не менее, на практике (например, при размещении рекламы и коробочном дизайне), «Майкрософт» использует знак диеза.",["$","br",null,{}],["$","br",null,{}],"Названия языков программирования не принято переводить, поэтому язык называют, используя транскрипцию, — «Си шарп»."]}],["$","br",null,{}],["$","br",null,{}],["$","h2",null,{"children":"Стандартизация"}],["$","p",null,{"children":["C# стандартизирован в ECMA (ECMA-334) и ISO (ISO/IEC 23270).",["$","br",null,{}],["$","br",null,{}],"Известно как минимум о трёх независимых реализациях C#, базирующихся на этой спецификации и находящихся в настоящее время на различных стадиях разработки:"]}],["$","br",null,{}],["$","ul",null,{"children":[["$","li",null,{"children":"Mono, начата компанией Ximian, продолжена её покупателем и преемником Novell, а затем Xamarin."}],["$","li",null,{"children":"dotGNU и Portable.NET, разрабатываемые Free Software Foundation."}]]}],["$","br",null,{}],["$","br",null,{}],["$","h2",null,{"children":"Версии"}],["$","table",null,{"children":[["$","tr",null,{"children":[["$","th",null,{"children":"Версия"}],["$","th",null,{"children":"Дата выхода"}],["$","th",null,{"children":"Совместимые версии .NET"}],["$","th",null,{"children":"Совместимая версия Visual Studio"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 1.0"}],["$","td",null,{"children":"Январь 2002"}],["$","td",null,{"children":".NET Framework 1.0"}],["$","td",null,{"children":"Visual Studio .NET (2002)"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":["C# 1.1",["$","br",null,{}],"C# 1.2"]}],["$","td",null,{"children":"Апрель 2003"}],["$","td",null,{"children":".NET Framework 1.1"}],["$","td",null,{"children":"Visual Studio .NET 2003"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 2.0"}],["$","td",null,{"children":"Ноябрь 2005"}],["$","td",null,{"children":[".NET Framework 2.0",["$","br",null,{}],".NET Framework 3.0"]}],["$","td",null,{"children":"Visual Studio 2005"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 3.0"}],["$","td",null,{"children":"Ноябрь 2007"}],["$","td",null,{"children":[".NET Framework 2.0 (кроме LINQ)",["$","br",null,{}],".NET Framework 3.0 (кроме LINQ)",["$","br",null,{}],".NET Framework 3.5"]}],["$","td",null,{"children":"Visual Studio 2008"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 4.0"}],["$","td",null,{"children":"Апрель 2010"}],["$","td",null,{"children":".NET Framework 4.0"}],["$","td",null,{"children":"Visual Studio 2010"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 5.0"}],["$","td",null,{"children":"Август 2012"}],["$","td",null,{"children":".NET Framework 4.5"}],["$","td",null,{"children":"Visual Studio 2012"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 6.0"}],["$","td",null,{"children":"Июль 2015"}],["$","td",null,{"children":[".NET Framework 4.6",["$","br",null,{}],".NET Core 1.0",["$","br",null,{}],".NET Core 1.1"]}],["$","td",null,{"children":"Visual Studio 2015"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 7.0"}],["$","td",null,{"children":"Март 2017"}],["$","td",null,{"children":[".NET Framework 4.6.2",["$","br",null,{}],".NET Framework 4.7"]}],["$","td",null,{"children":"Visual Studio 2017 15.0"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 7.1"}],["$","td",null,{"children":"Август 2017"}],["$","td",null,{"children":".NET Core 2.0"}],["$","td",null,{"children":"Visual Studio 2017 15.3"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 7.2"}],["$","td",null,{"children":"Ноябрь 2017"}],["$","td",null,{"children":"Нету"}],["$","td",null,{"children":"Visual Studio 2017 15.5"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 7.3"}],["$","td",null,{"children":"Май 2018"}],["$","td",null,{"children":[".NET Core 2.1",["$","br",null,{}],".NET Core 2.2.",["$","br",null,{}],".NET Framework 4.8"]}],["$","td",null,{"children":"Visual Studio 2017 15.7"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 8.0"}],["$","td",null,{"children":"Сентябрь 2019"}],["$","td",null,{"children":[".NET Core 3.0",["$","br",null,{}],".NET Core 3.1",["$","br",null,{}],".NET Framework 4.8"]}],["$","td",null,{"children":"Visual Studio 2019 16.3"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 9.0"}],["$","td",null,{"children":"Сентябрь 2020"}],["$","td",null,{"children":".NET 5.0"}],["$","td",null,{"children":"Visual Studio 2019 16.8"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 10.0"}],["$","td",null,{"children":"Июль 2021"}],["$","td",null,{"children":".NET 6.0"}],["$","td",null,{"children":"Visual Studio 2022 17.0"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 11.0"}],["$","td",null,{"children":"Ноябрь 2022"}],["$","td",null,{"children":".NET 7.0"}],["$","td",null,{"children":"Visual Studio 2022 17.4"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 12.0"}],["$","td",null,{"children":"Ноябрь 2023"}],["$","td",null,{"children":".NET 8.0"}],["$","td",null,{"children":"Visual Studio 2022 17.8"}]]}]]}],["$","br",null,{}],["$","h5",null,{"children":"Общая информация по версиям"}],["$","table",null,{"children":[["$","tr",null,{"children":[["$","th",null,{"children":"Версия"}],["$","th",null,{"children":"Нововведения"}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 2.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Частичные типы"}],["$","li",null,{"children":"Обобщённые типы (generics)"}],["$","li",null,{"children":["Итераторы и ключевое слово ",["$","span",null,{"className":"code-mini","children":"yield"}]]}],["$","li",null,{"children":"Анонимные методы"}],["$","li",null,{"children":"Оператор null-объединения"}],["$","li",null,{"children":"Nullable-типы"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 3.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Запросы, интегрированные в язык (LINQ)"}],["$","li",null,{"children":"Инициализаторы объектов и коллекций"}],["$","li",null,{"children":"Лямбда-выражения"}],["$","li",null,{"children":"Деревья выражений"}],["$","li",null,{"children":["Неявная типизация и ключевое слово ",["$","span",null,{"className":"code-mini","children":"var"}]]}],["$","li",null,{"children":"Анонимные типы"}],["$","li",null,{"children":"Методы расширения"}],["$","li",null,{"children":"Автоматические свойства"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 4.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":["Динамическое связывание и ключевое слово ",["$","span",null,{"className":"code-mini","children":"dynamic"}]]}],["$","li",null,{"children":"Именованные и опциональные аргументы"}],["$","li",null,{"children":"Обобщенная ковариантность и контрвариантность"}],["$","li",null,{"children":["Библиотека TPL, концепция задач и классы ",["$","span",null,{"className":"code-mni","children":"Task"}],", ",["$","span",null,{"className":"code-mni","children":"Parallel"}]]}],["$","li",null,{"children":["Класс ",["$","span",null,{"className":"code-mini","children":"MemoryCache"}]]}],["$","li",null,{"children":"Классы параллельных коллекций"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 5.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Шаблон TAP"}],["$","li",null,{"children":["Асинхронные методы ",["$","span",null,{"className":"code-mini","children":"async"}]," и ",["$","span",null,{"className":"code-mini","children":"await"}]]}],["$","li",null,{"children":"Сведения о вызывающем объекте"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 6.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Компилятор как сервис"}],["$","li",null,{"children":"Импорт членов статических типов в пространство имён"}],["$","li",null,{"children":"Фильтры исключений"}],["$","li",null,{"children":[["$","span",null,{"className":"code-mini","children":"await"}]," в блоках ",["$","span",null,{"className":"code-mini","children":"catch"}],"/",["$","span",null,{"className":"code-mini","children":"finally"}]]}],["$","li",null,{"children":"Инициализаторы автосвойств"}],["$","li",null,{"children":"Автосвойства только для чтения"}],["$","li",null,{"children":["null-условные операции (",["$","span",null,{"className":"code-mini","children":"?."}]," и ",["$","span",null,{"className":"code-mini","children":"?[])"}]]}],["$","li",null,{"children":"Интерполяция строк"}],["$","li",null,{"children":["Оператор ",["$","span",null,{"className":"code-mini","children":"nameof"}]]}],["$","li",null,{"children":"Инициализатор словаря"}],["$","li",null,{"children":"Функции сжатые до выражений"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 7.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":[["$","span",null,{"className":"code-mini","children":"out"}],"-переменные"]}],["$","li",null,{"children":"Сопоставление с шаблоном"}],["$","li",null,{"children":["Шаблоны с ",["$","span",null,{"className":"code-mini","children":"is"}]]}],["$","li",null,{"children":["Шаблоны и выражение ",["$","span",null,{"className":"code-mini","children":"switch"}]]}],["$","li",null,{"children":"Кортежи"}],["$","li",null,{"children":"Распаковка кортежей (деконструкторы)"}],["$","li",null,{"children":"Локальные функции"}],["$","li",null,{"children":"Улучшения литералов"}],["$","li",null,{"children":"Локальные переменные и возвращаемые значения по ссылке"}],["$","li",null,{"children":"Расширение списка типов, возвращаемых асинхронными методами"}],["$","li",null,{"children":"Больше членов класса в виде выражений"}],["$","li",null,{"children":[["$","span",null,{"className":"code-mini","children":"throw"}]," выражения"]}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 8.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Члены только для чтения"}],["$","li",null,{"children":"Члены интерфейса по умолчанию"}],["$","li",null,{"children":"Улучшения сопоставления шаблонов"}],["$","li",null,{"children":"Объявления using"}],["$","li",null,{"children":"Статические локальные функции"}],["$","li",null,{"children":"Удаляемые ссылочные структуры"}],["$","li",null,{"children":"Ссылочные типы, допускающие значение NULL"}],["$","li",null,{"children":"Асинхронные потоки"}],["$","li",null,{"children":"Индексы и диапазоны"}],["$","li",null,{"children":"Присваивание объединения со значением NULL"}],["$","li",null,{"children":"Неуправляемые сконструированные типы"}],["$","li",null,{"children":"Выражения stackalloc во вложенных выражениях"}],["$","li",null,{"children":"Больше членов класса в виде выражений"}],["$","li",null,{"children":"Улучшения интерполированных строк"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 9.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Оператор объединения с null (??)"}],["$","li",null,{"children":"Пустые параметры для лямбда-выражений"}],["$","li",null,{"children":"Native Int: nint, nuint"}],["$","li",null,{"children":"Дизъюнктное объединение"}],["$","li",null,{"children":["Добавлено ",["$","span",null,{"className":"code-mini","children":"with"}],"-выражения"]}],["$","li",null,{"children":["новый модификатор ",["$","span",null,{"className":"code-mini","children":"initonly"}]]}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 10.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":["Добавление ",["$","span",null,{"className":"code-mini","children":"role=\"alert\""}]," атрибуты сообщений"]}],["$","li",null,{"children":["Обновления ",["$","span",null,{"className":"code-mini","children":"Counter"}]," компонент для добавления ",["$","span",null,{"className":"code-mini","children":"role=\"status\""}]]}],["$","li",null,{"children":["Замена ul в ",["$","span",null,{"className":"code-mini","children":"NavBar"}]," компонент для ",["$","span",null,{"className":"code-mini","children":"nav"}]]}],["$","li",null,{"children":["Новое название кнопки переключения ",["$","span",null,{"className":"code-mini","children":"NavBar"}]]}],["$","li",null,{"children":"Переход к использованию более семантической разметки"}]]}]}]]}],["$","tr",null,{"children":[["$","td",null,{"children":"C# 11.0"}],["$","td",null,{"children":["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Необработанные строковые литералы"}],["$","li",null,{"children":"Поддержка универсальной математики"}],["$","li",null,{"children":"Универсальные атрибуты"}],["$","li",null,{"children":"Строковые литералы UTF-8"}],["$","li",null,{"children":"Новые строки в выражениях интерполяции строк"}],["$","li",null,{"children":"Шаблоны списка"}],["$","li",null,{"children":"Локальные типы файлов"}],["$","li",null,{"children":"Обязательные элементы"}],["$","li",null,{"children":"Автоматические структуры по умолчанию"}],["$","li",null,{"children":["Сопоставление ",["$","span",null,{"className":"code-mini","children":["Span","<char>"]}]," шаблонов для константы string"]}],["$","li",null,{"children":["Расширенные ",["$","span",null,{"className":"code-mini","children":"nameof"}]," область"]}],["$","li",null,{"children":["Числовой ",["$","span",null,{"className":"code-mini","children":"intPtr"}]]}],["$","li",null,{"children":[["$","span",null,{"className":"code-mini","children":"ref"}]," поля и ",["$","span",null,{"className":"code-mini","children":"scoped ref"}]]}],["$","li",null,{"children":"Улучшенное преобразование групп методов для делегирования."}]]}]}]]}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 1.0"}],["$","p",null,{"children":["Проект C# был начат в декабре 1998 и получил кодовое название COOL (C-style Object Oriented Language). Версия 1.0 была анонсирована вместе с платформой .NET в июне 2000 года, тогда же появилась и первая общедоступная бета-версия; C# 1.0 окончательно вышел вместе с Microsoft Visual Studio .NET в феврале 2002 года.",["$","br",null,{}],["$","br",null,{}],"Первая версия C# напоминала по своим возможностям Java 1.4, несколько их расширяя: так, в C# имелись свойства (выглядящие в коде как поля объекта, но на деле вызывающие при обращении к ним методы класса), индексаторы (подобные свойствам, но принимающие параметр как индекс массива), события, делегаты, циклы ",["$","span",null,{"className":"code-mini","children":"foreach"}],", структуры, передаваемые по значению, автоматическое преобразование встроенных типов в объекты при необходимости (boxing), атрибуты, встроенные средства взаимодействия с неуправляемым кодом (DLL, COM) и прочее.",["$","br",null,{}],["$","br",null,{}],"Кроме того, в C# решено было перенести некоторые возможности C++, отсутствовавшие в Java: беззнаковые типы, перегрузку операторов (с некоторыми ограничениями, в отличие от C++), передача параметров в метод по ссылке, методы с переменным числом параметров, оператор ",["$","span",null,{"className":"code-mini","children":"goto"}]," (с ограничениями). Также в C# оставили ограниченную возможность работы с указателями — в местах кода, специально обозначенных словом ",["$","span",null,{"className":"code-mini","children":"unsafe"}]," и при указании специальной опции компилятору."]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 2.0"}],["$","p",null,{"children":"Проект спецификации C# 2.0 впервые был опубликован Microsoft в октябре 2003 года; в 2004 году выходили бета-версии (проект с кодовым названием Whidbey), C# 2.0 окончательно вышел 7 ноября 2005 года вместе с Visual Studio 2005 и .NET 2.0."}],["$","h4",null,{"children":"Новые возможности в версии 2.0"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Частичные типы (разделение реализации класса более чем на один файл)."}],["$","li",null,{"children":"Обобщённые, или параметризованные типы (generics). В отличие от шаблонов C++, они поддерживают некоторые дополнительные возможности и работают на уровне виртуальной машины. Вместе с тем, параметрами обобщённого типа не могут быть выражения, они не могут быть полностью или частично специализированы, не поддерживают шаблонных параметров по умолчанию, от шаблонного параметра нельзя наследоваться, и т. д."}],["$","li",null,{"children":["Новая форма итератора, позволяющая создавать сопрограммы с помощью ключевого слова ",["$","span",null,{"className":"code-mini","children":"yeild"}],", подобно Python и Ruby."]}],["$","li",null,{"children":"Анонимные методы, обеспечивающие функциональность замыкания."}],["$","li",null,{"children":["Оператор null-объединения: ",["$","span",null,{"className":"code-mini","children":"'??': return obj1 ?? obj2;"}]," означает (в нотации C# 1.0) ",["$","span",null,{"className":"code-mini","children":"return obj1!=null ? obj1 : obj2;"}],"."]}],["$","li",null,{"children":["Обнуляемые (nullable) типы — значения (обозначаемые вопросительным знаком, например, ",["$","span",null,{"className":"code-mini","children":"int? i = null;"}],"), представляющие собой те же самые типы-значения, способные принимать также значение ",["$","span",null,{"className":"code-mini","children":"null"}],". Такие типы позволяют улучшить взаимодействие с базами данных через язык SQL."]}],["$","li",null,{"children":"Поддержка 64-разрядных вычислений, что кроме всего прочего, позволяет увеличить адресное пространство и использовать 64-разрядные примитивные типы данных."}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 3.0"}],["$","p",null,{"children":"В июне 2004 года Андерс Хейлсберг впервые рассказал на сайте Microsoft о планируемых расширениях языка в C#3.0. В сентябре 2005 года вышли проект спецификации C# 3.0 и бета-версия C# 3.0, устанавливаемая в виде дополнения к существующим Visual Studio 2005 и .NET 2.0. Окончательно эта версия языка вошла в Visual Studio 2008 и .NET 3.5."}],["$","h4",null,{"children":"Новые возможности в версии 3.0"}],["$","p",null,{"children":"В C# 3.0 появились следующие радикальные добавления к языку:"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"children":["ключевые слова ",["$","span",null,{"className":"code-mini","children":"select, from, where"}],", позволяющие делать запросы из XML документов, коллекций и т. п. Эти запросы имеют сходство с запросами SQL и реализуются компонентом LINQ. (Сама фраза «language integrated query» переводится «запрос, интегрированный в язык».)"]}],["$","li",null,{"className":"padding-hover","children":["Инициализация объекта вместе с его свойствами:",["$","div",null,{"className":"code","children":["Customer c = new Customer();",["$","br",null,{}],"c.Name = \"James\"; c.Age=30;"]}],"можно записать как",["$","div",null,{"className":"code-big-mini","children":["Customer c = new Customer ","{ Name = \"James\", Age = 30 }",";"]}]]}],["$","li",null,{"className":"padding-hover","children":["Лямбда-выражения:",["$","div",null,{"className":"code-big-mini","children":["listOfFoo.Where(delegate(Foo x) ","{ return x.size > 10; }",");"]}],"теперь можно записать как",["$","div",null,{"className":"code-big-mini","children":["listOfFoo.Where(x ","=>"," x.size ",">"," 10);"]}]]}],["$","li",null,{"children":["Деревья выражений:",["$","br",null,{}],"лямбда-выражения теперь могут представляться в виде структуры данных, доступной для обхода во время выполнения, тем самым позволяя транслировать строго типизированные C#-выражения в другие домены (например, выражения SQL)."]}],["$","li",null,{"children":["Неявная типизация: Вывод типов локальной переменной. Для неявной типизации вместо названия типа данных используется ключевое слово var. Затем уже при компиляции компилятор сам выводит тип данных исходя из присвоенного значения: ",["$","span",null,{"className":"code-mini","children":"var x = \"hello\";"}]," вместо ",["$","span",null,{"className":"code-mini","children":"string x = \"hello\";"}]]}],["$","li",null,{"children":["Анонимные типы: ",["$","span",null,{"className":"code-mini","children":["var x = new ","{ Name = \"Muhammad\" }",";"]}]]}],["$","li",null,{"className":"padding-hover","children":["Методы расширения. Появилась возможность добавления новых методов в уже существующие классы. Реализуется с помощью ключевого слова this при первом параметре статической функции статического класса.",["$","div",null,{"className":"code","children":["public static class StringExtensions",["$","br",null,{}],"{",["$","br",null,{}],"        public static int ToInt32(this string val)",["$","br",null,{}],"        ","{",["$","br",null,{}],"                return Int32.Parse(val);",["$","br",null,{}],"        ","}",["$","br",null,{}],"}",["$","br",null,{}],"// ...",["$","br",null,{}],"string s = \"10\";",["$","br",null,{}],"int x = s.ToInt32();"]}]]}],["$","li",null,{"className":"padding-hover","children":["Автоматические свойства: компилятор сгенерирует закрытое (private) поле и соответствующие аксессор и мутатор для кода вида",["$","div",null,{"className":"code-big-mini","children":["public string Name ","{ get; private set; }"]}]]}]]}],["$","p",null,{"children":["C# 3.0 совместим с C# 2.0 по генерируемому MSIL-коду; улучшения в языке — чисто синтаксические и реализуются на этапе компиляции. Например, многие из интегрированных запросов LINQ можно осуществить, используя безымянные делегаты в сочетании с предикатными методами над контейнерами наподобие ",["$","span",null,{"className":"code-mini","children":"List.FindAll"}]," и ",["$","span",null,{"className":"code-mini","children":"List.RemoveAll"}],"."]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 4.0"}],["$","p",null,{"children":["Превью C# 4.0 было представлено в конце 2008 года, вместе с CTP-версией Visual Studio 2010.",["$","br",null,{}],["$","br",null,{}],"Visual Basic 10.0 и C# 4.0 были выпущены в апреле 2010 года, одновременно с выпуском Visual Studio 2010."]}],["$","h4",null,{"children":"Новые возможности в версии 4.0"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"children":["Возможность использования позднего связывания, для использования:",["$","ul",null,{"className":"in-list","children":[["$","li",null,{"children":["с языками с динамической типизацией (",["$","a",null,{"href":"../Python","children":"Python"}],", ",["$","a",null,{"href":"../Ruby","children":"Ruby"}],")"]}],["$","li",null,{"children":"с COM-объектами"}],["$","li",null,{"children":"отражения (reflection)"}],["$","li",null,{"children":["объектов с изменяемой структурой (DOM). Появляется ключевое слово ",["$","span",null,{"className":"code-mini","children":"dynamic"}],"."]}]]}]]}],["$","li",null,{"children":"Именованные и опциональные параметры"}],["$","li",null,{"children":"Новые возможности COM interop"}],["$","li",null,{"children":"Ковариантность и контравариантность обобщенных интерфейсов и делегатов"}],["$","li",null,{"children":"Контракты в коде (Code Contracts)"}],["$","li",null,{"children":["Библиотека параллельных задач TPL (Task Parallel Library), концепция задач и классы ",["$","span",null,{"className":"code-mini","children":"Task"}],", ",["$","span",null,{"className":"code-mini","children":"TaskFactory"}],", ",["$","span",null,{"className":"code-mini","children":"Parallel"}]]}],["$","li",null,{"children":["Добавлен класс ",["$","span",null,{"className":"code-mini","children":"MemoryCache"}],", который предназначен для кэширования контента. Он похож на класс ",["$","span",null,{"className":"code-mini","children":"Cache"}]," ASP.NET, но его можно использовать при написании веб- / графических / консольных приложений."]}],["$","li",null,{"children":"Добавлено пространство имен System.Collections.Concurrent и новые классы параллельных коллекций (ConcurrentQueue, ConcurrentStack, ConcurrentBag,…), которые предоставляют не только большую эффективность, но и более полную потокобезопасность."}]]}],["$","br",null,{}],["$","p",null,{"children":"Примеры:"}],["$","br",null,{}],["$","div",null,{"className":"code","children":["dynamic calc = GetCalculator();",["$","br",null,{}],"int sum = calc.Add(10, 20); // Динамический вызов"]}],["$","br",null,{}],["$","div",null,{"className":"code","children":"public void SomeMethod(int x, int y = 5, int z = 7); // Опциональные параметры"}],["$","br",null,{}],["$","h3",null,{"children":"Версия 5.0"}],["$","h4",null,{"children":"Новые возможности в версии 5.0"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"children":"Шаблон TAP (Task-based Asynchronous Pattern). TAP использует один метод для представления инициализации и завершения асинхронной операции."}],["$","li",null,{"children":["Асинхронные методы (",["$","span",null,{"className":"code-mini","children":"async"}]," и ",["$","span",null,{"className":"code-mini","children":"await"}],") — как реализация шаблона TAP."]}],["$","li",null,{"children":"Сведения о вызывающем объекте"}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 6.0"}],["$","h4",null,{"children":"Новые возможности в версии 6.0"}],["$","ul",null,{"className":"list-code","children":[["$","li",null,{"children":["null-условные операторы. Добавлены новые операторы: ?. и ?[]:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["int? length = customers?.Length; // null if customers is null",["$","br",null,{}],"Customer first = customers?[0];  // null if customers is null"]}]]}],["$","li",null,{"children":["Функции сжатые до выражений (expression-bodied functions). Теперь определение метода может быть задано с использованием лямбда-синтаксиса:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public Point Move(int dx, int dy) ","=>"," new Point(x + dx, y + dy);"]}]]}],["$","li",null,{"children":["Инициализаторы автосвойств. Автосвойства теперь можно инициализировать при объявлении:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public string First ","{ get; set; }"," = \"Jane\";"]}]]}],["$","li",null,{"children":["Автосвойства только для чтения. Автосвойства теперь могут быть объявлены без сеттеров:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public string First ","{ get; }"," = \"Jane\";"]}]]}],["$","li",null,{"children":["Инициализаторы индексов. Теперь можно инициализировать не только объекты и коллекции, но и словари:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["var numbers = new Dictionary","<int, string>"," ","{",["$","br",null,{}],"        [7] = \"seven\",",["$","br",null,{}],"        [9] = \"nine\",",["$","br",null,{}],"        [13] = \"thirteen\"",["$","br",null,{}],"}",";"]}]]}],["$","li",null,{"children":["Интерполяция строк. Вместо использования конструкций с ",["$","span",null,{"className":"code-mini","children":"String.Format()"}],", например:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["var s = String.Format(\"","{0}"," is ","{1}"," year","{{s}}"," old\", p.Name, p.Age);"]}],["$","br",null,{}],"теперь можно размещать код прямо в строке:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":"теперь можно размещать код прямо в строке:"}]]}],["$","li",null,{"children":["Фильтры исключений. Появилась возможность задавать условия для блоков ",["$","span",null,{"className":"code-mini","children":"catch"}],":",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["try ","{ … }"," catch (Exception e) when (Log(e)) ","{ … }"]}]]}],["$","li",null,{"children":["Импорт статических функций типов. Теперь доступ к статическим членам типов возможен без указания полного имени этих членов:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["using static System.Console;",["$","br",null,{}],"using static System.Math;",["$","br",null,{}],"class Program",["$","br",null,{}],"{",["$","br",null,{}],"        static void Main()",["$","br",null,{}],"        ","{",["$","br",null,{}],"                WriteLine(Sqrt(3*3 + 4*4));",["$","br",null,{}],"        ","}",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Оператор ",["$","span",null,{"className":"code-mini","children":"nameof"}],". Новый оператор, который возвращает компактное строковое представление для переданного в качестве аргумента типа:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":"WriteLine(nameof(person.Address.ZipCode)); // prints \"ZipCode\""}]]}],["$","li",null,{"children":["Для асинхронного программирования была добавлена возможность использования операторов ",["$","span",null,{"className":"code-mini","children":"await"}]," внутри блоков ",["$","span",null,{"className":"code-mini","children":"catch"}]," и ",["$","span",null,{"className":"code-mini","children":"finally"}],":",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["Resource res = null;",["$","br",null,{}],"try",["$","br",null,{}],"{",["$","br",null,{}],"        res = await Resource.OpenAsync(…);       // You could do this.",["$","br",null,{}],"}",["$","br",null,{}],"catch(ResourceException e)",["$","br",null,{}],"{",["$","br",null,{}],"        await Resource.LogAsync(res, e);         // Now you can do this …",["$","br",null,{}],"}",["$","br",null,{}],"finally",["$","br",null,{}],"}",["$","br",null,{}],"        if (res != null) await res.CloseAsync(); // … and this.",["$","br",null,{}],"}"]}]]}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 7.0"}],["$","h4",null,{"children":"Новые возможности в версии 7.0"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"className":"padding-hover","children":[["$","span",null,{"className":"code-mini","children":"out"}],"-переменные, которые позволяют объявить переменные сразу в вызове метода (причем областью видимости для таких переменных является внешний блок):",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":"p.GetCoordinates(out int x, out int y);"}]]}],["$","li",null,{"children":["Сопоставление с шаблоном. Вводится понятие шаблона (",["$","span",null,{"className":"code-mini","children":"pattern"}],"), который представляет собой синтаксическую конструкцию, позволяющую проверить соответствие переменной определённой форме и извлечь из неё информацию."]}],["$","li",null,{"children":["Шаблоны с ",["$","span",null,{"className":"code-mini","children":"is"}]," (",["$","span",null,{"className":"code-mini","children":"is"}]," теперь может использоваться не только с типом, но и с шаблоном — в качестве правого аргумента)"]}],["$","li",null,{"children":["Шаблоны и выражение ",["$","span",null,{"className":"code-mini","children":"switch"}],". Варианты использования ",["$","span",null,{"className":"code-mini","children":"switch"}]," были расширены, теперь можно:",["$","br",null,{}],["$","ul",null,{"className":"in-list","children":[["$","li",null,{"children":"использовать любые типы (не только примитивные);"}],["$","li",null,{"children":["использовать шаблоны в выражениях ",["$","span",null,{"className":"code-mini","children":"case"}],";"]}],["$","li",null,{"children":["добавлять дополнительные условия к выражениям ",["$","span",null,{"className":"code-mini","children":"case"}]," (используя ключевое слово ",["$","span",null,{"className":"code-mini","children":"when"}],")."]}]]}]]}],["$","li",null,{"className":"padding-hover","children":["Кортежи. Добавлен тип кортеж значений (структура ",["$","span",null,{"className":"code-mini","children":"ValueTuple"}],") и синтаксис работы с данными этого типа:",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["(string, string, string) LookupName(long id) // возвращаемый тип - кортеж",["$","br",null,{}],"{",["$","br",null,{}],"        ... // инициализируем данные",["$","br",null,{}],"        return (first, middle, last); // литерал кортежа",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":"Распаковка кортежей. Была добавлена новая синтаксическая конструкция деконструктор, позволяющая извлечь кортеж, состоящий из членов класса."}],["$","li",null,{"children":"окальные функции. Теперь функцию, которая используется только в теле какого-либо метода, можно объявить прямо в теле этого метода."}],["$","li",null,{"children":["Улучшения литералов. Были добавлены бинарные литералы и символ разделителя (",["$","span",null,{"className":"code-mini","children":"_"}],") в числовых литералах."]}],["$","li",null,{"children":["Локальные переменные и возвращаемые значения по ссылке. Расширена функциональность ключевого слова ",["$","span",null,{"className":"code-mini","children":"ref"}],". Теперь можно возвратить данные из метода или сохранить их в локальной переменной по ссылке."]}],["$","li",null,{"children":"Расширение списка типов, возвращаемых асинхронными методами"}],["$","li",null,{"children":["Больше членов класса в виде выражений. Синтаксис функций, сжатых до выражений (expression-bodied functions ",["$","span",null,{"className":"code-mini","children":"expression-bidied functions"}],"), теперь применим для сеттеров, геттеров, конструкторов и деструкторов."]}],["$","li",null,{"className":"padding-hover","children":[["$","span",null,{"className":"code-mini","children":"throw"}],"-выражения. Теперь можно использовать ",["$","span",null,{"className":"code-mini","children":"throw"}]," в функциях, сжатых до выражений (expression-bodied functions):",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public string GetLastName() ","=>"," throw new NotImplementedException();"]}]]}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 8.0"}],["$","h4",null,{"children":"Новые возможности в версии 8.0"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"children":["Модификатор ",["$","span",null,{"className":"code-mini","children":"readonly"}],". Был создан для обозначения члена, который не изменит состояние."]}],["$","li",null,{"children":"Методы интерфейсов по умолчанию. Теперь при создании метода интерфейса можно объявить его реализацию по умолчанию, которую можно переопределить в классе, который реализует этот интерфейс."}],["$","br",null,{}],["$","br",null,{}],["$","li",null,{"className":"padding-hover-big","children":["Сопоставление шаблонов. Возможность позволяет работать с шаблонами в зависимости от формата в связанных, но различных типах данных.",["$","br",null,{}],["$","ul",null,{"className":"in-list","children":[["$","li",null,{"children":"Рекурсивные шаблоны. Является выражением шаблона, которое применяется к результатам другого выражения шаблона."}],["$","li",null,{"className":"padding-hover-big-big","children":["Выражения switch позволяют сократить количество case и break, а также фигурных скобок.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini-small","children":["public enum Rainbow",["$","br",null,{}],"{",["$","br",null,{}],"        Red,",["$","br",null,{}],"        Orange,",["$","br",null,{}],"        Yellow,",["$","br",null,{}],"        Green,",["$","br",null,{}],"        Blue,",["$","br",null,{}],"        Indigo,",["$","br",null,{}],"        Violet",["$","br",null,{}],"}",["$","br",null,{}],["$","br",null,{}],"public static RGBColor FromRainbow(Rainbow colorBand) ","=>",["$","br",null,{}],"        colorBand switch",["$","br",null,{}],"        ","{",["$","br",null,{}],"                Rainbow.Red    ","=>"," new RGBColor(0xFF, 0x00, 0x00),",["$","br",null,{}],"                Rainbow.Orange ","=>"," new RGBColor(0xFF, 0x7F, 0x00),",["$","br",null,{}],"                Rainbow.Yellow ","=>"," new RGBColor(0xFF, 0xFF, 0x00),",["$","br",null,{}],"                Rainbow.Green  ","=>"," new RGBColor(0x00, 0xFF, 0x00),",["$","br",null,{}],"                Rainbow.Blue   ","=>"," new RGBColor(0x00, 0x00, 0xFF),",["$","br",null,{}],"                Rainbow.Indigo ","=>"," new RGBColor(0x4B, 0x00, 0x82),",["$","br",null,{}],"                Rainbow.Violet ","=>"," new RGBColor(0x94, 0x00, 0xD3),",["$","br",null,{}],"                _              ","=>"," throw new ArgumentException(message: \"invalid enum value\", paramName: nameof(colorBand)),",["$","br",null,{}],"        ","}",";"]}],["$","br",null,{}],["$","br",null,{}]]}],["$","li",null,{"children":["Шаблоны свойств. Позволяет сопоставлять свойства исследуемого объекта с помощью ",["$","span",null,{"className":"code-mini","children":["{"," variable : value ","}"," ","=>"," ... ."]}]]}],["$","li",null,{"children":["Шаблоны кортежей. Используется, если нужно работать с несколькими наборами входных данных. ",["$","span",null,{"className":"code-mini","children":["(value1, value2,..) ","=>"," ..."]}]]}]]}]]}],["$","li",null,{"children":["Объявление ",["$","span",null,{"className":"code-mini","children":"using"}],". Это объявление переменной, которому предшествует ключевое слово ",["$","span",null,{"className":"code-mini","children":"using"}],". Оно сообщает компилятору, что объявляемая переменная должна быть удалена в конце области видимости."]}],["$","li",null,{"children":["Статический локальный метод. Теперь можно убедиться в том, что метод не охватывает какие-либо переменные из области видимости с помощью добавления к нему модификатора ",["$","span",null,{"className":"code-mini","children":"static"}],"."]}],["$","li",null,{"children":["Удаляемые ссылочные структуры. Ссылочные структуры не могут реализовать IDisposable (как и любые другие интерфейсы). Поэтому чтобы удалить ",["$","span",null,{"className":"code-mini","children":"ref struct"}],", необходим доступный ",["$","span",null,{"className":"code-mini","children":"void Dispose()"}],"."]}],["$","li",null,{"children":["Типы значений, допускающие значение null. Теперь, чтобы указать, что переменная типа значений допускает значение ",["$","span",null,{"className":"code-mini","children":"null"}],", необходимо поставить к имени типа ",["$","span",null,{"className":"code-mini","children":"?"}]]}],["$","li",null,{"className":"padding-hover","children":["Асинхронные потоки. Это во-первых интерфейс ",["$","span",null,{"className":"code-mini","children":["IAsyncEnumerable","<T>"]}],".  А во-вторых конструкция ",["$","span",null,{"className":"code-mini","children":"foreach"}]," с ",["$","span",null,{"className":"code-mini","children":"await"}],".",["$","br",null,{}],["$","br",null,{}],["$","div",null,{"className":"code-big-mini-small","children":["public static async System.Collections.Generic.IAsyncEnumerable","<int>"," GenerateSequence()",["$","br",null,{}],"{",["$","br",null,{}],"        for (int i = 0; i ","<"," 20; i++)",["$","br",null,{}],"        ","{",["$","br",null,{}],"                await Task.Delay(100);",["$","br",null,{}],"                yield return i;",["$","br",null,{}],"        ","}",["$","br",null,{}],"}",["$","br",null,{}],"// or",["$","br",null,{}],"await foreach (var number in GenerateSequence())",["$","br",null,{}],"{",["$","br",null,{}],"        Console.WriteLine(number);",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Асинхронные высвобождаемые типы. Начиная с C# 8.0 язык поддерживает асинхронные освобождаемые типы, реализующие интерфейс ",["$","span",null,{"className":"code-mini","children":"System.IAsyncDisposable"}],". Операнд выражения ",["$","span",null,{"className":"code-mini","children":"using"}]," может реализовывать ",["$","span",null,{"className":"code-mini","children":"IDisposable"}]," или ",["$","span",null,{"className":"code-mini","children":"IAsyncDisposable"}],". В случае ",["$","span",null,{"className":"code-mini","children":"IAsyncDisposable"}]," компилятор создает код для ",["$","span",null,{"className":"code-mini","children":"await"}],", возвращенного ",["$","span",null,{"className":"code-mini","children":"Task"}]," из ",["$","span",null,{"className":"code-mini","children":"IAsyncDisposable.DisposeAsync"}],"."]}],["$","li",null,{"children":["Индексы и диапазоны. Диапазоны и индексы обеспечивают лаконичный синтаксис для доступа к отдельным элементам или диапазонам в последовательности. Нововведение включает в себя операторы ",["$","span",null,{"className":"code-mini","children":"^"}]," и ",["$","span",null,{"className":"code-mini","children":".."}]," , а также ",["$","span",null,{"className":"code-mini","children":"System.Index"}]," и ",["$","span",null,{"className":"code-mini","children":"System.Range"}]]}],["$","li",null,{"className":"padding-hover-big","children":["Оператор присваивания объединения с ",["$","span",null,{"className":"code-mini","children":"null"}],". Оператор ",["$","span",null,{"className":"code-mini","children":"??="}]," можно использовать для присваивания значения правого операнда левому операнду только в том случае, если левый операнд имеет значение ",["$","span",null,{"className":"code-mini","children":"null"}],".",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["List","<int>"," numbers = null;",["$","br",null,{}],"int? i = null;",["$","br",null,{}],["$","br",null,{}],"numbers ??= new List","<int>","();",["$","br",null,{}],"numbers.Add(i ??= 17);",["$","br",null,{}],"numbers.Add(i ??= 20);",["$","br",null,{}],["$","br",null,{}],"Console.WriteLine(string.Join(\" \", numbers));",["$","br",null,{}],"Console.WriteLine(i);"]}],["$","br",null,{}],["$","div",null,{"className":"prew-terminal","children":[["$","nav",null,{"children":["$","ul",null,{"children":[["$","li",null,{"children":"Terminal"}],["$","li",null,{"className":"new","children":["$","p",null,{"children":"+"}]}]]}]}],["$","div",null,{"className":"terminal","children":["17 17",["$","br",null,{}],"17"]}]]}]]}],["$","li",null,{"children":["Неуправляемые сконструированные типы. Начиная с C# 8.0, сконструированный тип значения является неуправляемым, если он содержит поля исключительно неуправляемых типов (например универсальный тип ","<T>",")."]}],["$","li",null,{"className":"padding-hover-big","children":["Выражение stackalloc во вложенных выражениях. Теперь если результат выражения stackalloc имеет тип ",["$","span",null,{"className":"code-mini","children":"System.Span<T>"}]," или ",["$","span",null,{"className":"code-mini","children":"System.ReadOnlySpan<T>"}],", то его можно использовать в других выражениях.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["Span","<int>"," numbers = stackalloc[] ","{ 1, 2, 3, 4, 5, 6 }",";",["$","br",null,{}],"var ind = numbers.IndexOfAny(stackalloc[] ","{ 2, 4, 6, 8 }",");",["$","br",null,{}],"Console.WriteLine(ind);"]}],["$","br",null,{}],["$","div",null,{"className":"prew-terminal","children":[["$","nav",null,{"children":["$","ul",null,{"children":[["$","li",null,{"children":"Terminal"}],["$","li",null,{"className":"new","children":["$","p",null,{"children":"+"}]}]]}]}],["$","div",null,{"className":"terminal","children":"1"}]]}]]}],["$","li",null,{"children":["Порядок маркеров ",["$","span",null,{"className":"code-mini","children":"$$"}]," и ",["$","span",null,{"className":"code-mini","children":"@"}]," в интерполированных строках verbatim теперь может быть любым."]}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 9.0"}],["$","h4",null,{"children":"Новые возможности в версии 9.0"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"className":"padding-hover-big","children":["Типы записей. Появилась возможность при помощи ключевого слова ",["$","span",null,{"className":"code-mini","children":"record"}]," для определения ссылочного типа, предоставляющего функционал инкапсуляции данных.",["$","div",null,{"className":"code-big-mini","children":"public record User(string FirstName, string LastName);"}],["$","br",null,{}],"По умолчанию типы записей является неизменяемыми. В отличие от других ссылочных типов, переменные типов записей считаются равными, если равны типы и значения их свойств и полей.",["$","br",null,{}],["$","ul",null,{"className":"in-list","children":[["$","li",null,{"children":["Обратимые изменения. Для заданного экземпляра записи при помощи ключевого слова ",["$","span",null,{"className":"code-mini","children":"with"}]," возможно создание копии с изменёнными значениями указанных свойств и полей."]}],["$","li",null,{"children":"Запись может быть унаследована от записи. Однако запись не может быть унаследована от класса, и наоборот, класс не может быть унаследован от записи."}]]}]]}],["$","li",null,{"className":"padding-hover-big","children":["Инициализаторы. C# 9.0 предоставляет синтаксис — ключевое слово ",["$","span",null,{"className":"code-mini","children":"init"}]," — для задания значений свойств класса при инициализации.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public class User",["$","br",null,{}],"{",["$","br",null,{}],"        public string FirstName ","{"," get; init; ","}",["$","br",null,{}],"        public string LastName ","{"," get; init; ","}",["$","br",null,{}],"}",";"]}]]}],["$","li",null,{"children":["Операторы верхнего уровня. Один файл в приложении допускается начать сразу с исполняемых строк кода, минуя ряд таких формальностей, как объявление пространств имён, классов, методов. Такие операторы эквивалентны операторам метода ",["$","span",null,{"className":"code-mini","children":"Main"}],"."]}],["$","li",null,{"children":["Улучшения сопоставлений шаблонов.",["$","br",null,{}],["$","ul",null,{"className":"in-list","children":[["$","li",null,{"children":"Шаблоны типов — соответствуют объекту заданного типа."}],["$","li",null,{"children":["Логические шаблоны — входные данные должны соответствовать заданной логической операции (",["$","span",null,{"className":"code-mini","children":"and"}],", ",["$","span",null,{"className":"code-mini","children":"or"}],", ",["$","span",null,{"className":"code-mini","children":"not"}],")."]}],["$","li",null,{"children":"Реляционные шаблоны — входные данные должны соответствовать заданной операции сравнения (больше, меньше, равно, больше или равно, меньше или равно) с константой."}]]}]]}],["$","li",null,{"children":"Улучшения производительности. "}],["$","li",null,{"className":"padding-hover","children":["Допускается опустить тип создаваемого объекта в выражении ",["$","span",null,{"className":"code-mini","children":"new"}],", если он известен заранее",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["private List","<User>"," persons = new();"]}]]}],["$","li",null,{"children":"Поддержка статических лямбда-выражений и статических анонимных методов. Как и статические локальные функции, они не могут захватывать нестатические локальные переменные и состояния экземпляра."}],["$","li",null,{"children":"Поддержка применения атрибутов к локальным функциям."}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 10.0"}],["$","h4",null,{"children":"Новые возможности в версии 10.0"}],["$","ul",null,{"className":"list-code","children":[["$","li",null,{"children":["Глобальные импорты. С помощью ключевого слова ",["$","span",null,{"className":"code-mini","children":"global"}]," появилась возможность определить пространства имён, которые будут импортированы глобально во всех файлах проекта.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["global using System;",["$","br",null,{}],"global using System.Collections.Generic;"]}]]}],["$","li",null,{"children":["Файловая область видимости пространства имён. Объявление пространства имён может быть применено ко всему файлу, что уменьшает уровень отступов в коде.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":"namespace MyNamespace;"}]]}],["$","li",null,{"children":["Усовершенствованные структуры. Добавлены улучшения в работу со структурами, в том числе возможность инициализации полей непосредственно в теле структуры и поддержка параметров по умолчанию.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public struct Point",["$","br",null,{}],"{",["$","br",null,{}],"        public int X ","{"," get; set; ","}"," = 0;",["$","br",null,{}],"        public int Y ","{"," get; set; ","}"," = 0;",["$","br",null,{}],"{"]}]]}],["$","li",null,{"children":["Запечатанные интерфейсы. Интерфейсы могут быть объявлены как ",["$","span",null,{"className":"code-mini","children":"sealed"}],", что предотвращает их реализацию другими интерфейсами.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public sealed interface IMyInterface ","{ }"]}]]}],["$","li",null,{"children":["Усовершенствованные операторы и литералы. Поддержка ",["$","span",null,{"className":"code-mini","children":"with"}],"-оператора для структурных типов, улучшенные string-интерполяции и другие синтаксические улучшения."]}],["$","li",null,{"children":["Улучшенное сопоставление шаблонов. Добавлены новые возможности для сопоставления шаблонов, включая шаблоны списков и возможность использования шаблонов в операторах ",["$","span",null,{"className":"code-mini","children":"switch"}]," и ",["$","span",null,{"className":"code-mini","children":"if"}],".",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["int[] numbers = ","{ 1, 2, 3, 4, 5 }",";",["$","br",null,{}],"bool isThreeElementArray = numbers is [_, _, _];"]}]]}],["$","li",null,{"children":["Поддержка записи структуры и членов записи. Улучшена производительность при использовании структурных типов с поддержкой записи.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":"public record struct Point(int X, int Y);"}]]}],["$","li",null,{"children":["Усовершенствованные атрибуты. Возможность применения атрибутов к более широкому кругу элементов, таких как локальные функции и выражения.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["[MyCustom]",["$","br",null,{}],"void LocalFunction() ","{ }"]}]]}],["$","li",null,{"children":["Лямбда-выражения. Поддержка более мощных и гибких лямбда-выражений, включая использование типов возврата и деструктуризацию.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["var increment = (int x) ","=>"," x + 1;"]}]]}],["$","li",null,{"children":["Усовершенствованные ",["$","span",null,{"className":"code-mini","children":"async/await"}],". Улучшена работа с асинхронными методами, включая более эффективное управление памятью и потоками."]}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 11.0"}],["$","h4",null,{"children":"Новые возможности в версии 11.0"}],["$","ul",null,{"className":"list-code","children":[["$","li",null,{"children":["Статические виртуальные элементы в интерфейсах. Интерфейсы теперь могут включать статические виртуальные и абстрактные члены, что позволяет перегружать операторы и определять статические свойства и методы. Это упрощает реализацию универсальных математических операций.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public interface IMyInterface","<","TSelf, TOther, TResult",">",["$","br",null,{}],"        where TSelf : IMyInterface","<","TSelf, TOther, TResult",">",["$","br",null,{}],"{",["$","br",null,{}],"        static abstract TResult operator +(TSelf left, TOther right);",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Проверяемые и непроверяемые операторы. Разработчики могут определять ",["$","span",null,{"className":"code-mini","children":"checked"}]," и ",["$","span",null,{"className":"code-mini","children":"unchecked"}]," арифметические операторы, что позволяет компилятору вызывать правильный вариант на основе контекста.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public static checked int operator +(MyType left, MyType right)",["$","br",null,{}],"{",["$","br",null,{}],"        left.Value + right.Value;",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Оператор unsigned right-shift. Введен новый оператор ",["$","span",null,{"className":"code-mini","children":">>>"}],", который выполняет сдвиг вправо без знака, упрощая работу с целочисленными типами.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["int result = -8 ",">>>"," 2;"]}]]}],["$","li",null,{"children":["Ослабленные требования к операторам смены. Второй операнд оператора сдвига больше не обязан быть типа ",["$","span",null,{"className":"code-mini","children":"int"}],", что делает использование универсальных математических интерфейсов более гибким.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["MyType value = new MyType();",["$","br",null,{}],"value ",">>="," 3;"]}]]}],["$","li",null,{"children":["Поддержка универсальной математики. Новые интерфейсы, такие как ",["$","span",null,{"className":"code-mini","children":"System.IAdditionOperators<TSelf, TOther, TResult>"}],", позволяют типам реализовывать математические операции более последовательно и удобно.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public struct MyNumber : ","IAdditionOperators<MyNumber, MyNumber, MyNumber>",["$","br",null,{}],"{",["$","br",null,{}],"        public static MyNumber operator +(MyNumber left, MyNumber right)",["$","br",null,{}],"        ","{",["$","br",null,{}],"        new MyNumber(left.Value + right.Value);",["$","br",null,{}],"        ","}",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Расширенные возможности инициализации типов. Теперь можно задавать значения полей прямо в теле структуры и использовать параметры по умолчанию.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public struct Point",["$","br",null,{}],"{",["$","br",null,{}],"        public int X ","{"," get; set; ","}"," = 0;",["$","br",null,{}],"        public int Y ","{"," get; set; ","}"," = 0;",["$","br",null,{}],"}"]}]]}]]}],["$","br",null,{}],["$","h3",null,{"children":"Версия 12.0"}],["$","h4",null,{"children":"Новые возможности в версии 12.0["}],["$","ul",null,{"className":"list-code","children":[["$","li",null,{"children":["Статические абстрактные и виртуальные методы в интерфейсах. Интерфейсы теперь могут содержать статические абстрактные и виртуальные методы, что позволяет определять поведение для универсальных математических операций.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public interface ","IMyInterface<TSelf, TOther, TResult>",["$","br",null,{}],"        where TSelf : ","IMyInterface<TSelf, TOther, TResult>"," ",["$","br",null,{}],"{"," ",["$","br",null,{}],"        static abstract TResult operator +(TSelf left, TOther right);",["$","br",null,{}],"        static virtual TResult Add(TSelf left, TOther right)",["$","br",null,{}],"        ","{",["$","br",null,{}],"                return left + right;",["$","br",null,{}],"        ","}",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Поддержка коллекций с неизменяемыми элементами. Введена новая коллекция ",["$","span",null,{"className":"code-mini","children":"ImmutableArray"}],", которая обеспечивает неизменяемость элементов и повышение производительности.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":"var immutableArray = ImmutableArray.Create(1, 2, 3, 4);"}]]}],["$","li",null,{"children":["Улучшенные структуры данных. В C# 12 введены новые типы данных, такие как ",["$","span",null,{"className":"code-mini","children":"readonly struct"}]," и ",["$","span",null,{"className":"code-mini","children":"ref readonly struct"}],", для оптимизации работы с памятью.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public readonly struct Point",["$","br",null,{}],"{",["$","br",null,{}],"        public int X ","{"," get; ","}",["$","br",null,{}],"        public int Y ","{"," get; ","}",["$","br",null,{}],["$","br",null,{}],"        public Point(int x, int y)",["$","br",null,{}],"        ","{",["$","br",null,{}],"                X = x;",["$","br",null,{}],"                Y = y;",["$","br",null,{}],"        ","{",["$","br",null,{}],"}"]}]]}],["$","li",null,{"children":["Расширенные возможности для типов записи. Теперь записи поддерживают наследование и могут содержать методы с телами.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public record Person(string Name)",["$","br",null,{}],"{",["$","br",null,{}],"        public virtual string GetName() ","=>"," Name;",["$","br",null,{}],"}",["$","br",null,{}],["$","br",null,{}],"public record Employee(string Name, int EmployeeId) : Person(Name)",["$","br",null,{}],"{",["$","br",null,{}],"        public override string GetName() ","=>"," $\"","{","Name","}"," (ID: ","{","EmployeeId","}",")\";",["$","br",null,{}],"{"]}]]}],["$","li",null,{"children":["Поддержка типов с произвольным количеством параметров. Введены новые методы для работы с переменным числом параметров, упрощая использование таких типов в коде.",["$","br",null,{}],["$","div",null,{"className":"code-big-mini","children":["public void PrintValues(params int[] values)",["$","br",null,{}],"{",["$","br",null,{}],"        foreach (var value in values)",["$","br",null,{}],"        ","{",["$","br",null,{}],"                Console.WriteLine(value);",["$","br",null,{}],"        ","}",["$","br",null,{}],"}",["$","br",null,{}],["$","br",null,{}],"PrintValues(1, 2, 3, 4);"]}]]}],["$","li",null,{"children":"Расширенные возможности компилятора. В C# 12 компилятор получил новые возможности для оптимизации и проверки кода, включая улучшенную поддержку анализаторов и генераторов исходного кода."}]]}],["$","br",null,{}],["$","br",null,{}],["$","h2",null,{"children":"Пример «Hello, World!»"}],["$","p",null,{"children":["Ниже представлен код классической программы «Hello world» на C# для консольного приложения:",["$","br",null,{}]]}],["$","div",null,{"className":"code","children":"Console.WriteLine(\"Hello World!\");"}],["$","br",null,{}],["$","p",null,{"children":["и код этой же программы для приложения Windows Forms:",["$","br",null,{}]]}],["$","div",null,{"className":"code","children":["namespace WindowsForms;",["$","br",null,{}],["$","br",null,{}],"public class Program ",["$","br",null,{}],"{",["$","br",null,{}],"        [STAThread]",["$","br",null,{}],"        public static void Main() ","=>"," new DemoForm().ShowDialog();",["$","br",null,{}],"}",["$","br",null,{}],["$","br",null,{}],"public class DemoForm : Form",["$","br",null,{}],"{",["$","br",null,{}],"        Label label = new Label();",["$","br",null,{}],["$","br",null,{}],"        public DemoForm()",["$","br",null,{}],"        ","{",["$","br",null,{}],"                label.Text = \"Hello World!\";",["$","br",null,{}],"                this.Controls.Add(label);",["$","br",null,{}],"                this.StartPosition = FormStartPosition.CenterScreen;",["$","br",null,{}],"                this.BackColor = Color.White;",["$","br",null,{}],"                this.FormBorderStyle = FormBorderStyle.Fixed3D;",["$","br",null,{}],"        ","}",["$","br",null,{}],"}"]}],["$","br",null,{}],["$","br",null,{}],["$","h2",null,{"children":"Реализации"}],["$","p",null,{"children":"Существует несколько реализаций C#:"}],["$","ul",null,{"className":"list","children":[["$","li",null,{"children":["Компилятор Roslyn c открытым ",["$","a",null,{"href":"https://github.com/dotnet/roslyn","className":"link-other","children":"исходным кодом"}]]}],["$","li",null,{"children":"Реализация C# в виде компилятора csc.exe включена в состав .NET Framework (включая .NET Micro Framework, .NET Compact Framework и его реализации под Silverlight и Windows Phone 7)."}],["$","li",null,{"children":"В составе проекта Rotor (Shared Source Common Language Infrastructure) компании Microsoft."}],["$","li",null,{"children":"Проект Mono включает в себя реализацию C# с открытым исходным кодом."}],["$","li",null,{"children":"Проект DotGNU также включает компилятор C# с открытым кодом."}],["$","li",null,{"children":"DotNetAnywhere — ориентированная на встраиваемые системы реализация CLR, поддерживает практически всю спецификацию C# 2.0."}]]}]]}]]}],null,["$","$L7",null,{"children":"$L8"}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","rQXX18elhgv8hPKBEplck",{"children":[["$","$L9",null,{"children":"$La"}],["$","$Lb",null,{"children":"$Lc"}],null]}]]}],false]],"m":"$undefined","G":["$d","$undefined"],"s":false,"S":true}
c:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"C#"}],["$","meta","2",{"name":"description","content":"Язык програмиорование C#"}]]
8:null
